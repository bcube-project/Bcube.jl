var documenterSearchIndex = {"docs":
[{"location":"manual/assembler/#Assemble-(bi)linear-forms","page":"Assemble (bi)linear forms","title":"Assemble (bi)linear forms","text":"","category":"section"},{"location":"manual/assembler/","page":"Assemble (bi)linear forms","title":"Assemble (bi)linear forms","text":"todo: \nThis page is under construction. Checkout the API reference for more details.","category":"page"},{"location":"manual/assembler/#Apply-dirichlet-conditions","page":"Assemble (bi)linear forms","title":"Apply dirichlet conditions","text":"","category":"section"},{"location":"api/operator/operator/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"api/dof/dof/#dof","page":"Degree of freedom","title":"Degree of freedom","text":"","category":"section"},{"location":"api/dof/dof/#Assembler","page":"Degree of freedom","title":"Assembler","text":"","category":"section"},{"location":"api/dof/dof/#Bcube.AbstractBilinearFaceSidePair","page":"Degree of freedom","title":"Bcube.AbstractBilinearFaceSidePair","text":"AbstractBilinearFaceSidePair{A} <: AbstractLazyWrap{A}\n\nInterface:\n\n* get_args_bilinear(a::AbstractBilinearFaceSidePair)\n\n\n\n\n\n","category":"type"},{"location":"api/dof/dof/#Bcube.AbstractFaceSidePair","page":"Degree of freedom","title":"Bcube.AbstractFaceSidePair","text":"AbstractFaceSidePair{A} <: AbstractLazyWrap{A}\n\nInterface:\n\nside_n(a::AbstractFaceSidePair)\nside_p(a::AbstractFaceSidePair)\n\n\n\n\n\n","category":"type"},{"location":"api/dof/dof/#Bcube.__assemble_linear!-Tuple{Any, Any, Any, Measure, Bcube.AbstractBcubeBackend}","page":"Degree of freedom","title":"Bcube.__assemble_linear!","text":"Dev notes\n\nTwo levels of \"LazyMapOver\" because first we LazyMapOver the Tuple of argument of the linear form, and the for each item of this Tuple we LazyMapOver the shape functions.\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._append_contribution!-Tuple{Any, Any, Any, Any, Any, Any, Bcube.CellInfo, Any, Bcube.AbstractBcubeBackend}","page":"Degree of freedom","title":"Bcube._append_contribution!","text":"bilinear case\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._assemble_linear!-Tuple{Any, Any, Any, Bcube.Integration, Bcube.AbstractBcubeBackend}","page":"Degree of freedom","title":"Bcube._assemble_linear!","text":"_assemble_linear!(b, l, V, integration::Integration, backend::AbstractBcubeBackend)\n_assemble_linear!(b, l, V, integration::MultiIntegration{N}, backend::AbstractBcubeBackend) where {N}\n\nThese functions act as a function barrier in order to:\n\nget the function corresponding to the operand in the linear form\nreshape b internally to deal with cases when V is a AbstractMultiTestFESpace\ncall __assemble_linear! to apply dispatch on the type of measure of the integration and improve type stability during the assembling loop.\n\nDev note:\n\nThe case integration::MultiIntegration{N} is treated by looping over each Integration contained in the MultiIntegration\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._blockmap_bilinear-Union{Tuple{N2}, Tuple{N1}, Tuple{Tuple{Vararg{T, N1}} where T, Tuple{Vararg{T, N2}} where T}} where {N1, N2}","page":"Degree of freedom","title":"Bcube._blockmap_bilinear","text":"From tuples a=(a_1 a_2  a_i  a_m) and b=(b_1 b_2  b_j  b_n), it builds A and B which correspond formally to the following two matrices :\n\nA equiv beginpmatrix\na_1  a_1    a_1\na_2  a_2    a_2\n            \na_m  a_m    a_m\nendpmatrix\nqquad and qquad\nB equiv beginpmatrix\nb_1  b_2    b_n\nb_1  b_2    b_n\n            \nb_1  b_2    b_n\nendpmatrix\n\nA and B are wrapped in LazyMapOver structures so that all operations on them are done elementwise by default (in other words, it can be considered that the operations are automatically broadcasted).\n\nDev note :\n\nBoth A and B are stored as a tuple of tuples, wrapped by LazyMapOver, where inner tuples correspond to each columns of a matrix. This hierarchical structure reduces both inference and compile times by avoiding the use of large tuples.\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._diag_tuples-Union{Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Any}} where N","page":"Degree of freedom","title":"Bcube._diag_tuples","text":"_diag_tuples(diag::Tuple{Vararg{Any,N}}, b) where N\n\nReturn N tuples of length N. For each tuple tᵢ, its values are defined so that tᵢ[k]=diag[k] if k==i, tᵢ[k]=b otherwise. The result can be seen as a dense diagonal-like array using tuple.\n\nExample for N=3:\n\n(diag[1],  b,       b      ),\n(b,        diag[2], b      ),\n(b,        b,       diag[3]))\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._get_multi_tuple_var-Union{Tuple{Tuple{Vararg{Any, N}}}, Tuple{N}} where N","page":"Degree of freedom","title":"Bcube._get_multi_tuple_var","text":"For N=3 for example:     (LazyMapOver((LazyMapOver(V[1]), NullOperator(),  NullOperator())),      LazyMapOver((NullOperator(),  LazyMapOver(V[2]), NullOperator())),      LazyMapOver((NullOperator(),  NullOperator(),  LazyMapOver(V[3]))))\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._may_reshape_b-Tuple{AbstractVector, TestFESpace}","page":"Degree of freedom","title":"Bcube._may_reshape_b","text":"For AbstractMultiTestFESpace, it creates a Tuple (of views) of the different \"destination\" in the vector: one for each FESpace\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.assemble_bilinear!-Tuple{Any, Any, Any, Any, Measure, TrialFESpace, TestFESpace, Bcube.AbstractBcubeBackend}","page":"Degree of freedom","title":"Bcube.assemble_bilinear!","text":"assemble_bilinear!(I, J, X, f, measure::Measure, U::TrialFESpace, V::TestFESpace, backend::BcubeBackendCPUSerial)\n\nIn-place version of assemble_bilinear.\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.assemble_bilinear-Union{Tuple{N}, Tuple{Function, Union{Bcube.AbstractMultiFESpace{N, <:Tuple{Vararg{TrialFESpace, N}}}, TrialFESpace}, Union{Bcube.AbstractMultiFESpace{N, <:Tuple{Vararg{TestFESpace, N}}}, TestFESpace}}} where N","page":"Degree of freedom","title":"Bcube.assemble_bilinear","text":"assemble_bilinear(a::Function, U, V; T = Float64, backend::AbstractBcubeBackend = get_bcube_backend())\n\nAssemble the (sparse) Matrix corresponding to the given bilinear form a on the trial and test finite element spaces U and V.\n\nFor the in-place version, check-out assemble_bilinear!.\n\nArguments\n\na::Function : function of two variables (u,v) representing the bilinear form\nU : trial finite element space (for u)\nV : test finite element space (for v)\n\nExamples\n\njulia> mesh = rectangle_mesh(3,3)\njulia> U = TrialFESpace(FunctionSpace(:Lagrange, 0), mesh)\njulia> V = TestFESpace(U)\njulia> dΩ = Measure(CellDomain(mesh), 3)\njulia> a(u, v) = ∫(u * v)dΩ\njulia> assemble_bilinear(a, U, V)\n4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n 0.25   ⋅     ⋅     ⋅\n  ⋅    0.25   ⋅     ⋅\n  ⋅     ⋅    0.25   ⋅\n  ⋅     ⋅     ⋅    0.25\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.assemble_linear!-Tuple{AbstractVector, Function, Union{Bcube.AbstractMultiFESpace{N, <:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}}","page":"Degree of freedom","title":"Bcube.assemble_linear!","text":"assemble_linear!(b::AbstractVector, l::Function, V::Union{TestFESpace, AbstractMultiTestFESpace}; backend::AbstractBcubeBackend = get_bcube_backend())\n\nIn-place version of assemble_linear.\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.assemble_linear-Tuple{Function, Union{Bcube.AbstractMultiFESpace{N, <:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}}","page":"Degree of freedom","title":"Bcube.assemble_linear","text":"assemble_linear(l::Function, V::Union{TestFESpace, AbstractMultiTestFESpace}; T = Float64, backend::AbstractBcubeBackend = get_bcube_backend())\n\nAssemble the vector corresponding to a linear form l on the finite element space V\n\nFor the in-place version, checkout assemble_linear!.\n\nArguments\n\nl::Function : linear form to assemble, a function of one variable l(v)\nV : test finite element space\n\nExamples\n\njulia> mesh = rectangle_mesh(3,3)\njulia> U = TrialFESpace(FunctionSpace(:Lagrange, 0), mesh)\njulia> V = TestFESpace(U)\njulia> dΩ = Measure(CellDomain(mesh), 3)\njulia> l(v) = ∫(v)dΩ\njulia> assemble_linear(l, V)\n4-element Vector{Float64}:\n 0.25\n 0.25\n 0.25\n 0.25\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.blockmap_bilinear_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractFESpace, Bcube.AbstractCellInfo}","page":"Degree of freedom","title":"Bcube.blockmap_bilinear_shape_functions","text":"Dev notes:\n\nReturn blockU and blockV to be able to compute the local matrix corresponding to the bilinear form :\n\n    Aij = a(λᵤj λᵥi)\n\nwhere λᵤ and λᵥ are the shape functions associated with the trial U and the test V function spaces respectively. In a \"map-over\" version, it can be written :\n\n    A = a(blockU blockV)\n\nwhere blockU and blockV correspond formally to the lazy-map-over matrices :\n\n    k blockUkj = λᵤj\n        blockVik = λᵥi\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.blockmap_shape_functions-Tuple{Any, Bcube.FaceInfo}","page":"Degree of freedom","title":"Bcube.blockmap_shape_functions","text":"Dev note :\n\nMaterialize the integrand function on all the different possible Tuples of v=(v1,0,0,...), (0,v2,0,...), ..., (..., vi, ...)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.blockmap_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractCellInfo}","page":"Degree of freedom","title":"Bcube.blockmap_shape_functions","text":"blockmap_shape_functions(fespace::AbstractFESpace, cellinfo::AbstractCellInfo)\n\nReturn all shape functions a = LazyMapOver((λ₁, λ₂, …, λₙ)) corresponding to fespace in cell cellinfo. These shape functions are wrapped by a LazyMapOver so that for a function f it gives:     f(a) == map(f, a)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.blockmap_shape_functions-Tuple{Bcube.AbstractMultiFESpace, Bcube.AbstractCellInfo}","page":"Degree of freedom","title":"Bcube.blockmap_shape_functions","text":"blockmap_shape_functions(multiFESpace::AbstractMultiFESpace, cellinfo::AbstractCellInfo)\n\nReturn all shape functions corresponding to each fespace in multiFESSpace for cell cellinfo :\n\n    ((v₁   ) ( v₂  )  (    vₙ))\n\nwhere:\n\nvᵢ = (λᵢ₁, λᵢ₂, …, λᵢ_ₘ) are the shapes functions of the i-th fespace in the cell.\n∅ are NullOperators\n\nNote that the LazyMapOver is used to wrap recursively the result.\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.compute-Tuple{Bcube.Integration}","page":"Degree of freedom","title":"Bcube.compute","text":"compute(integration::Integration)\n\nCompute an integral, independently from a FEM/DG framework (i.e without FESpace)\n\nReturn a SparseVector. The indices of the domain elements are used to store the result of the integration in this sparse vector.\n\nExample\n\nCompute volume of each cell and each face.\n\nmesh = rectangle_mesh(2, 3)\ndΩ = Measure(CellDomain(mesh), 1)\ndΓ = Measure(BoundaryFaceDomain(mesh), 1)\nf = PhysicalFunction(x -> 1)\n@show Bcube.compute(∫(f)dΩ)\n@show Bcube.compute(∫(side⁻(f))dΓ)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#DofHandler","page":"Degree of freedom","title":"DofHandler","text":"","category":"section"},{"location":"api/dof/dof/#Bcube.DofHandler","page":"Degree of freedom","title":"Bcube.DofHandler","text":"The DofHandler handles the degree of freedom numbering. To each degree of freedom is associated a unique integer.\n\n\n\n\n\n","category":"type"},{"location":"api/dof/dof/#Bcube.DofHandler-Tuple{Bcube.Mesh, Bcube.AbstractFunctionSpace, Int64, Bool}","page":"Degree of freedom","title":"Bcube.DofHandler","text":"DofHandler(mesh::Mesh, fSpace::AbstractFunctionSpace, ncomponents::Int, isContinuous::Bool)\n\nConstructor of a DofHandler for a SingleFESpace on a Mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._deal_with_dofs_on_edges!-Tuple{Dict{Tuple{Int64, Set{Int64}}, Tuple{Int64, Vector{Int64}}}, Any, Any, Any, Any, Int64, Any, Bcube.AbstractShape, Int64, Bcube.AbstractFunctionSpace}","page":"Degree of freedom","title":"Bcube._deal_with_dofs_on_edges!","text":"deal_with_dofs_on_edges!(dict, iglob, offset, c2n, celltypes, icell::Int, inodes_g, e2n_g, s::AbstractShape, kvar::Int, fs)\n\nFunction dealing with dofs shared by different cell through an edge connection (excluding bord vertices).\n\nTODO : remove kvar\n\nArguments\n\ndict may be modified by this routine\niglob may be modified by this routine\noffset may be modified by this routine\nfs : FunctionSpace of var kvar\nicell : cell index\nkvar : var index\ns : shape of icell-th cell\ninodes_g : global indices of nodes of icell\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._deal_with_dofs_on_faces!-Tuple{Any, Any, Any, Any, Any, Int64, Vector{Vector{Int64}}, Bcube.AbstractShape, Bcube.AbstractFunctionSpace, Int64}","page":"Degree of freedom","title":"Bcube._deal_with_dofs_on_faces!","text":"TODO : remove kvar\n\nArguments\n\nf2n_g : local face index -> global nodes indices\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._deal_with_dofs_on_vertices!-Tuple{Dict{Tuple{Int64, Int64}, Tuple{Int64, Vector{Int64}}}, Any, Any, Int64, Any, Bcube.AbstractShape, Int64, Bcube.AbstractFunctionSpace}","page":"Degree of freedom","title":"Bcube._deal_with_dofs_on_vertices!","text":"deal_with_dofs_on_vertices!(dict, iglob, offset, icell::Int, inodes_g, s::AbstractShape, kvar::Int, fs)\n\nFunction dealing with dofs shared by different cell through a vertex connection.\n\nTODO : remove kvar\n\nArguments\n\ndict may be modified by this routine\niglob may be modified by this routine\noffset may be modified by this routine\nfs : FunctionSpace of var kvar\nicell : cell index\nkvar : var index\ns : shape of icell-th cell\ninodes_g : global indices of nodes of icell\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.get_dof-Tuple{Bcube.DofHandler, Any, Int64, Int64}","page":"Degree of freedom","title":"Bcube.get_dof","text":"get_dof(dhl::DofHandler, icell, icomp::Int, idof::Int)\n\nGlobal index of the idof local degree of freedom of component icomp in cell icell.\n\nExample\n\nmesh = one_cell_mesh(:line)\ndhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))\n@show get_dof(dhl, 1, 1, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.get_dof-Tuple{Bcube.DofHandler, Any, Int64}","page":"Degree of freedom","title":"Bcube.get_dof","text":"get_dof(dhl::DofHandler, icell, icomp::Int)\n\nGlobal indices of all the dofs of a given component in a given cell\n\nExample\n\nmesh = one_cell_mesh(:line)\ndhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))\n@show get_dof(dhl, 1, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.get_ncomponents-Tuple{Bcube.DofHandler}","page":"Degree of freedom","title":"Bcube.get_ncomponents","text":"Number of components handled by a DofHandler\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.get_ndofs-Tuple{Bcube.DofHandler, Any, AbstractVector{Int64}}","page":"Degree of freedom","title":"Bcube.get_ndofs","text":"get_ndofs(dhl, icell, icomp::Vector{Int})\n\nNumber of dofs for a given set of components in a given cell.\n\nExample\n\nmesh = one_cell_mesh(:line)\ndhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1); size = 2))\n@show get_ndofs(dhl, 1, [1, 2])\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.get_ndofs-Tuple{Bcube.DofHandler, Any, Int64}","page":"Degree of freedom","title":"Bcube.get_ndofs","text":"get_ndofs(dhl, icell, kvar::Int)\n\nNumber of dofs for a given variable in a given cell.\n\nExample\n\nmesh = one_cell_mesh(:line)\ndhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))\n@show get_ndofs(dhl, 1, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.get_ndofs-Tuple{Bcube.DofHandler, Any}","page":"Degree of freedom","title":"Bcube.get_ndofs","text":"get_ndofs(dhl::DofHandler, icell)\n\nNumber of dofs for a given cell.\n\nNote that for a vector variable, the total (accross all components) number of dofs is returned.\n\nExample\n\nmesh = one_cell_mesh(:line)\ndhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))\n@show get_ndofs(dhl, 1, :u)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.get_ndofs-Tuple{Bcube.DofHandler}","page":"Degree of freedom","title":"Bcube.get_ndofs","text":"get_ndofs(dhl::DofHandler)\n\nTotal number of dofs. This function takes into account that dofs can be shared by multiple cells.\n\nExample\n\nmesh = one_cell_mesh(:line)\ndhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))\n@show get_ndofs(dhl::DofHandler)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.max_ndofs-Tuple{Bcube.DofHandler}","page":"Degree of freedom","title":"Bcube.max_ndofs","text":"max_ndofs(dhl::DofHandler)\n\nCount maximum number of dofs per cell, all components mixed\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Finite-element-spaces","page":"Finite element spaces","title":"Finite element spaces","text":"","category":"section"},{"location":"api/interpolation/fespace/#Bcube.AbstractFESpace","page":"Finite element spaces","title":"Bcube.AbstractFESpace","text":"Abstract type to represent an finite-element space of size S. See SingleFESpace for more details about what looks like a finite-element space.\n\nDevs notes\n\nAll subtypes should implement the following functions:\n\nget_function_space(feSpace::AbstractFESpace)\nget_shape_functions(feSpace::AbstractFESpace, shape::AbstractShape)\nget_cell_shape_functions(feSpace::AbstractFESpace, shape::AbstractShape)\nget_ndofs(feSpace::AbstractFESpace)\nis_continuous(feSpace::AbstractFESpace)\n\nAlternatively, you may define a \"parent\" to your structure by implementing the Base.parent function. Then, all the above functions will be redirected to the \"parent\" FESpace.\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.AbstractMultiFESpace","page":"Finite element spaces","title":"Bcube.AbstractMultiFESpace","text":"Devs notes\n\nAll subtypes should implement the following functions:\n\nget_fespace(mfeSpace::AbstractMultiFESpace)\nget_mapping(mfeSpace::AbstractMultiFESpace)\nget_dofs(mfeSpace::AbstractMultiFESpace, icell::Int)\nget_shape_functions(mfeSpace::AbstractMultiFESpace, shape::AbstractShape)\nget_cell_shape_functions(mfeSpace::AbstractMultiFESpace, shape::AbstractShape)\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.MultiFESpace","page":"Finite element spaces","title":"Bcube.MultiFESpace","text":"A MultiFESpace represents a \"set\" of TrialFESpace or TestFESpace. This structure provides a global dof numbering for each FESpace.\n\nN is the number of FESpace contained in this MultiFESpace.\n\nNote that the FESpace can be different from each other (one continous, one discontinuous; one scalar, one vector...)\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.MultiFESpace-Union{Tuple{Tuple{Vararg{Union{TestFESpace{S, FE}, TrialFESpace{S, FE}} where {S, FE}, N}}}, Tuple{N}} where N","page":"Finite element spaces","title":"Bcube.MultiFESpace","text":"MultiFESpace(\n    feSpaces::Tuple{Vararg{TrialOrTest, N}};\n    arrayOfStruct::Bool = AOS_DEFAULT,\n) where {N}\nMultiFESpace(\n    feSpaces::AbstractArray{FE};\n    arrayOfStruct::Bool = AOS_DEFAULT,\n) where {FE <: TrialOrTest}\nMultiFESpace(feSpaces::Vararg{TrialOrTest}; arrayOfStruct::Bool = AOS_DEFAULT)\n\nBuild a finite element space representing several sub- finite element spaces.\n\nThis is particulary handy when several variables are in play since it provides a global dof numbering (for the whole system). The finite element spaces composing the MultiFESpace can be different from each other (some continuous, some discontinuous, some scalar, some vectors...).\n\nArguments\n\nfeSpaces : the finite element spaces composing the MultiFESpace.   Note that they must be of type TrialFESpace or TestFESpace.\n\nKeywords\n\narrayOfStruct::Bool = AOS_DEFAULT : indicates if the dof numbering should be of type \"Array of Structs\" (AoS)   or \"Struct of Arrays\" (SoA).\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.SingleFESpace","page":"Finite element spaces","title":"Bcube.SingleFESpace","text":"SingleFESpace(\n    fSpace::AbstractFunctionSpace,\n    mesh::AbstractMesh,\n    dirichletBndNames = String[];\n    size::Int = 1,\n    isContinuous::Bool = true,\n    kwargs...\n)\n\nBuild a finite element space (scalar or vector) from a FunctionSpace and a Mesh.\n\nArguments\n\nfSpace::AbstractFunctionSpace : the function space associated to the FESpace\nmesh::AbstractMesh : the mesh on which the FESpace is discretized\ndirichletBndNames = String[] : list of mesh boundary labels where a Dirichlet condition applies\n\nKeywords\n\nsize::Int = 1 : the number of components of the FESpace\nisContinuous::Bool = true : if true, a continuous dof numbering is created. Otherwise, dof lying\n\non cell nodes or cell faces are duplicated, not shared (discontinuous dof numbering)\n\nkwargs : for things such as parallel cache (internal/dev usage only)\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.SingleFESpace-2","page":"Finite element spaces","title":"Bcube.SingleFESpace","text":"An finite-element space (FESpace) is basically a function space, associated to degrees of freedom (on a mesh).\n\nA FESpace can be either scalar (to represent a Temperature for instance) or vector (to represent a Velocity). In case of a \"vector\" SingleFESpace, all the components necessarily share the same FunctionSpace.\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.TestFESpace","page":"Finite element spaces","title":"Bcube.TestFESpace","text":"TestFESpace(trialFESpace::TrialFESpace)\nTestFESpace(\n    fSpace::AbstractFunctionSpace,\n    mesh::AbstractMesh,\n    dirichletBndNames = String[];\n    size::Int = 1,\n    isContinuous::Bool = true,\n    kwargs...,\n)\n\nBuild a test finite element space.\n\nA TestFESpace can be built from a TrialFESpace. See SingleFESpace for hints about the function arguments. Only arguments specific to TrialFESpace are detailed below.\n\nExamples\n\njulia> mesh = one_cell_mesh(:line)\njulia> fSpace = FunctionSpace(:Lagrange, 2)\njulia> U = TrialFESpace(fSpace, mesh)\njulia> V = TestFESpace(U)\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.TestFESpace-2","page":"Finite element spaces","title":"Bcube.TestFESpace","text":"A TestFESpace is basically a SingleFESpace plus other attributes (related to boundary conditions)\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.TrialFESpace","page":"Finite element spaces","title":"Bcube.TrialFESpace","text":"TrialFESpace(feSpace, dirichletValues)\nTrialFESpace(\n    fSpace::AbstractFunctionSpace,\n    mesh::AbstractMesh,\n    dirichlet::Dict{String} = Dict{String, Any}();\n    size::Int = 1,\n    isContinuous::Bool = true,\n    kwargs...\n)\nTrialFESpace(\n    fSpace::AbstractFunctionSpace,\n    mesh::AbstractMesh,\n    type::Symbol,\n    dirichlet::Dict{String} = Dict{String, Any}();\n    size::Int = 1,\n    kwargs...\n)\n\nBuild a trial finite element space.\n\nSee SingleFESpace for hints about the function arguments. Only arguments specific to TrialFESpace are detailed below.\n\nArguments\n\ndirichlet::Dict{String} = Dict{String, Any}() : dictionnary specifying the Dirichlet   valued-function (or function) associated to each mesh boundary label. The function f(x,t)   to apply is expressed in the physical coordinate system. Alternatively, a constant value   can be provided instead of a function.\ntype::Symbol : :continuous or :discontinuous\n\nWarning\n\nFor now the Dirichlet condition can only be applied to nodal bases.\n\nExamples\n\njulia> mesh = one_cell_mesh(:line)\njulia> fSpace = FunctionSpace(:Lagrange, 2)\njulia> U = TrialFESpace(fSpace, mesh)\njulia> V = TrialFESpace(fSpace, mesh, :discontinuous; size = 3)\njulia> W = TrialFESpace(fSpace, mesh, Dict(\"North\" => 3., \"South\" => (x,t) -> t .* x))\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.TrialFESpace-2","page":"Finite element spaces","title":"Bcube.TrialFESpace","text":"A TrialFESpace is basically a SingleFESpace plus other attributes (related to boundary conditions)\n\nDev notes\n\nwe cannot directly store Dirichlet values on dofs because the Dirichlet values needs \"time\" to apply\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.MultiplierFESpace","page":"Finite element spaces","title":"Bcube.MultiplierFESpace","text":"A MultiplierFESpace can be viewed as a set of independent P0 elements. It is used to define Lagrange multipliers and assemble the associated augmented system (the system that adds the multipliers as unknowns).\n\n\n\n\n\n","category":"function"},{"location":"api/interpolation/fespace/#Bcube._MultiFESpace-Union{Tuple{Tuple{Vararg{Union{TestFESpace{S, FE}, TrialFESpace{S, FE}} where {S, FE}, N}}}, Tuple{N}} where N","page":"Finite element spaces","title":"Bcube._MultiFESpace","text":"Low-level constructor \n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube._build_mapping_AoS-Tuple{Tuple{Vararg{Union{TestFESpace{S, FE}, TrialFESpace{S, FE}} where {S, FE}}}, Int64}","page":"Finite element spaces","title":"Bcube._build_mapping_AoS","text":"Build a global numbering using an Array-Of-Struct strategy\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube._build_mapping_SoA-Tuple{Tuple{Vararg{Union{TestFESpace{S, FE}, TrialFESpace{S, FE}} where {S, FE}}}, Int64}","page":"Finite element spaces","title":"Bcube._build_mapping_SoA","text":"Build a global numbering using an Struct-Of-Array strategy \n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.allocate_dofs","page":"Finite element spaces","title":"Bcube.allocate_dofs","text":"allocate_dofs(feSpace::AbstractFESpace, T = Float64)\n\nAllocate a vector with a size equal to the number of dof of the FESpace, with the type T. For a MultiFESpace, a vector of the total size of the space is returned (and not a Tuple of vectors)\n\n\n\n\n\n","category":"function"},{"location":"api/interpolation/fespace/#Bcube.build_jacobian_sparsity_pattern-Tuple{TrialFESpace, Bcube.AbstractMesh}","page":"Finite element spaces","title":"Bcube.build_jacobian_sparsity_pattern","text":"build_jacobian_sparsity_pattern(u::AbstractMultiFESpace, mesh::AbstractMesh)\n\nBuild the jacobian sparsity pattern corresponding to the \"FESpace U\".\n\nA jacobian is associated to a given function, here this function is assumed to mix (i.e \"link\") all the variables of the FESpace together.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_cell_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractShape}","page":"Finite element spaces","title":"Bcube.get_cell_shape_functions","text":"Return the shape functions associated to the AbstractFESpace in \"packed\" form:  λ(x) = (λ₁(x),...,λᵢ(x),...λₙ(x)) for the n dofs.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_dirichlet_boundary_tags-Tuple{Bcube.AbstractFESpace}","page":"Finite element spaces","title":"Bcube.get_dirichlet_boundary_tags","text":"Return the boundary tags where a Dirichlet condition applies\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_dirichlet_values-Tuple{TrialFESpace}","page":"Finite element spaces","title":"Bcube.get_dirichlet_values","text":"Return the values associated to a Dirichlet condition\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_dofs-Tuple{Bcube.AbstractFESpace, Int64}","page":"Finite element spaces","title":"Bcube.get_dofs","text":"Return the dofs indices for the cell icell\n\nResult is an array of integers.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_dofs-Tuple{MultiFESpace, Int64}","page":"Finite element spaces","title":"Bcube.get_dofs","text":"get_dofs(feSpace::MultiFESpace, icell::Int)\n\nReturn the dofs indices for the cell icell for each single-feSpace. Result is a tuple of array of integers, where each array of integers are the indices relative to the numbering of each singleFESpace.\n\nWarning:\n\nCombine get_dofs with get_mapping if global dofs indices are needed.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_fespace-Tuple{Bcube.AbstractMultiFESpace}","page":"Finite element spaces","title":"Bcube.get_fespace","text":"get_fespace(mfeSpace::AbstractMultiFESpace, iSpace)\nget_fespace(mfeSpace::AbstractMultiFESpace)\n\nReturn the i-th FESpace composing this AbstractMultiFESpace. If no index is provided, the tuple of FESpace composing this AbstractMultiFESpace` is returnted.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_fespace-Tuple{MultiFESpace}","page":"Finite element spaces","title":"Bcube.get_fespace","text":"Return the tuple of FESpace composing this MultiFESpace\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_function_space-Tuple{Bcube.AbstractFESpace}","page":"Finite element spaces","title":"Bcube.get_function_space","text":"Return the FunctionSpace (eventually multiple spaces) associated to the AbstractFESpace.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_mapping-Tuple{Bcube.AbstractMultiFESpace}","page":"Finite element spaces","title":"Bcube.get_mapping","text":"get_mapping(mfeSpace::AbstractMultiFESpace, iSpace)\nget_mapping(mfeSpace::AbstractMultiFESpace)\n\nReturn the mapping for the ith FESpace composing the MultiFESpace. If no index is provided, the tuple of mapping for each FESpace` is returnted.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_n_fespace-Union{Tuple{Bcube.AbstractMultiFESpace{N}}, Tuple{N}} where N","page":"Finite element spaces","title":"Bcube.get_n_fespace","text":"Number of FESpace composing the MultiFESpace \n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_ncomponents-Tuple{Bcube.AbstractFESpace}","page":"Finite element spaces","title":"Bcube.get_ncomponents","text":"Return the size S(= number of components) associated to AbstractFESpace{S}.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_ndofs-Tuple{Bcube.AbstractFESpace}","page":"Finite element spaces","title":"Bcube.get_ndofs","text":"Return the total number of dofs of the FESpace, taking into account the continuous/discontinuous type of the space. If the FESpace contains itself several FESpace (see MultiFESpace), the sum of all dofs is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_ndofs-Tuple{Bcube.AbstractMultiFESpace}","page":"Finite element spaces","title":"Bcube.get_ndofs","text":"Total number of dofs contained in this MultiFESpace \n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractShape}","page":"Finite element spaces","title":"Bcube.get_shape_functions","text":"Return the shape functions associated to the AbstractFESpace.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_size-Union{Tuple{Bcube.AbstractFESpace{S}}, Tuple{S}} where S","page":"Finite element spaces","title":"Bcube.get_size","text":"Return the size S associated to AbstractFESpace{S}.\n\n\n\n\n\n","category":"method"},{"location":"manual/conventions/#Conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"manual/conventions/","page":"Conventions","title":"Conventions","text":"This documentation follows the following notations or naming conventions:","category":"page"},{"location":"manual/conventions/","page":"Conventions","title":"Conventions","text":"coordinates inside a reference frame are noted (hatx haty) or (xi eta) while coordinates in the physical frame are noted (xy)\nwhen talking about a mapping, F or sometimes F_rp designates the mapping from the reference element to the physical element. On the other side, F^-1 or sometimes F_pr designates the physical element to the reference element mapping.\n\"dof\" means \"degree of freedom\"","category":"page"},{"location":"manual/cellfunction/#Cell-function","page":"Cell function","title":"Cell function","text":"","category":"section"},{"location":"manual/cellfunction/","page":"Cell function","title":"Cell function","text":"warning: Warning\nThis page is under construction.","category":"page"},{"location":"manual/cellfunction/","page":"Cell function","title":"Cell function","text":"As explained earlier, at least two coordinates systems exist in Bcube : the \"reference\" coordinates (ReferenceDomain) and the \"physical\" coordinates (PhysicalDomain). The evaluation of a function on a point in a cell depends on the way this point has been defined. Hence the definition of CellPoints that embed the coordinate system. Given a CellPoint (or eventually a FacePoint), an AbstractCellFunction will be evaluated and the mapping between the ReferenceDomain to the PhysicalDomain (or reciprocally) will be performed internally if necessary : if an AbstractCellFunction defined in terms of reference coordinates is applied on a CellPoint expressed in the reference coordinates system, no mapping is needed.","category":"page"},{"location":"howto/howto/#how-to","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"","category":"section"},{"location":"howto/howto/#Build-your-own-LazyOperator","page":"How to... (FAQ)","title":"Build your own LazyOperator","text":"","category":"section"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Imagine that you want some kind of function (~operator) that has a different behavior depending on the cell (or face) it is applied to. The PhysicalFunction won't do the job since it is assumed that the provided function applies the same way in all the different cells. What you want is a LazyOperator. Here is how to build a custom one.","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"For the example, let's say that you want an operator whose action is to multiply x, the evaluated point, by the index of the cell surrounding x. Start importing some Bcube material and by declaring a type corresponding to this operator:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"using Bcube\nimport Bcube: CellInfo, CellPoint, get_coords\nstruct DummyOperator <: Bcube.AbstractLazy end","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Then, specify what happens when Bcube asks for the restriction of your operator in a given cell. This is done before applying it to any point. In most case, you don't want to do anything special, so just return the operator itself:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Bcube.materialize(op::DummyOperator, ::CellInfo) = op","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Now, specify what to return when Bcube wants to apply this operator on a given point in a cell. As said earlier, we want it the return the point, multiplied by the cell index (but it could be anything you want):","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"function Bcube.materialize(\n    ::DummyOperator,\n    cPoint::CellPoint,\n)\n    x = get_coords(cPoint)\n    cInfo = Bcube.get_cellinfo(cPoint)\n    index = Bcube.cellindex(cInfo)\n    return x * index\nend","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"That's it! To see your operator in action, take a look at the related section.","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"In this short example, note that we restricted ourselves to CellPoint : the DummyOperator won't be applicable to a face. To do so, you have to specialize the materialization on a Side of a FaceInfo and on a Side of a FacePoint. Checkout the source code for TangentialProjector to see this in action. Besides, the CellPoint is parametrized by a DomainStyle, allowing to specify different behavior depending on if your operator is applied to a point in the ReferenceDomain or in the PhysicalDomain.","category":"page"},{"location":"howto/howto/#Evaluate-a-LazyOperator-on-a-specific-point","page":"How to... (FAQ)","title":"Evaluate a LazyOperator on a specific point","text":"","category":"section"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Suppose that you have built a mesh and defined a LazyOperator on this mesh and you want, for debug purpose, evaluate this operator on a point of your choice. First, let's define our example operator:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"using Bcube\nmesh = circle_mesh(10)\nop = Bcube.TangentialProjector()","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Then, let's define the point where we want to evaluate this operator. For this, we need to create a so-called CellPoint. It's structure is quite basic : it needs the coordinates, the mesh cell owning these coordinates, and if the coordinates are given in the ReferenceDomain or in the PhysicalDomain. Here, we will select the first cell of the mesh, and choose the coordinates [0.5] (recall that we are in 1D, hence this vector of one component):","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"cInfo = Bcube.CellInfo(mesh, 1)\ncPoint = Bcube.CellPoint([0.5], cInfo, Bcube.ReferenceDomain())","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Now, they are always two steps to evaluate a LazyOperator. First we need to materialize it on a cell (or a face) and then to evaluate it on a cell-point (or face-point). The materialization on a cell does not necessarily triggers something, it depends on the operator. For instance, an analytic function will not have a specific behaviour depending on the cell; however a shape function will.","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"op_cell = Bcube.materialize(op, cInfo)","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Finally, we can apply our operator on the cell point defined above and observe the result. It is also called a \"materialization\":","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"@show Bcube.materialize(op_cell, cPoint)","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Note that before and after the materialization on a cell point, the operator can be displayed as a tree with","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Bcube.show_lazy_operator(op)\nBcube.show_lazy_operator(op_cell)","category":"page"},{"location":"howto/howto/#Get-the-coordinates-of-Lagrange-dofs","page":"How to... (FAQ)","title":"Get the coordinates of Lagrange dofs","text":"","category":"section"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"For a Lagrange \"uniform\" function space, the dofs corresponds to vertices. The following lagrange_dof_to_coords function returns a matrix : each line contains the coordinates of the dof corresponding to the line number.","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"function lagrange_dof_to_coords(U, mesh)\n    coords = map(1:Bcube.spacedim(mesh)) do i\n        f = PhysicalFunction(x -> x[i])\n        u = FEFunction(U)\n        projection_l2!(u, f, mesh)\n        return get_dof_values(u)\n    end\n    return hcat(coords...)\nend","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"For instance:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"using Bcube\nmesh = rectangle_mesh(2, 3; xmin = 1, xmax = 2, ymin = 3, ymax = 5)\nU = TrialFESpace(FunctionSpace(:Lagrange, 1), mesh)\ncoords = lagrange_dof_to_coords(U, mesh)\n@show coords[2] # coordinates of dof '2' in the global numbering","category":"page"},{"location":"howto/howto/#Loop-over-the-cells-or-faces-of-a-mesh","page":"How to... (FAQ)","title":"Loop over the cells or faces of a mesh","text":"","category":"section"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Let's say you have a Mesh with one or several limits","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"using Bcube\nmesh = rectangle_mesh(2, 3)\nΩ = CellDomain(mesh)\nΓ = InteriorFaceDomain(mesh)\nΛ = BoundaryFaceDomain(mesh, (\"xmin\", \"ymin\"))","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"You can loop over the mesh cell and/or faces using the foreach_element function applied to any \"domain\". Each item is either a CellInfo or a FaceInfo (or a CellSide) depending on the nature of the domain. This information contains all the geometric information about the entity:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"# Loop over the different domains (to illustrate that it works for different kind of domains)\nfor (domain, legend) in zip((Ω, Γ, Λ), (\"Cells in Ω\", \"Faces in Γ\", \"Faces in Λ\"))\n    println(\"\\n-----------\")\n    println(legend)\n    println(\"-----------\")\n\n    # Loop over the elements (cells of faces) in this domain\n    foreach_element(domain) do element\n\n        # index of the cell/face in the mesh\n        println(\"\")\n        println(\"Element $(Bcube.get_element_index(element))\")\n\n        # show the nodes index forming this element\n        @show Bcube.get_nodes_index(element)\n\n        # array of the \"Node\" forming this element\n        elt_nodes = Bcube.nodes(element)\n        @show elt_nodes\n\n        # element \"entity type\" (Bar2_t, Quad4_t etc)\n        elt_type = Bcube.get_element_type(element)\n        @show elt_type\n\n        # element center\n        elt_center = Bcube.center(elt_type, elt_nodes)\n        @show elt_center\n\n        # Additionnal info for faces\n        if element isa Bcube.FaceInfo\n            # Access the CellInfo of the neighbor cell (\"negative\" cell)\n            # For interior faces only, the \"positive\" side can be retrieved\n            # as well (with side_p)\n            neighbor_cell_n = side_n(element)\n\n            # We can also retrieve the local index of the face in the neighbor cells\n            # Note that boundary faces only have one neighbor cell, which is on the\n            # negative side by convention.\n            kside = Bcube.get_cell_side_n(element)\n\n            # Normal of the face at the face center using the low level API\n            cell_type = Bcube.get_element_type(neighbor_cell_n)\n            cell_nodes = Bcube.nodes(neighbor_cell_n)\n            @show Bcube.normal(cell_type, cell_nodes, kside, elt_center)\n        end\n    end\nend","category":"page"},{"location":"howto/howto/#Export-face-normals-to-a-CSV-file","page":"How to... (FAQ)","title":"Export face normals to a CSV file","text":"","category":"section"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Imagine that you want to export some face normals (of one boundary for instance) in a CSV file to check their orientation. You can get inspiration from this script:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"using Bcube\nusing DelimitedFiles\nusing SparseArrays\n\n# Build a toy mesh and extract some boundaries\nmesh = rectangle_mesh(3, 4)\nΩ = CellDomain(mesh)\nΛ = BoundaryFaceDomain(mesh, (\"xmin\", \"ymin\"))\n\n# Get face normals\nnΛ = get_face_normals(Λ)\n\n# Compute : location of face centers, normals and surface of each face\ndΛ = Measure(Λ, 1)\nx = Bcube.compute(∫(side_n(PhysicalFunction(x -> x)))dΛ)\nn = Bcube.compute(∫(side_n(nΛ))dΛ)\ns = Bcube.compute(∫(side_n(PhysicalFunction(x -> 1)))dΛ)\n\n# Get non-zeros values (results are sparse vectors from now)\n_, x = findnz(x)\n_, n = findnz(n)\n_, s = findnz(s)\n\n# Use surface to \"correct\" x and n\nx = x ./ s\nn = n ./ s\n\n# Prepare data for output\nx = transpose(hcat(x...))\nn = transpose(hcat(n...))\ny = hcat(x, n)\n\n# Write normals as CSV\na = (\"x\", \"y\", \"z\")[1:Bcube.spacedim(mesh)]\nheader = join(a, \",\") * \",\" * join(\"n\" .* a, \",\")\nopen(joinpath(@__DIR__, \"output.csv\"), \"w\") do io\n    println(io, header)\n    writedlm(io, y, \",\")\nend\n\n# Write mesh as VTK\nwrite_vtk(joinpath(@__DIR__, \"output\"), mesh)","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Note that once the CSV file is obtained, the normals can be visualized for instance with Paraview by using three consecutive filters:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"TableToPoints to convert coordinates into points\nCalculator to convert \"normals columns\" into vectors (using iHat, jHat etc)\nGlyph to visualized these vectors","category":"page"},{"location":"howto/howto/#Comparing-manually-the-benchmarks-with-main","page":"How to... (FAQ)","title":"Comparing manually the benchmarks with main","text":"","category":"section"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Let's say you want to compare the performance of your current branch (named \"target\" hereafter) with the main branch (named \"baseline\" hereafter).","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Open from Bcube.jl/ a REPL and type:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"pkg> activate --temp\npkg> add BenchmarkTools PkgBenchmark StaticArrays UnPack\npkg> dev .\nusing PkgBenchmark\nimport Bcube\nbenchmarkpkg(Bcube, BenchmarkConfig(; env = Dict(\"JULIA_NUM_THREADS\" => \"1\")); resultfile = joinpath(@__DIR__, \"result-target.json\"))","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"This will create a result-target.json in the current directory.","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Then checkout the main branch. Start a fresh REPL and type (almost the same):","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"pkg> activate --temp\npkg> add BenchmarkTools PkgBenchmark StaticArrays UnPack\npkg> dev .\nusing PkgBenchmark\nimport Bcube\nbenchmarkpkg(Bcube, BenchmarkConfig(; env = Dict(\"JULIA_NUM_THREADS\" => \"1\")); resultfile = joinpath(@__DIR__, \"result-baseline.json\"))","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"This will create a result-baseline.json in the current directory.","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"You can now \"compare\" the two files by running (watch-out for the order):","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"target = PkgBenchmark.readresults(\"result-target.json\")\nbaseline = PkgBenchmark.readresults(\"result-baseline.json\")\njudgement = judge(target, baseline)\nexport_markdown(\"judgement.md\", judgement)","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"This will create the markdown file judgement.md with the results.","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"For more details, once you've built the judgement object, you can also type the following code from https://github.com/tkf/BenchmarkCI.jl:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"open(\"detailed-judgement.md\", \"w\") do io\n    println(io, \"# Judge result\")\n    export_markdown(io, judgement)\n    println(io)\n    println(io)\n    println(io, \"---\")\n    println(io, \"# Target result\")\n    export_markdown(io, PkgBenchmark.target_result(judgement))\n    println(io)\n    println(io)\n    println(io, \"---\")\n    println(io, \"# Baseline result\")\n    export_markdown(io, PkgBenchmark.baseline_result(judgement))\n    println(io)\n    println(io)\n    println(io, \"---\")\nend","category":"page"},{"location":"howto/howto/#Run-the-benchmark-manually","page":"How to... (FAQ)","title":"Run the benchmark manually","text":"","category":"section"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Let's say you want to run the benchmarks locally (without comparing with main)","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Open from Bcube.jl/ a REPL and type:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"pkg> activate --temp\npkg> add BenchmarkTools PkgBenchmark StaticArrays WriteVTK UnPack\npkg> dev .\nusing PkgBenchmark\nimport Bcube\nresults = benchmarkpkg(Bcube, BenchmarkConfig(; env = Dict(\"JULIA_NUM_THREADS\" => \"1\")); resultfile = joinpath(@__DIR__, \"result.json\"))\nexport_markdown(\"results.md\", results)","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"This will create the markdown file results.md with the results.","category":"page"},{"location":"api/mesh/gmsh_utils/#GMSH","page":"GMSH","title":"GMSH","text":"","category":"section"},{"location":"manual/function_space/#Function-and-FE-spaces","page":"Function and FE spaces","title":"Function and FE spaces","text":"","category":"section"},{"location":"manual/function_space/#AbstractFunctionSpace","page":"Function and FE spaces","title":"AbstractFunctionSpace","text":"","category":"section"},{"location":"manual/function_space/","page":"Function and FE spaces","title":"Function and FE spaces","text":"In Bcube, a FunctionSpace is defined by a type (nodal Lagrange polynomials, modal Taylor expansion, etc) and a degree. For each implemented FunctionSpace, a list of shape functions is associated on a given Shape. For instance, one can get the shape functions associated to the Lagrange polynomials or order 3 on a Square. Note that for \"tensor\" elements such as Line, Square or Cube; the Lagrange polynomials are available at any order; being computed symbolically.","category":"page"},{"location":"manual/function_space/","page":"Function and FE spaces","title":"Function and FE spaces","text":"fs = FunctionSpae(:Lagrange, 2)","category":"page"},{"location":"manual/function_space/#AbstractFESpace","page":"Function and FE spaces","title":"AbstractFESpace","text":"","category":"section"},{"location":"manual/function_space/","page":"Function and FE spaces","title":"Function and FE spaces","text":"Then, an FESpace (more precisely SingleFESpace) is a function space associated to a numbering of the degrees of freedom. Note that the numbering may depend on the continuous or discontinuous feature of the space. Hence a SingleFESpace takes basically four input to be built : a FunctionSpace, the number of components of this space (scalar or vector), an indicator of the continuous/discontinuous characteristic, and the mesh. The dof numbering is built by combining the mesh numberings (nodes, cells, faces) and the function space. Note that the degree of the FunctionSpace can differ from the \"degree\" of the mesh elements : it is possible to build a SingleFESpace with P2 polynomials on a mesh only containing straight lines (defined by only two nodes, Bar2_t). ","category":"page"},{"location":"manual/function_space/","page":"Function and FE spaces","title":"Function and FE spaces","text":"For more clarity, the SingleFESpace is actually declined in two flavors : TrialFESpace and TestFESpace. These are the ones exposed to the API. The naming convention should be clear to the user familiar to the FE (and/or GD) method. Optionaly, a TrialFESpace can also contain the tags of the boundaries where Dirichlet condition(s) applies.","category":"page"},{"location":"manual/function_space/","page":"Function and FE spaces","title":"Function and FE spaces","text":"A MultiFESpace is simply a set of TrialFESpace (or a set of TestFESpace), eventually of different natures. Its befenit is that it allows to build a \"global\" numbering of all the dofs represented by this space. This is especially convenient to solve systems of equations.","category":"page"},{"location":"manual/function_space/","page":"Function and FE spaces","title":"Function and FE spaces","text":"fs = FunctionSpace(:Lagrange, 2)\nU_fem_sca = TrialFEspace(fs, mesh) # scalar FEM FESpace\nU_dg_sca = TrialFEspace(fs, mesh, :discontinuous) # scalar DG FESpace\nU_dg_vec = TrialFEspace(fs, mesh, :discontinuous; size = 2) # 2-components DG FESpace\n\nU = MultiFESpace(U_fem_sca, U_dg_sca, U_dg_vec)\n\nV_fem_sca = TestFESpace(U_fem_sca)\nV_dg_sca = TestFESpace(U_dg_sca)\nV_dg_vec = TestFESpace(U_dg_vec)\n\nV = MultiFESpace(V_fem_sca, V_dg_sca, V_dg_vec)","category":"page"},{"location":"manual/function_space/#AbstractFEFunction","page":"Function and FE spaces","title":"AbstractFEFunction","text":"","category":"section"},{"location":"manual/function_space/","page":"Function and FE spaces","title":"Function and FE spaces","text":"With a TrialFESpace, one can build the representation of a function discretized on this space: a FEFunction. This structure stores a vector of values, one for each degree of freedom of the finite element space. To set or get the values of a FEFunction, the functions set_dof_values! and get_dof_values are available respectively. A FEFunction can be projected on another FESpace; or evaluated at some specific mesh location (a coordinates, all the nodes, all the mesh centers, etc).","category":"page"},{"location":"manual/function_space/","page":"Function and FE spaces","title":"Function and FE spaces","text":"U = TrialFESpace(FunctionSpace(:Lagrange, 1), mesh)\nu = FEFunction(U) # an FEFunction with all zeros as the initial value\nu = FEFunction(U, rand(nnodes(mesh))) # a random value at each dof\n\ndofs = get_dof_values(u) # get the values of the FEFunction\nset_dof_values!(u, 2. * dofs) # assign the dof values\nprojection_l2!(u, PhysicalFunction(x -> norm(x)), mesh) # set the dof values using an L2 projection","category":"page"},{"location":"api/io/io_interface/#io-interface","page":"IO interface","title":"IO interface","text":"","category":"section"},{"location":"api/io/io_interface/#Bcube.check_input_file-Tuple{Bcube.AbstractIoHandler, String}","page":"IO interface","title":"Bcube.check_input_file","text":"check_input_file([handler::AbstractIoHandler,] filepath::String)\n\nCheck that the input file is compatible with the Bcube reader, and print warnings and/or errors if it's not.\n\n\n\n\n\n","category":"method"},{"location":"api/io/io_interface/#Bcube.read_file-Tuple{Bcube.AbstractIoHandler, String}","page":"IO interface","title":"Bcube.read_file","text":"read_file(\n    [handler::AbstractIoHandler,]\n    filepath::String;\n    domains = String[],\n    varnames = nothing,\n    topodim = 0,\n    spacedim = 0,\n    verbose = false,\n    kwargs...,\n)\n\nRead the mesh and associated data in the given file.\n\nReturns a NamedTuple with the following keys:\n\nmesh -> the Bcube mesh\ndata -> dictionnary of FlowSolutionName => (dictionnary of VariableName => MeshData)\n\nIf domains is an empty list/array, all the domains found will be read and merged. Otherwise, domains can be a filtered list/array of the domain names to retain.\n\nIf varnames is set to nothing, no variables will be read, which is the behavior of read_mesh. To read all the variables, varnames must be set to \"*\".\n\nThe argument topodim can be used to force and/or select the elements of this topological dimension to be interpreted as \"volumic\". Leave it to 0 to let the reader determines the topological dimension automatically. The same goes for spacedim.\n\nExample\n\nresult = read_file(\"file.cgns\"; varnames = [\"Temperature\", \"Density\"], verbose = true)\n@show ncells(result.mesh)\n@show keys(result.data)\n\n\n\n\n\n","category":"method"},{"location":"api/io/io_interface/#Bcube.read_mesh-Tuple{Bcube.AbstractIoHandler, String}","page":"IO interface","title":"Bcube.read_mesh","text":"Similar to read_file, but return only the mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/io/io_interface/#Bcube.write_file","page":"IO interface","title":"Bcube.write_file","text":"write_file(\n    [handler::AbstractIoHandler,]\n    filepath::String,\n    mesh::AbstractMesh,\n    data = nothing,\n    it::Integer = -1,\n    time::Real = 0.0;\n    mesh_degree::Integer = 1,\n    functionSpaceType::AbstractFunctionSpaceType = Lagrange(),\n    discontinuous::Bool = false,\n    collection_append::Bool = false,\n    kwargs...,\n)\n\nWrite a set of AbstractLazy to a file.\n\ndata can be provided as a Dict{String, AbstractLazy} if they share the same \"container\" (~FlowSolution), or as a Dict{String, T} where T is the previous Dict type described.\n\nTo write cell-centered data, wrapped your input into a MeshCellData (for instance using cell_mean or MeshCellData ∘ var_on_centers).\n\nExample\n\nmesh = rectangle_mesh(6, 7; xmin = -1, xmax = 1.0, ymin = -1, ymax = 1.0)\nf_u = PhysicalFunction(x -> x[1]^2 + x[2]^2)\nu = FEFunction(TrialFESpace(FunctionSpace(:Lagrange, 4), mesh))\nprojection_l2!(u, f_u, mesh)\n\nvars = Dict(\"f_u\" => f_u, \"u\" => u, \"grad_u\" => ∇(u))\n\nfor mesh_degree in 1:5\n    write_file(\n        joinpath(@__DIR__, \"output\"),\n        mesh,\n        vars;\n        mesh_degree,\n        discontinuous = false\n    )\nend\n\nRemarks:\n\nIf mesh is of degree d, the solution will be written on a mesh of degree mesh_degree, even if this\n\nnumber is different from d.\n\nThe degree of the input FEFunction (P1, P2, P3, ...) is not used to define the nodes where the solution is\n\nwritten, only mesh and mesh_degree matter. The FEFunction is simply evaluated on the aforementionned nodes.\n\nDev notes\n\nTo specialize this method, please specialize:\n\nwrite_file(\n    handler::AbstractIoHandler,\n    filepath::String,\n    mesh::AbstractMesh,\n    U_export::AbstractFESpace,\n    data = nothing,\n    it::Integer = -1,\n    time::Real = 0.0;\n    collection_append::Bool = false,\n    kwargs...,\n)\n\n\n\n\n\n","category":"function"},{"location":"manual/operator/#LazyOperators","page":"LazyOperators","title":"LazyOperators","text":"","category":"section"},{"location":"manual/operator/","page":"LazyOperators","title":"LazyOperators","text":"todo: \nThis documentation is under construction, you can check the how to section to get an idea of how lazy operators are defined and used.","category":"page"},{"location":"manual/integration/#Integration","page":"Integration","title":"Integration","text":"","category":"section"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"To compute an integral on a geometrical element, for instance a curved element, a variable substitution is used to compute the integral on the corresponding reference Shape. This variable substitution reads:","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"int_Omega g(x) mathrmd Omega = int_hatOmega J(x) left(g circ F right)(hatx) mathrmd hatOmega","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"where we recall that F is the reference to physical mapping and J is the determinant of the jacobian matrix of this mapping. Depending on the shape and element order, this determinant is either hard-coded or computed with ForwardDiff.","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"Now, to compute the right side, i.e the integral on the reference shape, quadrature rules are applied to hatg = g circ F:","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"int_hatOmega hatg(hatx) mathrmd hatOmega = sum_i =1^N_q omega_i hatg(hatx_i)","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"A specific procedure is applied to compute integrals on a face of a cell (i.e a surfacic integral on a face of a volumic element).","category":"page"},{"location":"manual/integration/#Defining-a-(bi)linear-form","page":"Integration","title":"Defining a (bi)linear form","text":"","category":"section"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"When using the FEM or the DG method, (bi)linear forms have to be defined. These forms represent scalar products between functions, and involve an integration. For instance, the common bilinear form (corresponding to the mass matrix once assembled) is (uv) mapsto int ucdot v  mathrmdOmega. In Bcube, this integral translates to:","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"mesh = (...)\nΩ = CellDomain(mesh)\ndΩ = Measure(Ω, 2)\na(u,v) = ∫(u⋅v)dΩ","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"You can see a new concept here : the Measure dΩ. A measure is built from a domain (cell of face) and a quadrature rule. Several quadrature rules are available, see here.","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"info: Info\nWe've done nothing else that defining a function a above. It is then intended to be used with the assemble_bilinear function (and FESpaces).","category":"page"},{"location":"manual/integration/#Computing-a-raw-integral","page":"Integration","title":"Computing a raw integral","text":"","category":"section"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"It is possible to compute an integral over a domain directly without assembling a (bi)linear form, for instance to compute the area of the cells, or the error between an analytical and a numerical solution. To do so, use the Bcube.compute function:","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"g = PhysicalFunction(x -> 2 * x[1])\nresult = Bcube.compute(∫(g)dΩ)","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"The obtained result is actually not the sum over the elements of Ω, but a SparseVector with the result of the integration element-wise. So if you integrate over a subset of the mesh cells, the result will be a sparse vector containing only non-zero values for those cells.","category":"page"},{"location":"api/interpolation/shape/#Reference-shape","page":"Reference shape","title":"Reference shape","text":"","category":"section"},{"location":"api/interpolation/shape/#Bcube.center-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.center","text":"center(::AbstractShape)\n\nCenter of the AbstractShape.\n\nImplementation\n\nSpecialize for better performances\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.entity-Union{Tuple{D}, Tuple{Bcube.AbstractShape, Val{D}}} where D","page":"Reference shape","title":"Bcube.entity","text":"entity(s::AbstractShape, ::Val{D}) where D\n\nReturn the geometrical Entity corresponding to the AbstractShape of a given degree D.\n\nRemark : Returned entity must be consistent with the corresponding Lagrange function space.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.face_area-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.face_area","text":"face_area(::AbstractShape)\n\nReturn the length/area of the faces of a shape.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.face_shapes-Tuple{Bcube.AbstractShape, Any}","page":"Reference shape","title":"Bcube.face_shapes","text":"face_shapes(shape::AbstractShape, i)\n\nShape of i-th shape of the input shape.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.face_shapes-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.face_shapes","text":"face_shapes(::AbstractShape)\n\nReturn a tuple of the Shape of each face of the given (cell) Shape. For instance, a Triangle has three faces, all of them are Line.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.faces2nodes-Tuple{Bcube.AbstractShape, Any}","page":"Reference shape","title":"Bcube.faces2nodes","text":"faces2nodes(shape::AbstractShape, side)\n\nReturn the index of the vertices on the iside-th face of a shape. If side is positive, the face is oriented preserving the cell normal. If side is negative, the face is returned with the opposite direction (i.e reverse node order).\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.faces2nodes-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.faces2nodes","text":"faces2nodes(::AbstractShape)\n\nReturn the index of the vertices on the faces of a shape.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.get_coords-Tuple{Bcube.AbstractShape, Any}","page":"Reference shape","title":"Bcube.get_coords","text":"get_coords(shape::AbstractShape,i)\n\nReturn the coordinates of the ith shape vertices. i can be a tuple of indices, then the multiples vertices's coordinates are returned.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.get_coords-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.get_coords","text":"get_coords(::AbstractShape)\n\nReturn node coordinates of the shape in the reference space.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.nedges-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.nedges","text":"nedges(::AbstractShape)\n\nGeneric function. Indicate how many edges a shape has.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.nfaces-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.nfaces","text":"nfaces(::AbstractShape)\n\nIndicate how many faces a shape has.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.normal-Tuple{Bcube.AbstractShape, Any}","page":"Reference shape","title":"Bcube.normal","text":"normal(shape::AbstractShape, i)\n\nReturn the outward normal of the ith face of the shape.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.normals-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.normals","text":"normals(::AbstractShape)\n\nReturn the outward normals of all the faces of the shape.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.nvertices-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.nvertices","text":"nvertices(::AbstractShape)\n\nIndicate how many vertices a shape has.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.shape-Tuple{Bcube.AbstractEntityType}","page":"Reference shape","title":"Bcube.shape","text":"shape(::AbstractEntityType)\n\nReturn the reference Shape corresponding to the given AbstractEntityType.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Function-spaces","page":"Function spaces","title":"Function spaces","text":"","category":"section"},{"location":"api/interpolation/function_space/#Generic","page":"Function spaces","title":"Generic","text":"","category":"section"},{"location":"api/interpolation/function_space/#Bcube.AbstractFunctionSpaceType","page":"Function spaces","title":"Bcube.AbstractFunctionSpaceType","text":"Abstract structure for the different types of function space, for instance the Lagrange function space, the Taylor function space etc.\n\nDevs notes\n\nAll subtypes should implement the following functions:\n\nget_ndofs(::AbstractFunctionSpace, ::AbstractShape)\n_scalar_shape_functions(::AbstractFunctionSpace, ::AbstractShape, ξ)\nidof_by_vertex(::AbstractFunctionSpace, ::AbstractShape)\nidof_by_edge(::AbstractFunctionSpace, ::AbstractShape)\nidof_by_edge_with_bounds(::AbstractFunctionSpace, ::AbstractShape)\nidof_by_face(::AbstractFunctionSpace, ::AbstractShape)\nidof_by_face_with_bounds(::AbstractFunctionSpace, ::AbstractShape)\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/function_space/#Bcube.FunctionSpace-Tuple{Bcube.AbstractFunctionSpaceType, Integer}","page":"Function spaces","title":"Bcube.FunctionSpace","text":"FunctionSpace(fstype::Symbol, degree::Integer)\nFunctionSpace(fstype::AbstractFunctionSpaceType, degree::Integer)\n\nBuild a FunctionSpace of the designated FunctionSpaceType and degree.\n\nExamples\n\njulia> FunctionSpace(:Lagrange, 2)\nFunctionSpace{Bcube.Lagrange{:Uniform}, 2}()\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.basis_functions_style-Tuple{Bcube.AbstractFunctionSpace}","page":"Function spaces","title":"Bcube.basis_functions_style","text":"basis_functions_style(fs::AbstractFunctionSpace)\n\nReturn the style (modal or nodal) corresponding to the basis functions of the 'fs'.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.get_coords-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.get_coords","text":"get_coords(fs::AbstractFunctionSpace,::AbstractShape)\n\nReturn node coordinates in the reference space for associated function space and shape.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.get_degree-Union{Tuple{Bcube.AbstractFunctionSpace{type, degree}}, Tuple{degree}, Tuple{type}} where {type, degree}","page":"Function spaces","title":"Bcube.get_degree","text":"get_degree(::AbstractFunctionSpace{type, degree}) where{type, degree}\n\nReturn the degree associated to the AbstractFunctionSpace.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.get_ndofs-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.get_ndofs","text":"get_ndofs(fs::AbstractFunctionSpace, shape::AbstractShape)\n\nNumber of dofs associated to the given interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.get_type-Union{Tuple{Bcube.AbstractFunctionSpace{type}}, Tuple{type}} where type","page":"Function spaces","title":"Bcube.get_type","text":"get_type(::AbstractFunctionSpace{type})\n\nGetter for the type of the AbstractFunctionSpace\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.idof_by_edge-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.idof_by_edge","text":"idof_by_edge(::AbstractFunctionSpace, ::AbstractShape)\n\nReturn the local indices of the dofs lying on each edge of the Shape.\n\nDofs lying on the edge vertices are excluded.\n\nThe result is a Tuple of arrays of integers. Arrays maybe be empty. See Lagrange interpolation for simple examples.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.idof_by_edge_with_bounds-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.idof_by_edge_with_bounds","text":"idof_by_edge_with_bounds(::AbstractFunctionSpace, ::AbstractShape)\n\nReturn the local indices of the dofs lying on each edge of the Shape.\n\nDofs lying on the edge vertices are included.\n\nThe result is a Tuple of arrays of integers. Arrays maybe be empty. See Lagrange interpolation for simple examples.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.idof_by_face-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.idof_by_face","text":"idof_by_face(::AbstractFunctionSpace, ::AbstractShape)\n\nReturn the local indices of the dofs lying on each face of the Shape.\n\nDofs lying on the face edges are excluded, only \"face-interior\" dofs are considered.\n\nThe result is a Tuple of arrays of integers. Arrays maybe be empty. See Lagrange interpolation for simple examples.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.idof_by_face_with_bounds-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.idof_by_face_with_bounds","text":"idof_by_face_with_bounds(::AbstractFunctionSpace, ::AbstractShape)\n\nReturn the local indices of the dofs lying on each face of the Shape.\n\nDofs lying on the face edges are included\n\nThe result is a Tuple of arrays of integers. Arrays maybe be empty. See Lagrange interpolation for simple examples.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.idof_by_vertex-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.idof_by_vertex","text":"idof_by_vertex(::AbstractFunctionSpace, ::AbstractShape)\n\nReturn the local indices of the dofs lying on each vertex of the Shape.\n\nBeware that we are talking about the Shape, not the EntityType. So 'interior' vertices of the EntityType are not taken into account for instance. See Lagrange interpolation for simple examples.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.shape_functions-Union{Tuple{N}, Tuple{Bcube.AbstractFunctionSpace, Val{N}, Bcube.AbstractShape, Any}} where N","page":"Function spaces","title":"Bcube.shape_functions","text":"shape_functions(::AbstractFunctionSpace, ::Val{N}, shape::AbstractShape, ξ) where N\nshape_functions(::AbstractFunctionSpace, shape::AbstractShape, ξ)\n\nReturn the list of shape functions corresponding to a FunctionSpace and a Shape. N is the size of the finite element space (default: N=1 if the argument is not provided).\n\nThe result is a vector of all the shape functions evaluated at position ξ, and not a tuple of the different shape functions. This choice is optimal for performance.\n\nNote : λ = ξ -> shape_functions(fs, shape, ξ); λ(ξ)[i] is faster than λ =shape_functions(fs, shape); λ[i](ξ)\n\nImplementation\n\nDefault version, should be overriden for each concrete FunctionSpace.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.shape_functions_vec-Union{Tuple{N}, Tuple{Bcube.AbstractFunctionSpace, Val{N}, Bcube.AbstractShape, Any}} where N","page":"Function spaces","title":"Bcube.shape_functions_vec","text":"shape_functions_vec(fs::AbstractFunctionSpace, ::Val{N}, shape::AbstractShape, ξ) where {N}\n\nReturn all the shape functions of FunctionSpace on a Shape evaluated in ξ as a vector.\n\nN is the the size (number of components) of the finite element space.\n\n\n\nshape_functions_vec(fs::AbstractFunctionSpace{T,D}, n::Val{N}, shape::AbstractShape) where {T,D, N}\n\nThe shape functions are returned as a vector of functions.\n\nImplementation\n\nThis is implementation is not always valid, but it is for Lagrange and Taylor spaces (the only two spaces available up to 20/01/23).\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.∂λξ_∂ξ","page":"Function spaces","title":"Bcube.∂λξ_∂ξ","text":"∂λξ_∂ξ(::AbstractFunctionSpace, ::Val{N}, shape::AbstractShape) where N\n\nGradient, with respect to the reference coordinate system, of shape functions for any function space. The result is an array whose elements are the gradient of each shape functions. N is the size of the finite element space.\n\nImplementation\n\nDefault version using automatic differentiation. Specialize to increase performance.\n\n\n\n\n\n","category":"function"},{"location":"api/interpolation/function_space/#Lagrange","page":"Function spaces","title":"Lagrange","text":"","category":"section"},{"location":"api/interpolation/function_space/#Bcube._scalar_shape_functions-Tuple{FunctionSpace{<:Bcube.Lagrange, 1}, Bcube.Tetra, Any}","page":"Function spaces","title":"Bcube._scalar_shape_functions","text":"shape_functions(::FunctionSpace{<:Lagrange, 1}, ::Tetra, ξ)\n\nShape functions for Tetra Lagrange element of degree 1 in a 3D space.\n\nhatlambda_1(xi eta zeta) = (1 - xi - eta - zeta) hspace1cm\nhatlambda_2(xi eta zeta) = xi                        hspace1cm\nhatlambda_3(xi eta zeta) = eta                       hspace1cm\nhatlambda_5(xi eta zeta) = zeta                      hspace1cm\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.shape_functions-Union{Tuple{N}, Tuple{D}, Tuple{FunctionSpace{<:Bcube.Lagrange, D}, Val{N}, Bcube.AbstractShape, Any}} where {D, N}","page":"Function spaces","title":"Bcube.shape_functions","text":"shape_functions(::FunctionSpace{<:Lagrange}, :: Val{N}, ::AbstractShape, ξ) where {N}\n\nImplementation\n\nFor N > 1, the default version consists in \"replicating\" the shape functions. If shape_functions returns the vector [λ₁; λ₂; λ₃], and if the FESpace is of size 2, then this default behaviour consists in returning the matrix [λ₁ 0; λ₂ 0; λ₃ 0; 0 λ₁; 0 λ₂; 0 λ₃].\n\nTriangle\n\nOrder 1\n\nhatlambda_1(xi eta) = 1 - xi - eta hspace1cm\nhatlambda_2(xi eta) = xi                hspace1cm\nhatlambda_3(xi eta) = eta\n\nOrder 2\n\nbeginaligned\n     hatlambda_1(xi eta) = (1 - xi - eta)(1 - 2 xi - 2 eta) \n     hatlambda_2(xi eta) = xi (2xi - 1) \n     hatlambda_3(xi eta) = eta (2eta - 1) \n     hatlambda_12(xi eta) = 4 xi (1 - xi - eta) \n     hatlambda_23(xi eta) = 4 xi eta \n     hatlambda_31(xi eta) = 4 eta (1 - xi - eta)\nendaligned\n\nPrism\n\nOrder 1\n\nbeginaligned\n    hatlambda_1(xi eta zeta) = (1 - xi - eta)(1 - zeta)2 hspace1cm\n    hatlambda_2(xi eta zeta) = xi (1 - zeta)2          hspace1cm\n    hatlambda_3(xi eta zeta) = eta (1 - zeta)2  hspace1cm\n    hatlambda_5(xi eta zeta) = (1 - xi - eta)(1 + zeta)2 hspace1cm\n    hatlambda_6(xi eta zeta) = xi (1 + zeta)2          hspace1cm\n    hatlambda_7(xi eta zeta) = eta (1 + zeta)2  hspace1cm\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.shape_functions_symbolic-Union{Tuple{D}, Tuple{FunctionSpace{<:Bcube.Lagrange, D}, Bcube.Line, Any}} where D","page":"Function spaces","title":"Bcube.shape_functions_symbolic","text":"shape_functions_symbolic(fs::FunctionSpace{<:Lagrange, D}, ::Shape, ξ) where {D, Shape<:Line}\n∂λξ_∂ξ_symbolic(fs::FunctionSpace{<:Lagrange, D}, ::Shape, ξ) where {D, Shape<:Line}\n\nImplementation\n\nBased on Symbolic.jl. First tests show that this version is slower than the implementation based on meta when D is greater. Further investigations are needed to understand this behavior.\n\nshape_functions_symbolic uses a \"generated\" function named _shape_functions_symbolic. The core of the generated function is an Expression that is created by __shape_functions_symbolic. This latter function uses the Symbolics package and the lagrange polynomials (defined in _lagrange_poly).\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.∂λξ_∂ξ-Tuple{FunctionSpace{<:Bcube.Lagrange, 0}, Val{1}, Bcube.Line, Number}","page":"Function spaces","title":"Bcube.∂λξ_∂ξ","text":"∂λξ_∂ξ(::FunctionSpace{<:Lagrange}, ::Val{1}, ::AbstractShape, ξ)\n\nTriangle\n\nOrder 0\n\nnabla hatlambda(xi eta) =\nbeginpmatrix\n    0  0\nendpmatrix\n\nOrder 1\n\nbeginaligned\n     nabla hatlambda_1(xi eta) =\n        beginpmatrix\n            -1  -1\n        endpmatrix \n     nabla hatlambda_2(xi eta) =\n        beginpmatrix\n            1  0\n        endpmatrix \n     nabla hatlambda_3(xi eta) =\n        beginpmatrix\n            0  1\n        endpmatrix \nendaligned\n\nOrder 2\n\nbeginaligned\n     nabla hatlambda_1(xi eta) =\n        beginpmatrix\n            -3 + 4 (xi + eta)  -3 + 4 (xi + eta)\n        endpmatrix \n     nabla hatlambda_2(xi eta) =\n        beginpmatrix\n            -1 + 4 xi  0\n        endpmatrix \n     nabla hatlambda_3(xi eta) =\n        beginpmatrix\n            0  -1 + 4 eta\n        endpmatrix \n     nabla hatlambda_12(xi eta) =\n        4 beginpmatrix\n            1 - 2 xi - eta  - xi\n        endpmatrix \n     nabla hatlambda_23(xi eta) =\n        4 beginpmatrix\n            eta  xi\n        endpmatrix \n     nabla hatlambda_31(xi eta) =\n        4 beginpmatrix\n            - eta  1 - 2 eta - xi\n        endpmatrix \nendaligned\n\nSquare\n\nOrder 0\n\nnabla hatlambda(xi eta) =\nbeginpmatrix\n    0  0\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Taylor","page":"Function spaces","title":"Taylor","text":"","category":"section"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"The Taylor function space corresponds to a function space where functions are approximated by a Taylor series expansion of order n in each cell:","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"    forall x in Omega_ig(x) = g(x_0) + (x - x_0) g(x_0) + o(x)","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"where x_0 is the cell center.","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"Note that a Taylor-P0 is strictly equivalent to a 1st-order Finite Volume discretization (beware that \"order\" can have different meaning depending on whether one refers to the order of the function space basis or the order of the discretization method).","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"Recall that any function space implies that any function g is interpolated by g(x) = sum g_i lambda_i(x) where lambda_i are the shape functions. For a Taylor expansion, the definition of lambda_i is not unique. For instance for the Taylor expansion of order 1 on a 1D line above, we may be tempted to set lambda_1(x) = 1 and lambda_2(x) = (x - x_0). If you do so, what are the corresponding shape functions in the reference element, the hatlambda_i? We immediately recover hatlambda_1(hatx)  = 1. For hatlambda_2:","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"    hatlambda_2(hatx) = (lambda circ F)(hatx) = (x rightarrow x - x_0) circ (hatx rightarrow fracx_r - x_l2 hatx + fracx_r + x_l2) = fracx_r - x_l2 hatx","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"So if you set lambda_2(x) = (x - x_0) then hatlambda_2 depends on the element length (Delta x = x_r-x_l), which is pointless. So lambda_2 must be proportional to the element length to obtain a universal definition for hatlambda_2. For instance, we may choose lambda_2(x) = (x - x_0)  Delta x, leading to hatlambda_2(hatx) = hatx  2. But we could have chosen an other element length multiple.","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"Don't forget that choosing lambda_2(x) = (x - x_0)  Delta x leads to g(x) = g(x_0) + fracx - x_0Delta x g(x_0) Δx hence g_2 = g(x_0) Δx in the interpolation.","category":"page"},{"location":"api/interpolation/function_space/#Bcube.shape_functions-Union{Tuple{N}, Tuple{FunctionSpace{<:Bcube.Taylor}, Val{N}, Bcube.AbstractShape, Any}} where N","page":"Function spaces","title":"Bcube.shape_functions","text":"shape_functions(::FunctionSpace{<:Taylor}, ::AbstractShape, ξ)\n\nImplementation\n\nFor N > 1, the default version consists in \"replicating\" the shape functions. If shape_functions returns the vector [λ₁; λ₂; λ₃], and if the FESpace is of size 2, then this default behaviour consists in returning the matrix [λ₁ 0; λ₂ 0; λ₃ 0; 0 λ₁; 0 λ₂; 0 λ₃].\n\nAny shape, order 0\n\nhatlambda(xi) = 1\n\nLine\n\nOrder 1\n\nhatlambda_1(xi) = 1 hspace1cm hatlambda_1(xi) = fracxi2\n\nSquare\n\nOrder 1\n\nbeginaligned\n     hatlambda_1(xi eta) = 0 \n     hatlambda_2(xi eta) = fracxi2 \n     hatlambda_3(xi eta) = fraceta2\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.∂λξ_∂ξ-Tuple{FunctionSpace{<:Bcube.Taylor, 0}, Val{1}, Bcube.Line, Any}","page":"Function spaces","title":"Bcube.∂λξ_∂ξ","text":"∂λξ_∂ξ(::FunctionSpace{<:Taylor}, ::Val{1}, ::AbstractShape, ξ)\n\nLine\n\nOrder 0\n\nnabla hatlambda(xi) = 0\n\nOrder 1\n\nnabla hatlambda_1(xi) = 0 hspace1cm nabla hatlambda_1(xi) = frac12\n\nSquare\n\nOrder 0\n\nhatlambda_1(xi eta) = beginpmatrix 0  0 endpmatrix\n\nOrder 1\n\nbeginaligned\n     nabla hatlambda_1(xi eta) = beginpmatrix 0  0 endpmatrix \n     nabla hatlambda_2(xi eta) = beginpmatrix frac12  0 endpmatrix \n     nabla hatlambda_3(xi eta) = beginpmatrix 0  frac12 endpmatrix\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Mesh","page":"Mesh","title":"Mesh","text":"","category":"section"},{"location":"api/mesh/mesh/#Entity","page":"Mesh","title":"Entity","text":"","category":"section"},{"location":"api/mesh/mesh/#Bcube.Node","page":"Mesh","title":"Bcube.Node","text":"A Node is a point in space of dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.topology_style-Union{Tuple{T}, Tuple{spaceDim}, Tuple{topoDim}, Tuple{Bcube.AbstractEntityType{topoDim}, Node{spaceDim, T}}} where {topoDim, spaceDim, T}","page":"Mesh","title":"Bcube.topology_style","text":"topology_style(::AbstractEntityType{topoDim}, ::Node{spaceDim, T}) where {topoDim, spaceDim, T}\ntopology_style(::AbstractEntityType{topoDim}, ::AbstractArray{Node{spaceDim, T}, N}) where {spaceDim, T, N, topoDim}\n\nIndicate the TopologyStyle of an entity of topology topoDim living in space of dimension spaceDim.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Connectivity","page":"Mesh","title":"Connectivity","text":"","category":"section"},{"location":"api/mesh/mesh/#Bcube.AbstractConnectivity","page":"Mesh","title":"Bcube.AbstractConnectivity","text":"AbstractConnectivity{T}\n\nSupertype for connectivity with indices of type T.\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.Connectivity","page":"Mesh","title":"Bcube.Connectivity","text":"Connectivity{T}\n\nType for connectivity with elements of type T.\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.inverse_connectivity-Union{Tuple{Bcube.Connectivity{T}}, Tuple{T}} where T","page":"Mesh","title":"Bcube.inverse_connectivity","text":"inverse_connectivity(c::Connectivity{T}) where {T}\n\nReturns the \"inverse\" of the connectivity 'c' and the corresponding 'keys'. 'keys' are provided because indices in 'c' could be sparse in the general case.\n\nExample\n\nmesh = basic_mesh()\nc2n = connectivities_indices(mesh,:c2n)\nn2c, keys = inverse_connectivity(c2n)\n\nHere, 'n2c' is the node->cell graph of connectivity and, 'n2c[i]' contains the indices of the cells connected to the node of index 'keys[i]'. If 'c2n' is dense, 'keys' is not necessary (because keys[i]==i, ∀i)\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Mesh-2","page":"Mesh","title":"Mesh","text":"","category":"section"},{"location":"api/mesh/mesh/#Bcube.AbstractMesh","page":"Mesh","title":"Bcube.AbstractMesh","text":"Implementation\n\nAll subtypes should implement the following functions:\n\nBase.parent(AbstractMesh) (default should be Base.parent(m::MyMesh) = m)\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.AbstractMeshMetaData","page":"Mesh","title":"Bcube.AbstractMeshMetaData","text":"Mesh metadata intended to store informations about \"zones\" (or \"domains\") originally stored in the mesh file.\n\nDevs notes\n\nAll subtypes should implement the following functions:\n\nget_zone_names(::AbstractMeshMetaData, ::AbstractMesh)\nget_zone_element_indices(::AbstractMeshMetaData, ::AbstractMesh, name)\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.Mesh","page":"Mesh","title":"Bcube.Mesh","text":"bc_names : <boundary tag> => <boundary names> bc_nodes : <boundary tag> => <boundary nodes tags> bc_faces : <boundary tag> => <boundary faces tags>\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.MeshConnectivity","page":"Mesh","title":"Bcube.MeshConnectivity","text":"Type parameters details:\n\nC is the indices type\nF is a symbol standing for \"from\"\nT is a symbol standing for \"to\"\nB::Union{Symbol,Nothing} is a symbol (or Nothing) standing for \"by\"\nL::Union{Int,Nothing} is nLayers type\n\nDev notes: from, to, by were previously structure properties (of type Symbol) but were moved to type parameter for GPU compatibility\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.connectivity_cell2cell_by_faces-Tuple{Any}","page":"Mesh","title":"Bcube.connectivity_cell2cell_by_faces","text":"connectivity_cell2cell_by_faces(mesh)\n\nBuild the cell -> cell connectivity by looking at neighbors by faces.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.connectivity_cell2cell_by_nodes-Tuple{Any}","page":"Mesh","title":"Bcube.connectivity_cell2cell_by_nodes","text":"connectivity_cell2cell_by_nodes(mesh)\n\nBuild the cell -> cell connectivity by looking at neighbors by nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.get_zone_element_indices-Tuple{Bcube.AbstractMesh, Any}","page":"Mesh","title":"Bcube.get_zone_element_indices","text":"get_zone_indices(::AbstractMesh, name)\n\nReturn the cell indices of a given zone, designated by its name\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.get_zone_names-Tuple{Bcube.AbstractMesh}","page":"Mesh","title":"Bcube.get_zone_names","text":"get_zone_names(::AbstractMeshMetaData)\n\nReturn the zone names\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.inner_faces-Tuple{Any}","page":"Mesh","title":"Bcube.inner_faces","text":"inner_faces(mesh)\n\nReturn the indices of the inner faces.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.oriented_cell_side-Tuple{Bcube.Mesh, Int64, Int64}","page":"Mesh","title":"Bcube.oriented_cell_side","text":"oriented_cell_side(mesh::Mesh,icell::Int,iface::Int)\n\nReturn the side number to which the face 'iface' belongs in the cell 'icell' of the mesh. A negative side number is returned if the face is inverted. Returns '0' if the face does not belongs the cell.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.outer_faces-Tuple{Any}","page":"Mesh","title":"Bcube.outer_faces","text":"outer_faces(mesh)\n\nReturn the indices of the outer (=boundary) faces.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Domain","page":"Mesh","title":"Domain","text":"","category":"section"},{"location":"api/mesh/mesh/#Bcube.AbstractDomain","page":"Mesh","title":"Bcube.AbstractDomain","text":"An AbstractDomain designates any set of entities from a mesh. For instance a set of cells, a set of faces etc.\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.AbstractDomainIndex","page":"Mesh","title":"Bcube.AbstractDomainIndex","text":"abstract type AbstractDomainIndex\n\nDevs notes\n\nAll subtypes should implement the following functions:\n\ngetelementtype(::AbstractDomainIndex)\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.BoundaryFaceDomain-Tuple{Bcube.Mesh, Tuple{Symbol, Vararg{Symbol}}}","page":"Mesh","title":"Bcube.BoundaryFaceDomain","text":"BoundaryFaceDomain(mesh)\nBoundaryFaceDomain(mesh, label::String)\nBoundaryFaceDomain(mesh, labels::Tuple{String, Vararg{String}})\n\nBuild a BoundaryFaceDomain corresponding to the boundaries designated by one or several labels (=names).\n\nIf no label is provided, all the BoundaryFaceDomain corresponds to all the boundary faces.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.CellDomain","page":"Mesh","title":"Bcube.CellDomain","text":"A CellDomain is a representation of the cells of a mesh. It's primary purpose is to represent a domain to integrate over.\n\nConstructors\n\nCellDomain(mesh::Mesh) CellDomain(mesh::Mesh, indices)\n\nExamples\n\njulia> mesh = rectangle_mesh(10, 10)\njulia> Ω_all = CellDomain(mesh)\njulia> selectedCells = [1,3,5,6]\njulia> Ω_selected = CellDomain(mesh, selectedCells)\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.CellInfo-Tuple{Any, Any, Any}","page":"Mesh","title":"Bcube.CellInfo","text":"Legacy constructor for CellInfo : no information about node indices \n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.CellInfo-Tuple{Any, Any}","page":"Mesh","title":"Bcube.CellInfo","text":"CellInfo(mesh, icell)\n\nDEBUG constructor for icell-th cell of mesh. For performance issues, don't use this version in production.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.DomainIteratorByTags","page":"Mesh","title":"Bcube.DomainIteratorByTags","text":"A DomainIteratorByTags is a helper to iterate over a Domain by iterating over groups of SubDomains sharing the same tag. This helps applying type-stable operations on the elements of the Domain.\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.FaceInfo","page":"Mesh","title":"Bcube.FaceInfo","text":"FaceInfo{CN<:CellInfo,CP<:CellInfo,FT,FN,F2N,I}\n\nType describing a face as the common side of two adjacent cells. CellInfo of cells from both sides is stored with the local side index of the face relative to each adjacent cell.\n\niface is the mesh-face-index (and not the domain-face-index).\n\nRemark:\n\nFor boundary face with no periodic condition, positive cell side info\n\nare duplicate from the negative ones.\n\nFor performance reason (type stability), nodes and type of the face\n\nis stored explicitely in FaceInfo even if it could have been computed by collecting info from the side of the negative or positive cells.\n\nFor GPU compatibility, it has been necessary to introduce two additional type\n\nparameters, namely CSN and CSP whereas in practice CSN == CSP == Int (bmxam : I've done multiple tests and this is the only solution I have for now. But I don't understand this solution and this might not be necessary)\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.FaceInfo-Tuple{Bcube.CellInfo, Bcube.CellInfo, Any, Any, AbstractVector, Any}","page":"Mesh","title":"Bcube.FaceInfo","text":"FaceInfo constructor\n\nCell sides are computed automatically.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.FaceInfo-Tuple{Bcube.Mesh, Int64}","page":"Mesh","title":"Bcube.FaceInfo","text":"DEBUG FaceInfo constructor for kface-th cell of mesh. For performance issues, don't use this version in production.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.SubDomain","page":"Mesh","title":"Bcube.SubDomain","text":"A SubDomain groups a collection of mesh elements (cells, faces, …) that share the same elementType.\n\nThe indices field stores the original mesh indices of those elements. The optional tag can be used to differentiate multiple sub‑domains of the same element type (e.g., for coloring or labeling). This structure is primarily intended for internal organization of mesh entities belonging to a Domain.\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube._compute_periodicity","page":"Mesh","title":"Bcube._compute_periodicity","text":"Find periodic face connectivities sush as :\n(faces of `labels2`) = A(faces of `labels1`)\n\n\n\n\n\n","category":"function"},{"location":"api/mesh/mesh/#Bcube.build_subdomains_by_celltypes-Tuple{Any, Any}","page":"Mesh","title":"Bcube.build_subdomains_by_celltypes","text":"build_subdomains_by_celltypes(mesh, indices)\n\nConstruct sub‑domains of a mesh grouped by cell type.\n\nArguments\n\nmesh: the mesh from which cells are taken.\nindices: a collection of cell indices to be considered.\n\nReturns\n\nA tuple of SubDomain objects, each containing:\n\na tag to identify groups of SubDomain (tag=nothing by default),\nthe cell type,\nthe list of indices belonging to that type.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.build_subdomains_by_facetypes-Tuple{Any, Any}","page":"Mesh","title":"Bcube.build_subdomains_by_facetypes","text":"build_subdomains_by_facetypes(mesh, indices)\n\nConstruct sub‑domains of a mesh grouped by face type (including adjacent cell types).\n\nArguments\n\nmesh: the mesh containing the faces.\nindices: a collection of face indices to be considered.\n\nReturns\n\nA tuple of SubDomain objects, each containing:\n\na tag to identify groups of SubDomain (tag=nothing by default),\na tuple (face_type, cell_type₁, cell_type₂) describing the face and its neighboring cells,\nthe list of indices belonging to that tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.build_subdomains_periodic_by_facetypes-Tuple{Any, Any}","page":"Mesh","title":"Bcube.build_subdomains_periodic_by_facetypes","text":"build_subdomains_periodic_by_facetypes(mesh, perio_cache)\n\nConstruct sub‑domains for periodic boundaries, grouped by face type (including adjacent cell types).\n\nArguments\n\nmesh: the mesh on which the periodic boundary is defined.\nperio_cache: a cache tuple returned by _compute_periodicity, containing at least bnd_f2c (boundary face to cell connectivity) and bnd_ftypes (boundary face types).\n\nReturns\n\nA tuple of SubDomain objects, each containing:\n\na tag to identify groups of SubDomain (tag=nothing by default),\na tuple (face_type, cell_type₁, cell_type₂) describing the periodic face and its two neighboring cells,\nthe list of indices belonging to that tuple.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.domain_to_mesh","page":"Mesh","title":"Bcube.domain_to_mesh","text":"domain_to_mesh(::AbstractDomain)\n\nConvert an AbstractDomain to a Mesh.\n\nThe new boundary faces, if any, obtained by selecting a portion of the original mesh are tagged with the value of the argument clipped_bnd_name.\n\n\n\n\n\n","category":"function"},{"location":"api/mesh/mesh/#Bcube.foreach_element","page":"Mesh","title":"Bcube.foreach_element","text":"foreach_element(f, domain::AbstractDomain, backend::BcubeBackendCPUSerial = get_bcube_backend())\n\nApply the in-place function f to every element of domain.\n\nThe iteration proceeds over all subdomains, grouped by their tags, using the CPU‑serial backend (default obtained via get_bcube_backend()). For each subdomain the lower‑level foreach_element overload is invoked, ensuring that f receives the appropriate element information.\n\nArguments\n\nf: Callable to be applied to each element. f must capture the variables that are modified during the loop.\ndomain::AbstractDomain: The domain whose elements are processed.\nbackend::BcubeBackendCPUSerial: Backend handling the iteration (default: get_bcube_backend()).\n\nReturns\n\nnothing.\n\n\n\n\n\n","category":"function"},{"location":"api/mesh/mesh/#Bcube.get_cell_normals-Tuple{Bcube.AbstractCellDomain}","page":"Mesh","title":"Bcube.get_cell_normals","text":"get_cell_normals(::AbstractMesh)\nget_cell_normals(::AbstractCellDomain)\nget_cell_normals(::Measure{<:AbstractCellDomain})\n\nReturn a LazyOperator representing a cell normal in the context of hypersurfaces (see [cell_normal]@ref for more details)\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.get_face_normals-Tuple{Bcube.AbstractFaceDomain}","page":"Mesh","title":"Bcube.get_face_normals","text":"get_face_normals(::AbstractFaceDomain)\nget_face_normals(::Measure{<:AbstractFaceDomain})\n\nReturn a LazyOperator representing a face normal\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.identify_cells","page":"Mesh","title":"Bcube.identify_cells","text":"identify_cells(mesh::Mesh, f::Function, all_nodes = true)\n\nIdentify the cells verifying a given geometrical criteria.\n\nReturn the cells indices. The function f takes one argument : x, a spatial coordinate.\n\nIf all_nodes is true, then all cells verifying f(x_i)==true where x_i are the cell nodes are selected. On the contrary, if all_nodes is false, all cells with at least one node verifying the criteria are selected.\n\n\n\n\n\n","category":"function"},{"location":"api/mesh/mesh/#Bcube.map_element","page":"Mesh","title":"Bcube.map_element","text":"map_element(f, domain::AbstractDomain, backend::BcubeBackendCPUSerial = get_bcube_backend())\n\nApply the out-of-place function f to each element of domain using the CPU‑serial backend (default obtained via get_bcube_backend()) and return an array whose size is equal to the number of elements of domain.\n\nThe iteration proceeds over all subdomains, grouped by their tags, using the default backend. For each subdomain, the lower‑level map_element overload is invoked, ensuring that f receives the appropriate element information.\n\nArguments\n\nf: Callable to be applied to each element.\ndomain::AbstractDomain: The domain whose elements are processed.\nbackend::BcubeBackendCPUSerial: Backend handling the iteration (default: get_bcube_backend()).\n\nReturns\n\nAn array containing the results of applying f to each element, with length equal to the number of elements in domain.\n\n\n\n\n\n","category":"function"},{"location":"api/mesh/mesh/#Bcube.opposite_side-Tuple{Bcube.FaceInfo}","page":"Mesh","title":"Bcube.opposite_side","text":"Return the opposite side of the FaceInfo : cellside \"n\" because cellside \"p\"\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#mesh-generator","page":"Mesh generator","title":"Mesh generator","text":"","category":"section"},{"location":"api/mesh/mesh_generator/#Bcube._compute_space_dim-Tuple{Any, Any, Any, Any, Any, Bool}","page":"Mesh generator","title":"Bcube._compute_space_dim","text":"_compute_space_dim(topodim, lx, ly, lz, tol, verbose::Bool)\n\nDeduce the number of space dimensions from the mesh boundaries : if one (or more) dimension of the bounding box is way lower than the other dimensions, the number of space dimension is decreased.\n\nCurrently, having for instance (x,z) is not supported. Only (x), or (x,y), or (x,y,z).\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube._cube_pile_mesh-Tuple{}","page":"Mesh generator","title":"Bcube._cube_pile_mesh","text":"_cube_pile_mesh()\n\nOnly for testing purpose.\n\nlevel 1        7–––8        |      |        |      | 4–––5–––6 |      |      | |      |      | 1–––2–––3\n\nlevel 2        15––16        |      |        |      | 12––13––-14 |      |      | |      |      | 9––-10––-11\n\nlevel 3\n\n  19-----20\n   |      |\n   |      |\n  17-----18\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube._duplicate_mesh-Tuple{Bcube.AbstractMesh}","page":"Mesh generator","title":"Bcube._duplicate_mesh","text":"_duplicate_mesh(mesh::AbstractMesh)\n\nMake an exact copy of the input mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube._two_cubes_mesh-Tuple{}","page":"Mesh generator","title":"Bcube._two_cubes_mesh","text":"_two_cubes_mesh(; zmin = 0, zmax = 1)\n\nOnly for testing purpose.\n\nz=zmin 4–––5–––6 |      |      | |      |      | 1–––2–––3\n\nz=zmax 10––11––-12 |      |      | |      |      | 7–––8–––9\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.basic_mesh-Tuple{}","page":"Mesh generator","title":"Bcube.basic_mesh","text":"basic_mesh()\n\nGenerate a toy mesh of two quads and one triangle.\n\nv1       v2       v3       v4  +–-e1–>+–-e5–>+–-e8–>+  ^        |        |  c3  / e4   c1   e2   c2  e6   e9  |        |        |  /  +<–e3–-+<–e7–-+/  v5      v6        v7\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.circle_mesh-Tuple{Any}","page":"Mesh generator","title":"Bcube.circle_mesh","text":"circle_mesh(n; r = 1, order = 1)\n\nMesh a circle (in 2D) with n nodes on the circumference.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.hexa_mesh-Tuple{Any, Any, Any}","page":"Mesh generator","title":"Bcube.hexa_mesh","text":"hexa_mesh(\n    nx,\n    ny,\n    nz;\n    xmin = 0.0,\n    xmax = 1.0,\n    ymin = 0.0,\n    ymax = 1.0,\n    zmin = 0.0,\n    zmax = 1.0,\n    order = 1,\n    bnd_names = (\"xmin\", \"xmax\", \"ymin\", \"ymax\", \"zmin\", \"zmax\"),\n)\n\nMesh a hexahedral domain with hexahedral mesh elements.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.line_mesh-Tuple{Any}","page":"Mesh generator","title":"Bcube.line_mesh","text":"line_mesh(n; xmin = 0., xmax = 1., order = 1, names = (\"xmin\", \"xmax\"))\n\nGenerate a mesh of a line of n vertices.\n\nExample\n\njulia> mesh = line_mesh(5)\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.ncube_mesh-Tuple{Vector{Int64}}","page":"Mesh generator","title":"Bcube.ncube_mesh","text":"ncube_mesh(n::Vector{Int}; order = 1)\n\nGenerate either a line mesh, a rectangle mesh, a cubic mesh... depending on the dimension of n.\n\nArgument\n\nn number of vertices in each spatial directions\n\nExample\n\nmesh_of_a_line = ncube_mesh([10])\nmesh_of_a_square = ncube_mesh([4, 5])\nmesh_of_a_hexa = ncube_mesh([4, 5, 6])\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.one_cell_mesh-Tuple{Symbol}","page":"Mesh generator","title":"Bcube.one_cell_mesh","text":"one_cell_mesh(type::Symbol, order = 1)\n\nGenerate a mesh of one cell. type can be :line, :quad, :tri, :hexa, :penta, :pyra.\n\nThe argument order refers to the geometry order. It has the same effect as the -order parameter in gmsh.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.rectangle_mesh-Tuple{Any, Any}","page":"Mesh generator","title":"Bcube.rectangle_mesh","text":"rectangle_mesh(\n    nx,\n    ny;\n    type = :quad,\n    xmin = 0.0,\n    xmax = 1.0,\n    ymin = 0.0,\n    ymax = 1.0,\n    order = 1,\n    bnd_names = (\"xmin\", \"xmax\", \"ymin\", \"ymax\"),\n)\n\nGenerate a 2D mesh of a rectangle with nx and ny vertices in the x and y directions respectively.\n\nExample\n\njulia> mesh = rectangle_mesh(5, 4)\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.scale-Tuple{Bcube.AbstractMesh, Any}","page":"Mesh generator","title":"Bcube.scale","text":"scale(mesh, factor)\n\nScale the input mesh nodes coordinates by a given factor and return the resulted mesh. The factor can be a number or a vector.\n\nUsefull for debugging.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.transform-Tuple{Bcube.AbstractMesh, Any}","page":"Mesh generator","title":"Bcube.transform","text":"transform(mesh::AbstractMesh, fun)\n\nTransform the input mesh nodes coordinates by applying the given fun function and return the resulted mesh.\n\nUsefull for debugging.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.translate-Tuple{Bcube.AbstractMesh, AbstractVector}","page":"Mesh generator","title":"Bcube.translate","text":"translate(mesh::AbstractMesh, t::AbstractVector)\n\nTranslate the input mesh with vector t.\n\nUsefull for debugging.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Integration","page":"Integration","title":"Integration","text":"","category":"section"},{"location":"api/integration/integration/#Measure","page":"Integration","title":"Measure","text":"","category":"section"},{"location":"api/integration/integration/#Bcube.Measure","page":"Integration","title":"Bcube.Measure","text":"A Measure is geometrical domain of integration associated to a way to integrate on it (i.e a quadrature rule).\n\nQ is the quadrature type used to integrate expressions using this measure.\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.Measure-Tuple{AbstractDomain, Integer}","page":"Integration","title":"Bcube.Measure","text":"Measure(domain::AbstractDomain, degree::Integer)\nMeasure(domain::AbstractDomain, ::Val{degree}) where {degree}\n\nBuild a Measure on the designated AbstractDomain with a default quadrature of degree degree.\n\nArguments\n\ndomain::AbstractDomain : the domain to integrate over\ndegree : the degree of the quadrature rule (Legendre quadrature type by default)\n\nExamples\n\njulia> mesh = line_mesh(10)\njulia> Ω = CellDomain(mesh)\njulia> dΩ = Measure(Ω, 2)\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Integration-methods","page":"Integration","title":"Integration methods","text":"","category":"section"},{"location":"api/integration/integration/#Base.:*-Tuple{Number, Bcube.Integration}","page":"Integration","title":"Base.:*","text":"*(a::Number, b::Integration)\n*(a::Integration, b::Number)\n\nMultiplication of an Integration is based on a rewriting rule following the linearity rules of integration : k*∫(f(x))dx => ∫(k*f(x))dx\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Base.:--Tuple{Bcube.Integrand}","page":"Integration","title":"Base.:-","text":"-(a::Integrand)\n\nSoustraction on an Integrand is treated as a multiplication by \"(-1)\" : -a ≡ ((-1)*a)\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Base.:--Tuple{Bcube.Integration}","page":"Integration","title":"Base.:-","text":"-(a::Integration)\n\nSoustraction on an Integration is treated as a multiplication by \"(-1)\" : -a ≡ ((-1)*a)\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.apply_quadrature-Tuple{Any, Bcube.AbstractShape, Bcube.AbstractQuadrature, Bcube.MapComputeQuadratureStyle}","page":"Integration","title":"Bcube.apply_quadrature","text":"apply_quadrature(\n    g_ref,\n    shape::AbstractShape,\n    quadrature::AbstractQuadrature,\n    ::MapComputeQuadratureStyle,\n)\n\nApply quadrature rule to function g_ref expressed on reference shape shape. Computation is optimized according to the given concrete type T<:AbstractComputeQuadratureStyle.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.apply_quadrature_v2-Union{Tuple{G}, Tuple{G, Bcube.AbstractShape, Bcube.AbstractQuadrature, Bcube.MapComputeQuadratureStyle}} where G","page":"Integration","title":"Bcube.apply_quadrature_v2","text":"apply_quadrature_v2(\n    g_ref,\n    shape::AbstractShape,\n    quadrature::AbstractQuadrature,\n    ::MapComputeQuadratureStyle,\n)\n\nAlternative version of apply_quadrature thats seems to be more efficient for face integration (this observation is not really understood)\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.integrate_on_ref_element-Tuple{Any, Any, Bcube.AbstractQuadrature}","page":"Integration","title":"Bcube.integrate_on_ref_element","text":"integrate_on_ref_element(g, cellinfo::CellInfo, quadrature::AbstractQuadrature, [::T]) where {N,[T<:AbstractComputeQuadratureStyle]}\nintegrate_on_ref_element(g, faceinfo::FaceInfo, quadrature::AbstractQuadrature, [::T]) where {N,[T<:AbstractComputeQuadratureStyle]}\n\nIntegrate a function g over a cell/face described by cellinfo/faceinfo.\n\nThe function g can be expressed in the reference or the physical space corresponding to the cell, both cases are automatically handled by applying necessary mapping when needed.\n\nIf the last argument is given, computation is optimized according to the given concrete type T<:AbstractComputeQuadratureStyle.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#quadratures","page":"Integration","title":"Quadrature rules","text":"","category":"section"},{"location":"api/integration/integration/#Bcube.AbstractQuadrature","page":"Integration","title":"Bcube.AbstractQuadrature","text":"AbstractQuadrature{T,D}\n\nAbstract type representing quadrature of type T and degree D\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.AbstractQuadratureNode","page":"Integration","title":"Bcube.AbstractQuadratureNode","text":"AbstractQuadratureNode{S,Q}\n\nAbstract type representing a quadrature node for a shape S and a quadrature Q. This type is used to represent and identify easily a quadrature node in a quadrature rules.\n\nDerived types must implement the following method:\n\n- get_index(quadnode::AbstractQuadratureNode{S,Q})\n- get_coords(quadnode::AbstractQuadratureNode)\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.AbstractQuadratureRule","page":"Integration","title":"Bcube.AbstractQuadratureRule","text":"AbstractQuadratureRule{S,Q}\n\nAbstract type representing a quadrature rule for a shape S and quadrature Q.\n\nDerived types must implement the following method:     - [get_weights(qr::AbstractQuadratureRule)]     - [get_nodes(qr::AbstractQuadratureRule)]     - [Base.length(qr::AbstractQuadratureRule)]\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.Quadrature","page":"Integration","title":"Bcube.Quadrature","text":"Quadrature{T,D}\n\nQuadrature of type T and degree D\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.QuadratureNode","page":"Integration","title":"Bcube.QuadratureNode","text":"QuadratureNode{S,Q}\n\nType representing a quadrature node for a shape S and a quadrature Q. This type can be used to represent and identify easily a quadrature node in the corresponding parent quadrature rule.\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.QuadratureRule","page":"Integration","title":"Bcube.QuadratureRule","text":"QuadratureRule{S,Q}\n\nAbstract type representing a quadrature rule for a shape S and quadrature Q\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.QuadratureRule-Tuple{Bcube.AbstractShape, Bcube.AbstractQuadrature}","page":"Integration","title":"Bcube.QuadratureRule","text":"QuadratureRule(shape::AbstractShape, q::AbstractQuadrature)\n\nReturn the quadrature rule corresponding to the given Shape according to the selected quadrature 'q'.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Base.length-Tuple{Bcube.AbstractQuadratureRule}","page":"Integration","title":"Base.length","text":"length(qr::AbstractQuadratureRule)\n\nReturns the number of quadrature nodes of qr.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube._gausslegendre1D-Union{Tuple{Val{N}}, Tuple{N}} where N","page":"Integration","title":"Bcube._gausslegendre1D","text":"_gausslegendre1D(::Val{N}) where N\n_gausslobatto1D(::Val{N}) where N\n\nReturn N-point Gauss quadrature weights and nodes on the domain [-1:1].\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube._get_num_nodes-Union{Tuple{degree}, Tuple{Bcube.Line, Val{degree}, QuadratureLegendre}} where degree","page":"Integration","title":"Bcube._get_num_nodes","text":"Gauss-Legendre formula with n nodes has degree of exactness 2n-1. Then, to obtain a given degree D, the number of nodes must satisfy: 2n-1  D or equivalently n  (D+1)2\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube._get_num_nodes-Union{Tuple{degree}, Tuple{Bcube.Line, Val{degree}, QuadratureLobatto}} where degree","page":"Integration","title":"Bcube._get_num_nodes","text":"Gauss-Lobatto formula with n+1 nodes has degree of exactness 2n-1, which equivalent to a degree of 2n-3 with n nodes. Then, to obtain a given degree D, the number of nodes must satisfy: 2n-3  D or equivalently n  (D+3)2\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube._get_num_nodes_per_dim-Union{Tuple{Bcube.AbstractQuadratureRule{<:S}}, Tuple{S}} where S","page":"Integration","title":"Bcube._get_num_nodes_per_dim","text":"get_num_nodes_per_dim(quadrule::AbstractQuadratureRule{S}) where S<:Shape\n\nReturns the number of nodes per dimension. This function is defined for shapes for which quadratures are based on a cartesian product : Line, Square, Cube\n\nRemark : Here we assume that the same degree is used along each dimension (no anisotropy for now!)\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.evalquadnode-Tuple{Any, Bcube.AbstractQuadratureNode}","page":"Integration","title":"Bcube.evalquadnode","text":"evalquadnode(f, quadnode::AbstractQuadratureNode)\n\nEvaluate the function f at the coordinates of quadnode.\n\nBasically, it computes:\n\nf(get_coords(quadnode))\n\nRemark:\n\nOptimization could be applied if f is a function based on a nodal basis such as one of the DoF and quadnode are collocated.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_coords-Tuple{Bcube.AbstractQuadratureNode}","page":"Integration","title":"Bcube.get_coords","text":"get_coords(quadnode::AbstractQuadratureNode)\n\nReturns the coordinates of quadnode.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_index-Tuple{Bcube.AbstractQuadratureNode}","page":"Integration","title":"Bcube.get_index","text":"get_index(quadnode::AbstractQuadratureNode{S,Q})\n\nReturns the index of quadnode in the parent quadrature rule AbstractQuadRules{S,Q}\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_nodes-Tuple{Bcube.AbstractQuadratureRule}","page":"Integration","title":"Bcube.get_nodes","text":"get_nodes(qr::AbstractQuadratureRule)\n\nReturns an array containing the coordinates of all quadrature nodes of qr.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_quadnodes-Union{Tuple{QuadratureRule{S, Q, N}}, Tuple{N}, Tuple{Q}, Tuple{S}} where {S, Q, N}","page":"Integration","title":"Bcube.get_quadnodes","text":"get_quadnodes(qr::QuadratureRule{S,Q,N}) where {S,Q,N}\n\nReturns an vector containing each QuadratureNode of qr\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_quadrature_points_gausslegendre-Tuple{Type{Val{:GLTRI12}}}","page":"Integration","title":"Bcube.get_quadrature_points_gausslegendre","text":"Gauss-Legendre quadrature, 12 point rule on triangle.\n\nRef: Witherden, F. D.; Vincent, P. E.      On the identification of symmetric quadrature rules for finite element methods.      Comput. Math. Appl. 69 (2015), no. 10, 1232–1241\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_quadrature_points_gausslegendre-Tuple{Type{Val{:GLTRI16}}}","page":"Integration","title":"Bcube.get_quadrature_points_gausslegendre","text":"Gauss-Legendre quadrature, 16 point rule on triangle, degree 8.\n\nRef: Witherden, F. D.; Vincent, P. E.      On the identification of symmetric quadrature rules for finite element methods.      Comput. Math. Appl. 69 (2015), no. 10, 1232–1241\n\nNote : quadrature is rescale to match our reference triangular shape which is defined in [0:1]² instead of [-1:1]²\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_quadrature_points_gausslegendre-Tuple{Type{Val{:GLTRI7}}}","page":"Integration","title":"Bcube.get_quadrature_points_gausslegendre","text":"Gauss-Legendre quadrature, 7 point rule on triangle. \n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_weights-Tuple{Bcube.AbstractQuadratureRule}","page":"Integration","title":"Bcube.get_weights","text":"get_weights(qr::AbstractQuadratureRule)\n\nReturns an array containing the weights of all quadrature nodes of qr.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.quadrature_points-Tuple{Bcube.Triangle, Val{4}, QuadratureLobatto}","page":"Integration","title":"Bcube.quadrature_points","text":"ref : https://www.math.umd.edu/~tadmor/references/files/Chen%20&%20Shu%20entropy%20stable%20DG%20JCP2017.pdf\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.quadrature_rule-Union{Tuple{D}, Tuple{Bcube.AbstractShape, Val{D}, Bcube.AbstractQuadratureType}} where D","page":"Integration","title":"Bcube.quadrature_rule","text":"quadrature_rule(::AbstractShape, ::Val{D}, ::AbstractQuadratureType) where {D}\n\nReturn the weights and points associated to the quadrature rule of degree D for the desired shape and quadrature type.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.quadrature_rule-Union{Tuple{N}, Tuple{Int64, Bcube.AbstractShape, Val{N}}} where N","page":"Integration","title":"Bcube.quadrature_rule","text":"quadrature_rule(iside::Int, shape::AbstractShape, degree::Val{N}) where N\n\nReturn the quadrature rule, computed with barycentric coefficients, corresponding to the given boundary of a shape and the given degree.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.quadrature_rule_bary-Union{Tuple{N}, Tuple{Int64, Bcube.AbstractShape, Val{N}}} where N","page":"Integration","title":"Bcube.quadrature_rule_bary","text":"quadrature_rule_bary(::Int, ::AbstractShape, degree::Val{N}) where N\n\nReturn the quadrature rule, computed with barycentric coefficients, corresponding to the given boundary of a shape and the given degree.\n\nThis function returns the quadrature weights and the barycentric weights to apply to each vertex of the reference shape. Hence, to apply the quadrature using this function, one needs to do : for (weight, l) in quadrature_rule_bary(iside, shape(etype), degree)     xp = zeros(SVector{td})     for i=1:nvertices         xp += l[i]*vertices[i]     end     # weight, xp is the quadrature couple (weight, node) end\n\n\n\n\n\n","category":"method"},{"location":"manual/geometry/#Geometry-and-mesh","page":"Geometry and mesh","title":"Geometry and mesh","text":"","category":"section"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"A Mesh is a set basically of nodes (Node), a set of entities (the mesh elements) and a list of connectivies that link the entities between themselves and with the nodes.","category":"page"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"In Bcube every mesh entity has corresponding reference Shape, a simplified or canonical representation of this element. A 1D line is mapped on the -11 segment, and a rectangle is mapped on the -11 times -11 square for instance. On these reference shapes, (almost) everything is known : the vertices location, the area, the quadrature points... Hence in Bcube we always compute things in the reference shape. For \"Lagrange\" elements (such as Bar*_t, Tri*_t, Quad*_t, Tetra*_t, Hexa*_t, Penta*_t etc), the mapping from the reference shape to a geometrical element is directly obtained from the corresponding Lagrange polynomials and the element node coordinates. Given a geometrical element with n nodes M_i, the mapping reads:","category":"page"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"F(xi) = sum_i=1^n hatlambda_i(xi)M_i","category":"page"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"where (lambda)_i are the Lagrange polynomials whose order matches the element order.","category":"page"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"(Image: sketch)","category":"page"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"Furthermore, an AbstractDomain is a subset of entities of the mesh. For instance, a CellDomain is a set of cells of the mesh, while InteriorFaceDomain and BoundaryFaceDomainare set of interior and boundary faces, respectively. This notion is a particular importance for integration and hence the definition of (bi)linear forms.","category":"page"},{"location":"manual/geometry/#Mesh-generators","page":"Geometry and mesh","title":"Mesh generators","text":"","category":"section"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"Bcube contains several helpers to build very simple mesh such as a line, a rectangle, a circle etc. The list of available mesh generators is available here.","category":"page"},{"location":"manual/geometry/#Reading-a-mesh","page":"Geometry and mesh","title":"Reading a mesh","text":"","category":"section"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"To read a mesh from a file, use the read_mesh function from the IO interface. However, there is no reader in the core of Bcube : there are implemented in companion packages.","category":"page"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"For now, Bcube supports GMSH format (.msh) through the BcubeGmsh.jl package, and there is also partial support of the CGNS file format through the BcubeCCGNS.jl package.","category":"page"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"julia> mesh = read_mesh(\"mesh.msh\")","category":"page"},{"location":"api/mapping/mapping/#Mapping","page":"Mapping","title":"Mapping","text":"","category":"section"},{"location":"api/mapping/mapping/#Mappings","page":"Mapping","title":"Mappings","text":"","category":"section"},{"location":"api/mapping/mapping/#Bcube.cell_normal-Union{Tuple{N}, Tuple{T}, Tuple{Bcube.AbstractEntityType{1}, AbstractArray{Node{2, T}, N}, Any}} where {T, N}","page":"Mapping","title":"Bcube.cell_normal","text":"cell_normal(ctype::AbstractEntityType, cnodes, ξ) where {T, N}\n\nCompute the cell normal vector of an entity of topology dimension equals to (n-1) in a n-D space, for instance a curve in a 2D space. This vector is expressed in the cell-reference coordinate system.\n\nDo not confuse the cell normal vector with the cell-side (i.e face) normal vector.\n\nTopology dimension 1\n\nthe curve direction vector, u, is J/||J||. Then n = [-u.y, u.x].\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.center-Tuple{Bcube.AbstractEntityType, Any}","page":"Mapping","title":"Bcube.center","text":"center(ctype::AbstractEntityType, cnodes)\n\nReturn the center of the AbstractEntityType by mapping the center of the corresponding Shape.\n\nWarning\n\nDo not use this function on a face of a cell : since the face is of dimension \"n-1\", the mapping won't be appropriate.\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.get_cell_centers-Tuple{Bcube.Mesh}","page":"Mapping","title":"Bcube.get_cell_centers","text":"get_cell_centers(mesh::Mesh)\n\nGet mesh cell centers coordinates (assuming perfectly flat cells)\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping-Tuple{Any, Any, Any}","page":"Mapping","title":"Bcube.mapping","text":"mapping(ctype::AbstractEntityType, cnodes, ξ)\nmapping(cshape::AbstractShape, cnodes, ξ)\n\nMap the reference shape on the local shape.\n\nImplementation\n\nThis function must be implemented for all shape.\n\n::Bar2_t\n\nMap the reference 2-nodes bar [-1,1] on the local bar:\n\nF(xi) = dfracx_r - x_l2 xi + dfracx_r + x_l2\n\n::Tri3_t\n\nMap the reference 3-nodes Triangle [0,1] x [0,1] on the local triangle.\n\nF(xi eta) = (1 - xi - eta) M_1 + xi M_2 + eta M_3\n\n::Quad4_t\n\nMap the reference 4-nodes square [-1,1] x [-1,1] on the 4-quadrilateral.\n\n::Tri6_t\n\nMap the reference 6-nodes triangle [0,1] x [0,1] on the P2 curved-triangle. F(xi) = sum lambda_i(xi) x_i where lambda_i are the Lagrange P2 shape functions and x_i are the local curved-triangle vertices' coordinates.\n\n::Quad9_t\n\nMap the reference 4-nodes square [-1,1] x [-1,1] on the P2 curved-quadrilateral. F(xi) = sum lambda_i(xi) x_i where lambda_i are the Lagrange P2 shape functions and x_i are the local curved-quadrilateral vertices' coordinates.\n\n::Hexa8_t\n\nMap the reference 8-nodes cube [-1,1] x [-1,1] x [-1,1] on the 8-hexa.\n\n::Hexa27_t\n\nMap the reference 8-nodes cube [-1,1] x [-1,1] x [-1,1] on the 27-hexa.\n\n::Penta6_t\n\nMap the reference 6-nodes prism [0,1] x [0,1] x [-1,1] on the 6-penta (prism).\n\n::Pyra5_t\n\nMap the reference 5-nodes pyramid [-1,1] x [-1,1] x [0,1] on the 5-pyra. See https://www.math.u-bordeaux.fr/~durufle/montjoie/pyramid.php\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping-Tuple{Bcube.Tetra4_t, Any, Any}","page":"Mapping","title":"Bcube.mapping","text":"mapping(nodes, ::Tetra4_t, ξ)\n\nMap the reference 4-nodes Tetraahedron [0,1] x [0,1] x [0,1] on the local triangle.\n\n```\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_det_jacobian-Tuple{Bcube.AbstractEntityType, Any, Any}","page":"Mapping","title":"Bcube.mapping_det_jacobian","text":"mapping_det_jacobian(ctype::AbstractEntityType, cnodes, ξ)\nmapping_det_jacobian(::TopologyStyle, ctype::AbstractEntityType, cnodes, ξ)\n\nAbsolute value of the determinant of the mapping Jacobian matrix, expressed in the reference element.\n\nImplementation\n\nFor a volumic cell (line in 1D, quad in 2D, cube in 3D), the default version uses mapping_jacobian, but the function can be specified for each shape.\n\nFor a curvilinear cell (line in 2D, or in 3D), the formula is always J = ||F'|| where F is the mapping. Hence we always fallback to the \"standard\" version, like for the volumic case.\n\nFinally, the surfacic cell (quad in 3D) needs a special treatment, see mapping_jacobian_hypersurface.\n\n::Bar2_t\n\nAbsolute value of the determinant of the mapping Jacobian matrix for the reference 2-nodes bar [-1,1] to the local bar mapping. det(J(xi)) = dfracx_r - x_l2\n\n::Tri3_t\n\nAbsolute value of the determinant of the mapping Jacobian matrix for the the reference 3-nodes Triangle [0,1] x [0,1] to the local triangle mapping.\n\nJ = (x_2 - x_1) (y_3 - y_1) - (x_3 - x_1) (y_2 - y_1)\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_face-Tuple{Bcube.AbstractShape, Any}","page":"Mapping","title":"Bcube.mapping_face","text":"mapping_face(cshape::AbstractShape, side)\nmapping_face(cshape::AbstractShape, side, permutation)\n\nBuild a mapping from the face reference element (corresponding to the side-th face of cshape) to the cell reference element (i.e the cshape).\n\nBuild a mapping from the face reference element (corresponding to the side-th face of cshape) to the cell reference element (i.e the cshape). If permutation is present, the mapping is built using this permutation.\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_inv-Tuple{Bcube.AbstractEntityType, Any, Any}","page":"Mapping","title":"Bcube.mapping_inv","text":"mapping_inv(::AbstractEntityType, cnodes, x)\n\nMap the local shape on the reference shape.\n\nImplementation\n\nThis function does not have to be implemented for all shape.\n\n::Bar2_t\n\nMap the local bar on the reference 2-nodes bar [-1,1]: F^-1(x) = dfrac2x - x_r - x_lx_r - x_l\n\n::Tri3_t\n\nMap the local triangle on the reference 3-nodes Triangle [0,1] x [0,1].\n\nTODO: check this formulae with SYMPY\n\nF^-1 beginpmatrix x  y endpmatrix =\nfrac1x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)\nbeginpmatrix\n    (y_3-y_1)x + (x_1 - x_3)y + (x_3 y_1 - x_1 y_3) \n    (y_1-y_2)x + (x_2 - x_1)x + (x_1 y_2 - x_2 y_1)\nendpmatrix\n\n::Quad4_t\n\nMap the  PARALLELOGRAM quadrilateral on the reference 4-nodes square [-1,1] x [-1,1]. Warning : this mapping is only corrects for parallelogram quadrilateral, not for any quadrilateral.\n\n\n\nTODO: check this formulae with SYMPY\n\nF^-1 beginpmatrix x  y endpmatrix =\nbeginpmatrix\n    a_1 x + b_1 y + c_1 \n    a_2 x + b_2 y + c_2\nendpmatrix\n\nwith\n\nbeginaligned\n    a_1  = dfrac-2 (y_3-y_2)Delta \n    b_1  = dfrac2 (x_3-x_2)Delta \n    c_1  = -1 - a_1 x_1 - b_1 y_1 \n    a_2  = dfrac-2 (y_1-y_2)Delta \n    b_2  = dfrac2 (x_1 - x_2)Delta \n    c_2  = -1 - a_2 x_1 - b_2 y_1\nendaligned\n\nwhere Delta = (x_1 - x_2)(y_3 - y_2) - (x_3 - x_2)(y_1 - y_2)\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_inv_jacobian-Tuple{Bcube.AbstractEntityType, Any, Any}","page":"Mapping","title":"Bcube.mapping_inv_jacobian","text":"mapping_inv_jacobian(ctype::AbstractEntityType, cnodes, x)\n\nJacobian matrix of the inverse mapping : dfracpartial F_i^-1partial x_j\n\nContrary to mapping_jacobian_inv, this function is not always defined because the inverse mapping, F^-1, is not always defined.\n\nImplementation\n\nDefault version using LinearAlgebra to inverse the matrix, but can be specified for each shape (if it exists).\n\n::Bar2_t\n\nMapping's jacobian matrix for the local bar to the reference 2-nodes bar [-1, 1].\n\ndfracpartial F^-1partial x = dfrac2x_r - x_l\n\n::Tri3_t\n\nMapping's jacobian matrix for the local triangle to the reference 3-nodes Triangle [0,1] x [0,1] mapping.\n\n\n\nTODO: check this formulae with SYMPY\n\nfracpartial F_i^-1partial x_j =\nfrac1x_1 (y_2 - y_3) + x_2 (y_3 - y_1) + x_3 (y_1 - y_2)\nbeginpmatrix\n    y_3 - y_1  x_1 - x_3 \n    y_1 - y_2  x_2 - x_1\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_jacobian-Tuple{Bcube.AbstractEntityType, Any, Any}","page":"Mapping","title":"Bcube.mapping_jacobian","text":"mapping_jacobian(ctype::AbstractEntityType, cnodes, ξ)\n\nJacobian matrix of the mapping : dfracpartial F_ipartial xi_j.\n\nImplementation\n\nDefault version using ForwardDiff, but can be specified for each shape.\n\n::Bar2_t\n\nMapping's jacobian matrix for the reference 2-nodes bar [-1, 1] to the local bar. dfracpartial Fpartial xi = dfracx_r - x_l2\n\n::Bar3_t\n\nMapping's jacobian matrix for the reference 2-nodes bar [-1, 1] to the local bar. ``\\dfrac{\\partial F}{\\partial \\xi} = \\frac{1}{2} \\left( (2\\xi - 1) M1 + (2\\xi + 1)M2 - 4 \\xi M_3\\right)\n\n::Tri3_t\n\nMapping's jacobian matrix for the reference 3-nodes Triangle [0,1] x [0,1] to the local triangle mapping.\n\ndfracpartial F_ipartial xi_j =\nbeginpmatrix\n    M_2 - M_1  M_3 - M_1\nendpmatrix\n\n::Quad4_t\n\nMapping's jacobian matrix for the reference square [-1,1] x [-1,1] to the 4-quadrilateral\n\nfracpartial Fpartial xi = -M_1 + M_2 + M_3 - M_4 + eta (M_1 - M_2 + M_3 - M_4)\n\nfracpartial Fpartial eta = -M_1 - M_2 + M_3 + M_4 + xi (M_1 - M_2 + M_3 - M_4)\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_jacobian_hypersurface-Tuple{Any, Any, Any}","page":"Mapping","title":"Bcube.mapping_jacobian_hypersurface","text":"mapping_jacobian_hypersurface(ctype, cnodes, ξ)\n\n\"Augmented\" jacobian matrix of the mapping.\n\nLet's consider a mathbbR^2 surface in mathbbR^3. The mapping F_Gamma(xi eta) maps the reference coordinate system to the physical coordinate system. It's jacobian J_Gamma is not squared. We can 'extend' this mapping to reach any point in mathbbR^3 (and not only the surface) using\n\nF(xi eta zeta) = F_Gamma(xi eta) + zeta nu\n\nwhere nu is the conormal. Then the restriction of the squared jacobian of F to the surface is simply\n\nJ_Gamma = (J_Gammanu)\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_jacobian_inv-Tuple{Bcube.AbstractEntityType, Any, Any}","page":"Mapping","title":"Bcube.mapping_jacobian_inv","text":"mapping_jacobian_inv(ctype::AbstractEntityType, cnodes, ξ)\n\nInverse of the mapping jacobian matrix. This is not exactly equivalent to the mapping_inv_jacobian since this function is evaluated in the reference element.\n\nImplementation\n\nDefault version using ForwardDiff, but can be specified for each shape.\n\n::Bar2_t\n\nInverse of mapping's jacobian matrix for the reference 2-nodes bar [-1, 1] to the local bar.\n\ndfracpartial Fpartial xi^-1 = dfrac2x_r - x_l\n\n::Bar3_t\n\nInverse of mapping's jacobian matrix for the reference 2-nodes bar [-1, 1] to the local bar.\n\ndfracpartial Fpartial xi^-1 = frac2(2xi - 1) M_1 + (2xi + 1)M_2 - 4 xi M_3\n\n::Tri3_t\n\nInverse of mapping's jacobian matrix for the reference 3-nodes Triangle [0,1] x [0,1] to the local triangle mapping.\n\ndfracpartial F_ipartial xi_j^-1 =\nfrac1(x_1 - x_2)(y_1 - y_3) - (x_1 - x_3)(y_1 - y_2)\nbeginpmatrix\n    -y_1 + y_3   x_1 - x_3 \n     y_1 - y_2  -x_1 + x_2\nendpmatrix\n\n::Quad4_t\n\nInverse of mapping's jacobian matrix for the reference square [-1,1] x [-1,1] to the 4-quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.normal-Tuple{Bcube.AbstractEntityType, Any, Any, Any}","page":"Mapping","title":"Bcube.normal","text":"normal(ctype::AbstractEntityType, cnodes, iside, ξ)\nnormal(::TopologyStyle, ctype::AbstractEntityType, cnodes, iside, ξ)\n\nNormal vector of the isideth face of a cell, evaluated at position ξ in the face reference element. So for the normal vector of the face of triangle living in a 3D space, ξ will be 1D (because the face is a line, which 1D).\n\nBeware this function needs the nodes cnodes and the type ctype of the cell (and not of the face).\n\nTODO: If iside is positive, then the outward normal (with respect to the cell) is returned, otherwise the inward normal is returned.\n\n::isCurvilinear\n\nNote that the \"face\" normal vector of a curve is the \"direction\" vector at the given extremity.\n\n::isVolumic\n\nn^loc = J^-intercal n^ref\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Reference-to-physical","page":"Mapping","title":"Reference to physical","text":"","category":"section"},{"location":"api/mapping/mapping/#Bcube.interpolate-Tuple{Any, Any}","page":"Mapping","title":"Bcube.interpolate","text":"interpolate(λ, q)\ninterpolate(λ, q, ncomps)\n\nCreate the interpolation function from a set of value on dofs and the shape functions, given by:\n\n    f(x) = sum_i=1^N q_i lambda_i(x)\n\nSo q is a vector whose size equals the number of dofs in the cell.\n\nIf ncomps is present, create the interpolation function for a vector field given by a set of value on dofs and the shape functions.\n\nThe interpolation formulae is the same than interpolate(λ, q) but the result is a vector function. Here q is a vector whose size equals the total number of dofs in the cell (all components mixed).\n\nNote that the result function is expressed in the same coordinate system as the input shape functions (i.e reference or local).\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.∂fξ_∂x-Union{Tuple{F}, Tuple{F, Val{1}, Bcube.AbstractEntityType, Any, Any}} where F","page":"Mapping","title":"Bcube.∂fξ_∂x","text":"∂fξ_∂x(f, n::Val{N}, ctype::AbstractEntityType, cnodes, ξ) where N\n\nCompute the gradient, with respect to the physical coordinates, of a function f on a point in the reference domain. N is the size of the codomain of f.\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.∂λξ_∂x","page":"Mapping","title":"Bcube.∂λξ_∂x","text":"∂λξ_∂x(::AbstractFunctionSpace, ::Val{N}, ctype::AbstractEntityType, cnodes, ξ) where N\n\nGradient, with respect to the physical coordinate system, of the shape functions associated to the FunctionSpace.\n\nDepending on the value of N, the shape functions are interpreted as associated to a scalar FESpace (N = 1) or a vector FESpace. For a vector FESpace, the result gradient is an array of size (n*Nc, n, d) where Nc is the number of dofs of one component (i.e scalar case), n is the size of the FESpace, and d the number of spatial dimensions.\n\nDefault version : the gradient shape functions are \"replicated\".\n\nSpecialize with a given FESpace for a custom behaviour.\n\nImplementation\n\nWe cannot use the topology_style to dispatch because this style is too specific to integration methods. For instance for the integration it is important the consider any line as isCurvilinear. However for the gradient computation we must distinguish a line in 1D, a line in 2D and a line in 3D...\n\n\n\n\n\n\n\n","category":"function"},{"location":"#Bcube.jl","page":"Home","title":"Bcube.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bcube is a Julia library providing tools for the spatial discretization of partial differential equation(s) (PDE). It offers a high-level API to discretize linear or non-linear problems on unstructured mesh using continuous or discontinuous finite elements (FEM - DG).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main features are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"high-level api : a(u, v) = ∫(η * ∇(u) ⋅ ∇(v))dΩ\n1D, 2D, 3D unstructured mesh with high-order geometrical elements (gmsh format)\nLagrange (continuous & discontinuous) and Taylor (discontinuous) finite elements (line, quad, tri, hexa, penta)\narbitrary order for hypercube Lagrange elements","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\nCommented tutorials as well as various examples can be found in the dedicated project BcubeTutorials.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bcube can be added to your Julia environment with this simple line :","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add Bcube","category":"page"},{"location":"#Alternatives","page":"Home","title":"Alternatives","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Numerous FEM-DG Julia packages are available, here is a non-exhaustive list;","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gridap.jl (which has greatly influenced the development of Bcube)\nFerrite.jl\nTrixi.jl","category":"page"},{"location":"#Contribution","page":"Home","title":"Contribution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Any contribution(s) and/or remark(s) are welcome! Don't hesitate to open an issue to ask a question or signal a bug. PRs improving the code (new features, new elements, fixing bugs, ...) will be greatly appreciated.","category":"page"},{"location":"#Gallery","page":"Home","title":"Gallery","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Helmholtz equation Phase field solidification Linear transport equation\n(Image: ) (Image: ) (Image: )\nHeat equation on a sphere Transport equation on hypersurfaces Linear thermo-elasticity\n(Image: ) (Image: ) (Image: )","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ghislain Blanchard, Lokman Bennani and Maxime Bouyges","category":"page"}]
}
