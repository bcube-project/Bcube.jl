var documenterSearchIndex = {"docs":
[{"location":"api/operator/operator/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"api/operator/operator/","page":"Operators","title":"Operators","text":"Modules = [Bcube]\nPages   = [\"operator.jl\"]","category":"page"},{"location":"api/dof/dof/#Degree-of-freedom","page":"Degree of freedom","title":"Degree of freedom","text":"","category":"section"},{"location":"api/dof/dof/#Assembler","page":"Degree of freedom","title":"Assembler","text":"","category":"section"},{"location":"api/dof/dof/","page":"Degree of freedom","title":"Degree of freedom","text":"Modules = [Bcube]\nPages   = [\"assembler.jl\"]","category":"page"},{"location":"api/dof/dof/#Bcube.AbstractBilinearFaceSidePair","page":"Degree of freedom","title":"Bcube.AbstractBilinearFaceSidePair","text":"AbstractBilinearFaceSidePair{A} <: AbstractLazyWrap{A}\n\nInterface:\n\n* get_args_bilinear(a::AbstractBilinearFaceSidePair)\n\n\n\n\n\n","category":"type"},{"location":"api/dof/dof/#Bcube.AbstractFaceSidePair","page":"Degree of freedom","title":"Bcube.AbstractFaceSidePair","text":"AbstractFaceSidePair{A} <: AbstractLazyWrap{A}\n\nInterface:\n\nside_n(a::AbstractFaceSidePair)\nside_p(a::AbstractFaceSidePair)\n\n\n\n\n\n","category":"type"},{"location":"api/dof/dof/#Bcube.__assemble_linear!-Tuple{Any, Any, Any, Measure}","page":"Degree of freedom","title":"Bcube.__assemble_linear!","text":"Dev notes\n\nTwo levels of \"LazyMapOver\" because first we LazyMapOver the Tuple of argument of the linear form, and the for each item of this Tuple we LazyMapOver the shape functions.\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._append_contribution!-Tuple{Any, Any, Any, Any, Any, Any, Bcube.CellInfo, Any}","page":"Degree of freedom","title":"Bcube._append_contribution!","text":"bilinear case\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._assemble_linear!-Tuple{Any, Any, Any, Bcube.Integration}","page":"Degree of freedom","title":"Bcube._assemble_linear!","text":"_assemble_linear!(b, l, V, integration::Integration)\n_assemble_linear!(b, l, V, integration::MultiIntegration{N}) where {N}\n\nThese functions act as a function barrier in order to:\n\nget the function corresponding to the operand in the linear form\nreshape b internally to deal with cases when V is a AbstractMultiTestFESpace\ncall __assemble_linear! to apply dispatch on the type of measure of the integration and improve type stability during the assembling loop.\n\nDev note:\n\nThe case integration::MultiIntegration{N} is treated by looping over each Integration contained in the MultiIntegration\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._blockmap_bilinear-Union{Tuple{N2}, Tuple{N1}, Tuple{Tuple{Vararg{T, N1}} where T, Tuple{Vararg{T, N2}} where T}} where {N1, N2}","page":"Degree of freedom","title":"Bcube._blockmap_bilinear","text":"From tuples a=(a_1 a_2  a_i  a_m) and b=(b_1 b_2  b_j  b_n), it builds A and B which correspond formally to the following two matrices :\n\nA equiv beginpmatrix\na_1  a_1    a_1\na_2  a_2    a_2\n            \na_m  a_m    a_m\nendpmatrix\nqquad and qquad\nB equiv beginpmatrix\nb_1  b_2    b_n\nb_1  b_2    b_n\n            \nb_1  b_2    b_n\nendpmatrix\n\nA and B are wrapped in LazyMapOver structures so that all operations on them are done elementwise by default (in other words, it can be considered that the operations are automatically broadcasted).\n\nDev note :\n\nBoth A and B are stored as a tuple of tuples, wrapped by LazyMapOver, where inner tuples correspond to each columns of a matrix. This hierarchical structure reduces both inference and compile times by avoiding the use of large tuples.\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._diag_tuples-Union{Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Any}} where N","page":"Degree of freedom","title":"Bcube._diag_tuples","text":"_diag_tuples(diag::Tuple{Vararg{Any,N}}, b) where N\n\nReturn N tuples of length N. For each tuple tᵢ, its values are defined so that tᵢ[k]=diag[k] if k==i, tᵢ[k]=b otherwise. The result can be seen as a dense diagonal-like array using tuple.\n\nExample for N=3:\n\n(diag[1],  b,       b      ),\n(b,        diag[2], b      ),\n(b,        b,       diag[3]))\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._get_multi_tuple_var-Union{Tuple{Tuple{Vararg{Any, N}}}, Tuple{N}} where N","page":"Degree of freedom","title":"Bcube._get_multi_tuple_var","text":"For N=3 for example:     (LazyMapOver((LazyMapOver(V[1]), NullOperator(),  NullOperator())),      LazyMapOver((NullOperator(),  LazyMapOver(V[2]), NullOperator())),      LazyMapOver((NullOperator(),  NullOperator(),  LazyMapOver(V[3]))))\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._may_reshape_b-Tuple{AbstractVector, TestFESpace}","page":"Degree of freedom","title":"Bcube._may_reshape_b","text":"For AbstractMultiTestFESpace, it creates a Tuple (of views) of the different \"destination\" in the vector: one for each FESpace\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.assemble_bilinear!-Tuple{Vector{Int64}, Vector{Int64}, Vector, Function, Measure, TrialFESpace, TestFESpace}","page":"Degree of freedom","title":"Bcube.assemble_bilinear!","text":"assemble_bilinear!(\n    I::Vector{Int},\n    J::Vector{Int},\n    X::Vector{T},\n    f::Function,\n    measure::Measure,\n    U::TrialFESpace,\n    V::TestFESpace,\n)\n\nIn-place version of assemble_bilinear.\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.assemble_bilinear-Union{Tuple{N}, Tuple{Function, Union{Bcube.AbstractMultiFESpace{N, <:Tuple{Vararg{TrialFESpace, N}}}, TrialFESpace}, Union{Bcube.AbstractMultiFESpace{N, <:Tuple{Vararg{TestFESpace, N}}}, TestFESpace}}} where N","page":"Degree of freedom","title":"Bcube.assemble_bilinear","text":"assemble_bilinear(a::Function, U, V)\n\nAssemble the (sparse) Matrix corresponding to the given bilinear form a on the trial and test finite element spaces U and V.\n\nFor the in-place version, check-out assemble_bilinear!.\n\nArguments\n\na::Function : function of two variables (u,v) representing the bilinear form\nU : trial finite element space (for u)\nV : test finite element space (for v)\n\nExamples\n\njulia> mesh = rectangle_mesh(3,3)\njulia> U = TrialFESpace(FunctionSpace(:Lagrange, 0), mesh)\njulia> V = TestFESpace(U)\njulia> dΩ = Measure(CellDomain(mesh), 3)\njulia> a(u, v) = ∫(u * v)dΩ\njulia> assemble_bilinear(a, U, V)\n4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n 0.25   ⋅     ⋅     ⋅\n  ⋅    0.25   ⋅     ⋅\n  ⋅     ⋅    0.25   ⋅\n  ⋅     ⋅     ⋅    0.25\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.assemble_linear!-Tuple{AbstractVector, Function, Union{Bcube.AbstractMultiFESpace{N, <:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}}","page":"Degree of freedom","title":"Bcube.assemble_linear!","text":"assemble_linear!(b::AbstractVector, l::Function, V::Union{TestFESpace, AbstractMultiTestFESpace})\n\nIn-place version of assemble_linear.\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.assemble_linear-Tuple{Function, Union{Bcube.AbstractMultiFESpace{N, <:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}}","page":"Degree of freedom","title":"Bcube.assemble_linear","text":"assemble_linear(l::Function, V::Union{TestFESpace, AbstractMultiTestFESpace})\n\nAssemble the vector corresponding to a linear form l on the finite element space V\n\nFor the in-place version, checkout assemble_linear!.\n\nArguments\n\nl::Function : linear form to assemble, a function of one variable l(v)\nV : test finite element space\n\nExamples\n\njulia> mesh = rectangle_mesh(3,3)\njulia> U = TrialFESpace(FunctionSpace(:Lagrange, 0), mesh)\njulia> V = TestFESpace(U)\njulia> dΩ = Measure(CellDomain(mesh), 3)\njulia> l(v) = ∫(v)dΩ\njulia> assemble_linear(l, V)\n4-element Vector{Float64}:\n 0.25\n 0.25\n 0.25\n 0.25\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.blockmap_bilinear_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractFESpace, Bcube.AbstractCellInfo}","page":"Degree of freedom","title":"Bcube.blockmap_bilinear_shape_functions","text":"Dev notes:\n\nReturn blockU and blockV to be able to compute the local matrix corresponding to the bilinear form :\n\n    Aij = a(λᵤj λᵥi)\n\nwhere λᵤ and λᵥ are the shape functions associated with the trial U and the test V function spaces respectively. In a \"map-over\" version, it can be written :\n\n    A = a(blockU blockV)\n\nwhere blockU and blockV correspond formally to the lazy-map-over matrices :\n\n    k blockUkj = λᵤj\n        blockVik = λᵥi\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.blockmap_shape_functions-Tuple{Any, Bcube.FaceInfo}","page":"Degree of freedom","title":"Bcube.blockmap_shape_functions","text":"Dev note :\n\nMaterialize the integrand function on all the different possible Tuples of v=(v1,0,0,...), (0,v2,0,...), ..., (..., vi, ...)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.blockmap_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractCellInfo}","page":"Degree of freedom","title":"Bcube.blockmap_shape_functions","text":"blockmap_shape_functions(fespace::AbstractFESpace, cellinfo::AbstractCellInfo)\n\nReturn all shape functions a = LazyMapOver((λ₁, λ₂, …, λₙ)) corresponding to fespace in cell cellinfo. These shape functions are wrapped by a LazyMapOver so that for a function f it gives:     f(a) == map(f, a)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.blockmap_shape_functions-Tuple{Bcube.AbstractMultiFESpace, Bcube.AbstractCellInfo}","page":"Degree of freedom","title":"Bcube.blockmap_shape_functions","text":"blockmap_shape_functions(multiFESpace::AbstractMultiFESpace, cellinfo::AbstractCellInfo)\n\nReturn all shape functions corresponding to each fespace in multiFESSpace for cell cellinfo :\n\n    ((v₁   ) ( v₂  )  (    vₙ))\n\nwhere:\n\nvᵢ = (λᵢ₁, λᵢ₂, …, λᵢ_ₘ) are the shapes functions of the i-th fespace in the cell.\n∅ are NullOperators\n\nNote that the LazyMapOver is used to wrap recursively the result.\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.compute-Tuple{Bcube.Integration}","page":"Degree of freedom","title":"Bcube.compute","text":"compute(integration::Integration)\n\nCompute an integral, independently from a FEM/DG framework (i.e without FESpace)\n\nReturn a SparseVector. The indices of the domain elements are used to store the result of the integration in this sparse vector.\n\nExample\n\nCompute volume of each cell and each face.\n\nmesh = rectangle_mesh(2, 3)\ndΩ = Measure(CellDomain(mesh), 1)\ndΓ = Measure(BoundaryFaceDomain(mesh), 1)\nf = PhysicalFunction(x -> 1)\n@show Bcube.compute(∫(f)dΩ)\n@show Bcube.compute(∫(side⁻(f))dΓ)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#DofHandler","page":"Degree of freedom","title":"DofHandler","text":"","category":"section"},{"location":"api/dof/dof/","page":"Degree of freedom","title":"Degree of freedom","text":"Modules = [Bcube]\nPages   = [\"dofhandler.jl\"]","category":"page"},{"location":"api/dof/dof/#Bcube.DofHandler","page":"Degree of freedom","title":"Bcube.DofHandler","text":"The DofHandler handles the degree of freedom numbering. To each degree of freedom is associated a unique integer.\n\n\n\n\n\n","category":"type"},{"location":"api/dof/dof/#Bcube.DofHandler-Tuple{Bcube.Mesh, Bcube.AbstractFunctionSpace, Int64, Bool}","page":"Degree of freedom","title":"Bcube.DofHandler","text":"DofHandler(mesh::Mesh, fSpace::AbstractFunctionSpace, ncomponents::Int, isContinuous::Bool)\n\nConstructor of a DofHandler for a SingleFESpace on a Mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._deal_with_dofs_on_edges!-Tuple{Dict{Tuple{Int64, Set{Int64}}, Tuple{Int64, Vector{Int64}}}, Any, Any, Any, Any, Int64, Any, Bcube.AbstractShape, Int64, Bcube.AbstractFunctionSpace}","page":"Degree of freedom","title":"Bcube._deal_with_dofs_on_edges!","text":"deal_with_dofs_on_edges!(dict, iglob, offset, c2n, celltypes, icell::Int, inodes_g, e2n_g, s::AbstractShape, kvar::Int, fs)\n\nFunction dealing with dofs shared by different cell through an edge connection (excluding bord vertices).\n\nTODO : remove kvar\n\nArguments\n\ndict may be modified by this routine\niglob may be modified by this routine\noffset may be modified by this routine\nfs : FunctionSpace of var kvar\nicell : cell index\nkvar : var index\ns : shape of icell-th cell\ninodes_g : global indices of nodes of icell\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._deal_with_dofs_on_faces!-Tuple{Any, Any, Any, Any, Any, Int64, Vector{Vector{Int64}}, Bcube.AbstractShape, Bcube.AbstractFunctionSpace, Int64}","page":"Degree of freedom","title":"Bcube._deal_with_dofs_on_faces!","text":"TODO : remove kvar\n\nArguments\n\nf2n_g : local face index -> global nodes indices\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube._deal_with_dofs_on_vertices!-Tuple{Dict{Tuple{Int64, Int64}, Tuple{Int64, Vector{Int64}}}, Any, Any, Int64, Any, Bcube.AbstractShape, Int64, Bcube.AbstractFunctionSpace}","page":"Degree of freedom","title":"Bcube._deal_with_dofs_on_vertices!","text":"deal_with_dofs_on_vertices!(dict, iglob, offset, icell::Int, inodes_g, s::AbstractShape, kvar::Int, fs)\n\nFunction dealing with dofs shared by different cell through a vertex connection.\n\nTODO : remove kvar\n\nArguments\n\ndict may be modified by this routine\niglob may be modified by this routine\noffset may be modified by this routine\nfs : FunctionSpace of var kvar\nicell : cell index\nkvar : var index\ns : shape of icell-th cell\ninodes_g : global indices of nodes of icell\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.dof-Tuple{Bcube.DofHandler, Any, Int64, Int64}","page":"Degree of freedom","title":"Bcube.dof","text":"dof(dhl::DofHandler, icell, icomp::Int, idof::Int)\n\nGlobal index of the idof local degree of freedom of component icomp in cell icell.\n\nExample\n\nmesh = one_cell_mesh(:line)\ndhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))\n@show dof(dhl, 1, 1, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.dof-Tuple{Bcube.DofHandler, Any, Int64}","page":"Degree of freedom","title":"Bcube.dof","text":"dof(dhl::DofHandler, icell, icomp::Int)\n\nGlobal indices of all the dofs of a given component in a given cell\n\nExample\n\nmesh = one_cell_mesh(:line)\ndhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))\n@show dof(dhl, 1, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.get_ncomponents-Tuple{Bcube.DofHandler}","page":"Degree of freedom","title":"Bcube.get_ncomponents","text":"Number of components handled by a DofHandler\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.max_ndofs-Tuple{Bcube.DofHandler}","page":"Degree of freedom","title":"Bcube.max_ndofs","text":"max_ndofs(dhl::DofHandler)\n\nCount maximum number of dofs per cell, all components mixed\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.ndofs-Tuple{Bcube.DofHandler, Any, AbstractVector{Int64}}","page":"Degree of freedom","title":"Bcube.ndofs","text":"ndofs(dhl, icell, icomp::Vector{Int})\n\nNumber of dofs for a given set of components in a given cell.\n\nExample\n\nmesh = one_cell_mesh(:line)\ndhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1); size = 2))\n@show ndofs(dhl, 1, [1, 2])\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.ndofs-Tuple{Bcube.DofHandler, Any, Int64}","page":"Degree of freedom","title":"Bcube.ndofs","text":"ndofs(dhl, icell, kvar::Int)\n\nNumber of dofs for a given variable in a given cell.\n\nExample\n\nmesh = one_cell_mesh(:line)\ndhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))\n@show ndofs(dhl, 1, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.ndofs-Tuple{Bcube.DofHandler, Any}","page":"Degree of freedom","title":"Bcube.ndofs","text":"ndofs(dhl::DofHandler, icell)\n\nNumber of dofs for a given cell.\n\nNote that for a vector variable, the total (accross all components) number of dofs is returned.\n\nExample\n\nmesh = one_cell_mesh(:line)\ndhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))\n@show ndofs(dhl, 1, :u)\n\n\n\n\n\n","category":"method"},{"location":"api/dof/dof/#Bcube.ndofs-Tuple{Bcube.DofHandler}","page":"Degree of freedom","title":"Bcube.ndofs","text":"ndofs(dhl::DofHandler)\n\nTotal number of dofs. This function takes into account that dofs can be shared by multiple cells.\n\nExample\n\nmesh = one_cell_mesh(:line)\ndhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))\n@show ndofs(dhl::DofHandler)\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Finite-element-spaces","page":"Finite element spaces","title":"Finite element spaces","text":"","category":"section"},{"location":"api/interpolation/fespace/","page":"Finite element spaces","title":"Finite element spaces","text":"Modules = [Bcube]\nPages   = [\"fespace.jl\"]","category":"page"},{"location":"api/interpolation/fespace/#Bcube.AbstractFESpace","page":"Finite element spaces","title":"Bcube.AbstractFESpace","text":"Abstract type to represent an finite-element space of size S. See SingleFESpace for more details about what looks like a finite-element space.\n\nDevs notes\n\nAll subtypes should implement the following functions:\n\nget_function_space(feSpace::AbstractFESpace)\nget_shape_functions(feSpace::AbstractFESpace, shape::AbstractShape)\nget_cell_shape_functions(feSpace::AbstractFESpace, shape::AbstractShape)\nget_ndofs(feSpace::AbstractFESpace)\nis_continuous(feSpace::AbstractFESpace)\n\nAlternatively, you may define a \"parent\" to your structure by implementing the Base.parent function. Then, all the above functions will be redirected to the \"parent\" FESpace.\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.AbstractMultiFESpace","page":"Finite element spaces","title":"Bcube.AbstractMultiFESpace","text":"Devs notes\n\nAll subtypes should implement the following functions:\n\nget_fespace(mfeSpace::AbstractMultiFESpace)\nget_mapping(mfeSpace::AbstractMultiFESpace)\nget_dofs(mfeSpace::AbstractMultiFESpace, icell::Int)\nget_shape_functions(mfeSpace::AbstractMultiFESpace, shape::AbstractShape)\nget_cell_shape_functions(mfeSpace::AbstractMultiFESpace, shape::AbstractShape)\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.MultiFESpace","page":"Finite element spaces","title":"Bcube.MultiFESpace","text":"A MultiFESpace represents a \"set\" of TrialFESpace or TestFESpace. This structure provides a global dof numbering for each FESpace.\n\nN is the number of FESpace contained in this MultiFESpace.\n\nNote that the FESpace can be different from each other (one continous, one discontinuous; one scalar, one vector...)\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.MultiFESpace-Union{Tuple{Tuple{Vararg{Union{TestFESpace{S, FE}, TrialFESpace{S, FE}} where {S, FE}, N}}}, Tuple{N}} where N","page":"Finite element spaces","title":"Bcube.MultiFESpace","text":"MultiFESpace(\n    feSpaces::Tuple{Vararg{TrialOrTest, N}};\n    arrayOfStruct::Bool = AOS_DEFAULT,\n) where {N}\nMultiFESpace(\n    feSpaces::AbstractArray{FE};\n    arrayOfStruct::Bool = AOS_DEFAULT,\n) where {FE <: TrialOrTest}\nMultiFESpace(feSpaces::Vararg{TrialOrTest}; arrayOfStruct::Bool = AOS_DEFAULT)\n\nBuild a finite element space representing several sub- finite element spaces.\n\nThis is particulary handy when several variables are in play since it provides a global dof numbering (for the whole system). The finite element spaces composing the MultiFESpace can be different from each other (some continuous, some discontinuous, some scalar, some vectors...).\n\nArguments\n\nfeSpaces : the finite element spaces composing the MultiFESpace.   Note that they must be of type TrialFESpace or TestFESpace.\n\nKeywords\n\narrayOfStruct::Bool = AOS_DEFAULT : indicates if the dof numbering should be of type \"Array of Structs\" (AoS)   or \"Struct of Arrays\" (SoA).\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.SingleFESpace","page":"Finite element spaces","title":"Bcube.SingleFESpace","text":"SingleFESpace(\n    fSpace::AbstractFunctionSpace,\n    mesh::AbstractMesh,\n    dirichletBndNames = String[];\n    size::Int = 1,\n    isContinuous::Bool = true,\n    kwargs...\n)\n\nBuild a finite element space (scalar or vector) from a FunctionSpace and a Mesh.\n\nArguments\n\nfSpace::AbstractFunctionSpace : the function space associated to the FESpace\nmesh::AbstractMesh : the mesh on which the FESpace is discretized\ndirichletBndNames = String[] : list of mesh boundary labels where a Dirichlet condition applies\n\nKeywords\n\nsize::Int = 1 : the number of components of the FESpace\nisContinuous::Bool = true : if true, a continuous dof numbering is created. Otherwise, dof lying\n\non cell nodes or cell faces are duplicated, not shared (discontinuous dof numbering)\n\nkwargs : for things such as parallel cache (internal/dev usage only)\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.SingleFESpace-2","page":"Finite element spaces","title":"Bcube.SingleFESpace","text":"An finite-element space (FESpace) is basically a function space, associated to degrees of freedom (on a mesh).\n\nA FESpace can be either scalar (to represent a Temperature for instance) or vector (to represent a Velocity). In case of a \"vector\" SingleFESpace, all the components necessarily share the same FunctionSpace.\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.TestFESpace","page":"Finite element spaces","title":"Bcube.TestFESpace","text":"TestFESpace(trialFESpace::TrialFESpace)\nTestFESpace(\n    fSpace::AbstractFunctionSpace,\n    mesh::AbstractMesh,\n    dirichletBndNames = String[];\n    size::Int = 1,\n    isContinuous::Bool = true,\n    kwargs...,\n)\n\nBuild a test finite element space.\n\nA TestFESpace can be built from a TrialFESpace. See SingleFESpace for hints about the function arguments. Only arguments specific to TrialFESpace are detailed below.\n\nExamples\n\njulia> mesh = one_cell_mesh(:line)\njulia> fSpace = FunctionSpace(:Lagrange, 2)\njulia> U = TrialFESpace(fSpace, mesh)\njulia> V = TestFESpace(U)\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.TestFESpace-2","page":"Finite element spaces","title":"Bcube.TestFESpace","text":"A TestFESpace is basically a SingleFESpace plus other attributes (related to boundary conditions)\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.TrialFESpace","page":"Finite element spaces","title":"Bcube.TrialFESpace","text":"A TrialFESpace is basically a SingleFESpace plus other attributes (related to boundary conditions)\n\nDev notes\n\nwe cannot directly store Dirichlet values on dofs because the Dirichlet values needs \"time\" to apply\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.TrialFESpace-2","page":"Finite element spaces","title":"Bcube.TrialFESpace","text":"TrialFESpace(feSpace, dirichletValues)\nTrialFESpace(\n    fSpace::AbstractFunctionSpace,\n    mesh::AbstractMesh,\n    dirichlet::Dict{String} = Dict{String, Any}();\n    size::Int = 1,\n    isContinuous::Bool = true,\n    kwargs...\n)\nTrialFESpace(\n    fSpace::AbstractFunctionSpace,\n    mesh::AbstractMesh,\n    type::Symbol,\n    dirichlet::Dict{String} = Dict{String, Any}();\n    size::Int = 1,\n    kwargs...\n)\n\nBuild a trial finite element space.\n\nSee SingleFESpace for hints about the function arguments. Only arguments specific to TrialFESpace are detailed below.\n\nArguments\n\ndirichlet::Dict{String} = Dict{String, Any}() : dictionnary specifying the Dirichlet   valued-function (or function) associated to each mesh boundary label. The function f(x,t)   to apply is expressed in the physical coordinate system. Alternatively, a constant value   can be provided instead of a function.\ntype::Symbol : :continuous or :discontinuous\n\nWarning\n\nFor now the Dirichlet condition can only be applied to nodal bases.\n\nExamples\n\njulia> mesh = one_cell_mesh(:line)\njulia> fSpace = FunctionSpace(:Lagrange, 2)\njulia> U = TrialFESpace(fSpace, mesh)\njulia> V = TrialFESpace(fSpace, mesh, :discontinuous; size = 3)\njulia> W = TrialFESpace(fSpace, mesh, Dict(\"North\" => 3., \"South\" => (x,t) -> t .* x))\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/fespace/#Bcube.MultiplierFESpace","page":"Finite element spaces","title":"Bcube.MultiplierFESpace","text":"A MultiplierFESpace can be viewed as a set of independant P0 elements. It is used to define Lagrange multipliers and assemble the associated augmented system (the system that adds the multipliers as unknowns).\n\n\n\n\n\n","category":"function"},{"location":"api/interpolation/fespace/#Bcube._MultiFESpace-Union{Tuple{Tuple{Vararg{Union{TestFESpace{S, FE}, TrialFESpace{S, FE}} where {S, FE}, N}}}, Tuple{N}} where N","page":"Finite element spaces","title":"Bcube._MultiFESpace","text":"Low-level constructor \n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube._build_mapping_AoS-Tuple{Tuple{Vararg{Union{TestFESpace{S, FE}, TrialFESpace{S, FE}} where {S, FE}}}, Int64}","page":"Finite element spaces","title":"Bcube._build_mapping_AoS","text":"Build a global numbering using an Array-Of-Struct strategy\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube._build_mapping_SoA-Tuple{Tuple{Vararg{Union{TestFESpace{S, FE}, TrialFESpace{S, FE}} where {S, FE}}}, Int64}","page":"Finite element spaces","title":"Bcube._build_mapping_SoA","text":"Build a global numbering using an Struct-Of-Array strategy \n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.allocate_dofs","page":"Finite element spaces","title":"Bcube.allocate_dofs","text":"allocate_dofs(feSpace::AbstractFESpace, T = Float64)\n\nAllocate a vector with a size equal to the number of dof of the FESpace, with the type T. For a MultiFESpace, a vector of the total size of the space is returned (and not a Tuple of vectors)\n\n\n\n\n\n","category":"function"},{"location":"api/interpolation/fespace/#Bcube.get_cell_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractShape}","page":"Finite element spaces","title":"Bcube.get_cell_shape_functions","text":"Return the shape functions associated to the AbstractFESpace in \"packed\" form:  λ(x) = (λ₁(x),...,λᵢ(x),...λₙ(x)) for the n dofs.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_dirichlet_boundary_tags-Tuple{Bcube.AbstractFESpace}","page":"Finite element spaces","title":"Bcube.get_dirichlet_boundary_tags","text":"Return the boundary tags where a Dirichlet condition applies\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_dirichlet_values-Tuple{TrialFESpace}","page":"Finite element spaces","title":"Bcube.get_dirichlet_values","text":"Return the values associated to a Dirichlet condition\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_dofs-Tuple{Bcube.AbstractFESpace, Int64}","page":"Finite element spaces","title":"Bcube.get_dofs","text":"Return the dofs indices for the cell icell\n\nResult is an array of integers.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_dofs-Tuple{MultiFESpace, Int64}","page":"Finite element spaces","title":"Bcube.get_dofs","text":"get_dofs(feSpace::MultiFESpace, icell::Int)\n\nReturn the dofs indices for the cell icell for each single-feSpace. Result is a tuple of array of integers, where each array of integers are the indices relative to the numbering of each singleFESpace.\n\nWarning:\n\nCombine get_dofs with get_mapping if global dofs indices are needed.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_fespace-Tuple{Bcube.AbstractMultiFESpace}","page":"Finite element spaces","title":"Bcube.get_fespace","text":"get_fespace(mfeSpace::AbstractMultiFESpace, iSpace)\nget_fespace(mfeSpace::AbstractMultiFESpace)\n\nReturn the i-th FESpace composing this AbstractMultiFESpace. If no index is provided, the tuple of FESpace composing this AbstractMultiFESpace` is returnted.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_fespace-Tuple{MultiFESpace}","page":"Finite element spaces","title":"Bcube.get_fespace","text":"Return the tuple of FESpace composing this MultiFESpace\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_function_space-Tuple{Bcube.AbstractFESpace}","page":"Finite element spaces","title":"Bcube.get_function_space","text":"Return the FunctionSpace (eventually multiple spaces) associated to the AbstractFESpace.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_mapping-Tuple{Bcube.AbstractMultiFESpace}","page":"Finite element spaces","title":"Bcube.get_mapping","text":"get_mapping(mfeSpace::AbstractMultiFESpace, iSpace)\nget_mapping(mfeSpace::AbstractMultiFESpace)\n\nReturn the mapping for the ith FESpace composing the MultiFESpace. If no index is provided, the tuple of mapping for each FESpace` is returnted.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_n_fespace-Union{Tuple{Bcube.AbstractMultiFESpace{N}}, Tuple{N}} where N","page":"Finite element spaces","title":"Bcube.get_n_fespace","text":"Number of FESpace composing the MultiFESpace \n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_ncomponents-Tuple{Bcube.AbstractFESpace}","page":"Finite element spaces","title":"Bcube.get_ncomponents","text":"Return the size S(= number of components) associated to AbstractFESpace{S}.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_ndofs-Tuple{Bcube.AbstractFESpace}","page":"Finite element spaces","title":"Bcube.get_ndofs","text":"Return the total number of dofs of the FESpace, taking into account the continuous/discontinuous type of the space. If the FESpace contains itself several FESpace (see MultiFESpace), the sum of all dofs is returned.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_ndofs-Tuple{Bcube.AbstractMultiFESpace}","page":"Finite element spaces","title":"Bcube.get_ndofs","text":"Total number of dofs contained in this MultiFESpace \n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractShape}","page":"Finite element spaces","title":"Bcube.get_shape_functions","text":"Return the shape functions associated to the AbstractFESpace.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/fespace/#Bcube.get_size-Union{Tuple{Bcube.AbstractFESpace{S}}, Tuple{S}} where S","page":"Finite element spaces","title":"Bcube.get_size","text":"Return the size S associated to AbstractFESpace{S}.\n\n\n\n\n\n","category":"method"},{"location":"manual/conventions/#Conventions","page":"Conventions","title":"Conventions","text":"","category":"section"},{"location":"manual/conventions/","page":"Conventions","title":"Conventions","text":"This documentation follows the following notation or naming conventions:","category":"page"},{"location":"manual/conventions/","page":"Conventions","title":"Conventions","text":"coordinates inside a reference frame are noted hatx haty or xi eta while coordinates in the physical frame are noted xy\nwhen talking about a mapping, F or sometimes F_rp designates the mapping from the reference element to the physical element. On the other side, F^-1 or sometimes F_pr designates the physical element to the reference element mapping.\n\"dof\" means \"degree of freedom\"","category":"page"},{"location":"manual/cellfunction/#Cell-function","page":"Cell function","title":"Cell function","text":"","category":"section"},{"location":"manual/cellfunction/","page":"Cell function","title":"Cell function","text":"As explained earlier, at least two coordinates systems exist in Bcube : the \"reference\" coordinates (ReferenceDomain) and the \"physical\" coordinates (PhysicalDomain). The evaluation of a function on a point in a cell depends on the way this point has been defined. Hence the definition of CellPoints that embed the coordinate system. Given a CellPoint (or eventually a FacePoint), an AbstractCellFunction will be evaluated and the mapping between the ReferenceDomain to the PhysicalDomain (or reciprocally) will be performed internally if necessary : if an AbstractCellFunction defined in terms of reference coordinates is applied on a CellPoint expressed in the reference coordinates system, no mapping is needed.","category":"page"},{"location":"howto/howto/#How-to...-(FAQ)","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"","category":"section"},{"location":"howto/howto/#Build-your-own-LazyOperator","page":"How to... (FAQ)","title":"Build your own LazyOperator","text":"","category":"section"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Imagine that you want some kind of function (~operator) that has a different behavior depending on the cell (or face) it is applied to. The PhysicalFunction won't do the job since it is assumed that the provided function applies the same way in all the different cells. What you want is a LazyOperator. Here is how to build a custom one.","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"For the example, let's say that you want an operator whose action is to multiply x, the evaluated point, by the index of the cell surrounding x. Start importing some Bcube material and by declaring a type corresponding to this operator:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"using Bcube\nimport Bcube: CellInfo, CellPoint, get_coord\nstruct DummyOperator <: Bcube.AbstractLazy end","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Then, specify what happens when Bcube asks for the restriction of your operator in a given cell. This is done before applying it to any point. In most case, you don't want to do anything special, so just return the operator itself:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Bcube.materialize(op::DummyOperator, ::CellInfo) = op","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Now, specify what to return when Bcube wants to apply this operator on a given point in a cell. As said earlier, we want it the return the point, multiplied by the cell index (but it could be anything you want):","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"function Bcube.materialize(\n    ::DummyOperator,\n    cPoint::CellPoint,\n)\n    x = get_coord(cPoint)\n    cInfo = Bcube.get_cellinfo(cPoint)\n    index = Bcube.cellindex(cInfo)\n    return x * index\nend","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"That's it! To see your operator in action, take a look at the related section.","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"In this short example, note that we restricted ourselves to CellPoint : the DummyOperator won't be applicable to a face. To do so, you have to specialize the materialization on a Side of a FaceInfo and on a Side of a FacePoint. Checkout the source code for TangentialProjector to see this in action. Besides, the CellPoint is parametrized by a DomainStyle, allowing to specify different behavior depending on if your operator is applied to a point in the ReferenceDomain or in the PhysicalDomain.","category":"page"},{"location":"howto/howto/#Evaluate-a-LazyOperator-on-a-specific-point","page":"How to... (FAQ)","title":"Evaluate a LazyOperator on a specific point","text":"","category":"section"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Suppose that you have built a mesh and defined a LazyOperator on this mesh and you want, for debug purpose, evaluate this operator on a point of your choice. First, let's define our example operator:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"using Bcube\nmesh = circle_mesh(10)\nop = Bcube.TangentialProjector()","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Then, let's define the point where we want to evaluate this operator. For this, we need to create a so-called CellPoint. It's structure is quite basic : it needs the coordinates, the mesh cell owning these coordinates, and if the coordinates are given in the ReferenceDomain or in the PhysicalDomain. Here, we will select the first cell of the mesh, and choose the coordinates [0.5] (recall that we are in 1D, hence this vector of one component):","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"cInfo = Bcube.CellInfo(mesh, 1)\ncPoint = Bcube.CellPoint([0.5], cInfo, Bcube.ReferenceDomain())","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Now, they are always two steps to evaluate a LazyOperator. First we need to materialize it on a cell (or a face) and then to evaluate it on a cell-point (or face-point). The materialization on a cell does not necessarily triggers something, it depends on the operator. For instance, an analytic function will not have a specific behaviour depending on the cell; however a shape function will.","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"op_cell = Bcube.materialize(op, cInfo)","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Finally, we can apply our operator on the cell point defined above and observe the result. It is also called a \"materialization\":","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"@show Bcube.materialize(op_cell, cPoint)","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Note that before and after the materialization on a cell point, the operator can be displayed as a tree with","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Bcube.show_lazy_operator(op)\nBcube.show_lazy_operator(op_cell)","category":"page"},{"location":"howto/howto/#Comparing-manually-the-benchmarks-with-main","page":"How to... (FAQ)","title":"Comparing manually the benchmarks with main","text":"","category":"section"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Let's say you want to compare the performance of your current branch (named \"target\" hereafter) with the main branch (named \"baseline\" hereafter).","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Open from Bcube.jl/ a REPL and type:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"pkg> activate --temp\npkg> add PkgBenchmark BenchmarkTools\npkg> dev .\nusing PkgBenchmark\nimport Bcube\nbenchmarkpkg(Bcube, BenchmarkConfig(; env = Dict(\"JULIA_NUM_THREADS\" => \"1\")); resultfile = joinpath(@__DIR__, \"result-target.json\"))","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"This will create a result-target.json in the current directory.","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Then checkout the main branch. Start a fresh REPL and type (almost the same):","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"pkg> activate --temp\npkg> add PkgBenchmark BenchmarkTools\npkg> dev .\nusing PkgBenchmark\nimport Bcube\nbenchmarkpkg(Bcube, BenchmarkConfig(; env = Dict(\"JULIA_NUM_THREADS\" => \"1\")); resultfile = joinpath(@__DIR__, \"result-baseline.json\"))","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"This will create a result-baseline.json in the current directory.","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"You can now \"compare\" the two files by running (watch-out for the order):","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"target = PkgBenchmark.readresults(\"result-target.json\")\nbaseline = PkgBenchmark.readresults(\"result-baseline.json\")\njudgement = judge(target, baseline)\nexport_markdown(\"judgement.md\", judgement)","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"This will create the markdown file judgement.md with the results.","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"For more details, once you've built the judgement object, you can also type the following code from https://github.com/tkf/BenchmarkCI.jl:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"open(\"detailed-judgement.md\", \"w\") do io\n    println(io, \"# Judge result\")\n    export_markdown(io, judgement)\n    println(io)\n    println(io)\n    println(io, \"---\")\n    println(io, \"# Target result\")\n    export_markdown(io, PkgBenchmark.target_result(judgement))\n    println(io)\n    println(io)\n    println(io, \"---\")\n    println(io, \"# Baseline result\")\n    export_markdown(io, PkgBenchmark.baseline_result(judgement))\n    println(io)\n    println(io)\n    println(io, \"---\")\nend","category":"page"},{"location":"howto/howto/#Run-the-benchmark-manually","page":"How to... (FAQ)","title":"Run the benchmark manually","text":"","category":"section"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Let's say you want to run the benchmarks locally (without comparing with main)","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"Open from Bcube.jl/ a REPL and type:","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"pkg> activate --temp\npkg> add PkgBenchmark\npkg> dev .\nusing PkgBenchmark\nimport Bcube\nresults = benchmarkpkg(Bcube, BenchmarkConfig(; env = Dict(\"JULIA_NUM_THREADS\" => \"1\")); resultfile = joinpath(@__DIR__, \"result.json\"))\nexport_markdown(\"results.md\", results)","category":"page"},{"location":"howto/howto/","page":"How to... (FAQ)","title":"How to... (FAQ)","text":"This will create the markdown file results.md with the results.","category":"page"},{"location":"api/mesh/gmsh_utils/#GMSH","page":"GMSH","title":"GMSH","text":"","category":"section"},{"location":"api/mesh/gmsh_utils/","page":"GMSH","title":"GMSH","text":"Modules = [Bcube]\nPages   = [\"gmsh_utils.jl\"]","category":"page"},{"location":"api/mesh/gmsh_utils/#Bcube._c2n_gmsh2cgns-Tuple{Any, Any}","page":"GMSH","title":"Bcube._c2n_gmsh2cgns","text":"Convert a cell->node connectivity with gmsh numbering convention to a cell->node connectivity with CGNs numbering convention.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube._compute_space_dim-Tuple{Bool}","page":"GMSH","title":"Bcube._compute_space_dim","text":"Deduce the number of space dimensions from the mesh : if one (or more) dimension of the bounding box is way lower than the other dimensions, the number of space dimension is decreased.\n\nCurrently, having for instance (x,z) is not supported. Only (x), or (x,y), or (x,y,z).\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube._gen_2cubes_mesh-Tuple{Any}","page":"GMSH","title":"Bcube._gen_2cubes_mesh","text":"_gen_2cubes_mesh(output)\n\nOnly for testing purpose.\n\nD–––E–––F |      |      | |      |      | A–––B–––C\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube._gen_cube_pile-Tuple{Any}","page":"GMSH","title":"Bcube._gen_cube_pile","text":"_gen_cube_pile(output)\n\nOnly for testing purpose.\n\n   G------H\n   |      |\n   |      |\n\nD–––E–––F |      |      | |      |      | A–––B–––C\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube._read_msh-Tuple{Int64, Bool}","page":"GMSH","title":"Bcube._read_msh","text":"_read_msh(spaceDim::Int, verbose::Bool)\n\nTo use this function, the gmsh file must have been opened already (see read_msh(path::String) for instance).\n\nThe number of topological dimensions is given by the highest dimension found in the file. The number of space dimensions is deduced from the axis dimensions if spaceDim = 0. If spaceDim is set to a positive number, this number is used as the number of space dimensions.\n\nImplementation\n\nGlobal use of gmsh module. Do not try to improve this function by passing an argument such as gmsh or gmsh.model : it leads to problems.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube.gen_cylinder_mesh-Tuple{Any, Any, Any}","page":"GMSH","title":"Bcube.gen_cylinder_mesh","text":"gen_cylinder_mesh(\n    output,\n    Lz,\n    nz;\n    radius = 1.0,\n    lc = 1e-1,\n    order = 1,\n    n_partitions = 0,\n    kwargs...\n)\n\nGenerate a 3D mesh of a cylindrical domain and length L and write the mesh to output.\n\nFor kwargs, see gen_line_mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube.gen_cylinder_shell_mesh-Tuple{Any, Any}","page":"GMSH","title":"Bcube.gen_cylinder_shell_mesh","text":"Implementation\n\nExtrusion is not used to enable \"random\" tri filling (whereas with extrusion we can at worse obtain regular rectangle triangle)\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube.gen_disk_mesh-Tuple{Any}","page":"GMSH","title":"Bcube.gen_disk_mesh","text":"gen_disk_mesh(\n    output;\n    radius = 1.0,\n    lc = 1e-1,\n    order = 1,\n    n_partitions = 0,\n    kwargs...\n)\n\nGenerate a 2D mesh of a disk domain and write the mesh to output.\n\nFor kwargs, see gen_line_mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube.gen_hexa_mesh-Tuple{Any, Any}","page":"GMSH","title":"Bcube.gen_hexa_mesh","text":"gen_hexa_mesh(\n    output,\n    type;\n    recombine = false,\n    n = [2, 2, 2],\n    l = [1.0, 1.0, 1.0],\n    center = [0.0, 0.0, 0.0],\n    order = 1,\n    kwargs...\n)\n\nGenerate a 3D mesh of a hexahedral domain and write the mesh to output. Use type to specify the element types: :tetra or :hexa.\n\nFor kwargs, see gen_line_mesh.\n\nImplementation\n\nNotations from https://cgns.github.io/CGNSdocscurrent/sids/conv.html We could also use extrusion.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube.gen_line_mesh-Tuple{Any}","page":"GMSH","title":"Bcube.gen_line_mesh","text":"gen_line_mesh(\n    output;\n    nx = 2,\n    lx = 1.0,\n    xc = 0.0,\n    order = 1,\n    bnd_names = (\"LEFT\", \"RIGHT\"),\n    n_partitions = 0,\n    kwargs...\n)\n\nGenerate a 1D mesh of a segment and write to \"output\".\n\nAvailable kwargs are\n\nverbose : true or false to enable gmsh verbose\nmsh_format : floating number indicating the output msh format (for instance : 2.2)\nsplit_files : if true, create one file by partition\ncreate_ghosts : if true, add a layer of ghost cells at every partition boundary\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube.gen_mesh_around_disk-Tuple{Any}","page":"GMSH","title":"Bcube.gen_mesh_around_disk","text":"gen_mesh_around_disk(\n    output;\n    r_in = 1.0,\n    r_ext = 10.0,\n    nθ = 360,\n    nr = 100,\n    nr_prog = 1.05,\n    order = 1,\n    recombine = true,\n    bnd_names = (\"Farfield\", \"Wall\"),\n    n_partitions = 0,\n    kwargs...\n)\n\nMesh the 2D domain around a disk.\n\nFor kwargs, see gen_line_mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube.gen_rectangle_mesh-Tuple{Any, Any}","page":"GMSH","title":"Bcube.gen_rectangle_mesh","text":"gen_rectangle_mesh(\n    output,\n    type;\n    transfinite = false,\n    nx = 2,\n    ny = 2,\n    lx = 1.0,\n    ly = 1.0,\n    xc = -1.0,\n    yc = -1.0,\n    order = 1,\n    bnd_names = (\"North\", \"South\", \"East\", \"West\"),\n    n_partitions = 0,\n    kwargs...\n)\n\nGenerate a 2D mesh of a rectangle domain and write the mesh to output. Use type to specify the element types: :tri or :quad.\n\nFor kwargs, see gen_line_mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube.gen_rectangle_mesh_with_tri_and_quad-Tuple{Any}","page":"GMSH","title":"Bcube.gen_rectangle_mesh_with_tri_and_quad","text":"gen_rectangle_mesh_with_tri_and_quad(\n    output;\n    nx = 2,\n    ny = 2,\n    lx = 1.0,\n    ly = 1.0,\n    xc = -1.0,\n    yc = -1.0,\n    order = 1,\n    n_partitions = 0,\n    kwargs...\n)\n\nGenerate a 2D mesh of a rectangle domain and write the mesh to output. The domain is split vertically in two parts: the upper part is composed of 'quad' cells and the lower part with 'tri'.           North          D –––- C          |   :quad |   West M₁|––––-|M₂  East          |   :tri  |          A –––- B            South\n\nFor kwargs, see gen_line_mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube.gen_sphere_mesh-Tuple{Any}","page":"GMSH","title":"Bcube.gen_sphere_mesh","text":"gen_sphere_mesh(\n    output;\n    radius = 1.0,\n    lc = 1e-1,\n    order = 1,\n    n_partitions = 0,\n    kwargs...,\n)\n\nGenerate the mesh of a sphere (surface of topological dimension 2, spatial dimension 3).\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube.gen_star_disk_mesh-Tuple{Any, Any, Any}","page":"GMSH","title":"Bcube.gen_star_disk_mesh","text":"gen_star_disk_mesh(\n    output,\n    ε,\n    m;\n    nθ = 360,\n    radius = 1.0,\n    lc = 1e-1,\n    order = 1,\n    n_partitions = 0,\n    kwargs...,\n)\n\nGenerate a 2D mesh of a star domain and write the mesh to output. The \"star\" wall is defined by r_wall = R left( 1 + varepsilon cos(m theta) right).\n\nFor kwargs, see gen_line_mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube.nodes_gmsh2cgns-Tuple{Bcube.AbstractEntityType, AbstractArray}","page":"GMSH","title":"Bcube.nodes_gmsh2cgns","text":"nodes_gmsh2cgns(entity::AbstractEntityType, nodes::AbstractArray)\n\nReorder nodes of a given entity from the Gmsh format to CGNS format\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/gmsh_utils/#Bcube.read_msh","page":"GMSH","title":"Bcube.read_msh","text":"read_msh(path::String, spaceDim::Int = 0; verbose::Bool = false)\n\nRead a .msh file designated by its path.\n\nSee read_msh() for more details.\n\n\n\n\n\n","category":"function"},{"location":"api/mesh/gmsh_utils/#Bcube.read_msh_with_cell_names","page":"GMSH","title":"Bcube.read_msh_with_cell_names","text":"read_msh_with_cell_names(path::String, spaceDim = 0; verbose = false)\n\nRead a .msh file designated by its path and also return names and tags\n\n\n\n\n\n","category":"function"},{"location":"manual/function_space/#Function-and-FE-spaces","page":"Function and FE spaces","title":"Function and FE spaces","text":"","category":"section"},{"location":"manual/function_space/#AbstractFunctionSpace","page":"Function and FE spaces","title":"AbstractFunctionSpace","text":"","category":"section"},{"location":"manual/function_space/","page":"Function and FE spaces","title":"Function and FE spaces","text":"In Bcube, a FunctionSpace is defined by a type (nodal Lagrange polynomials, modal Taylor expansion, etc) and a degree. For each implemented FunctionSpace, a list of shape functions is associated on a given Shape. For instance, one can get the shape functions associated to the Lagrange polynomials or order 3 on a Square. Note that for \"tensor\" elements such as Line, Square or Cube; the Lagrange polynomials are available at any order; being computed symbolically.","category":"page"},{"location":"manual/function_space/#AbstractFESpace","page":"Function and FE spaces","title":"AbstractFESpace","text":"","category":"section"},{"location":"manual/function_space/","page":"Function and FE spaces","title":"Function and FE spaces","text":"Then, an FESpace (more precisely SingleFESpace) is a function space associated to a numbering of the degrees of freedom. Note that the numbering may depend on the continuous or discontinuous feature of the space. Hence a SingleFESpace takes basically four input to be built : a FunctionSpace, the number of components of this space (scalar or vector), an indicator of the continuous/discontinuous characteristic, and the mesh. The dof numbering is built by combining the mesh numberings (nodes, cells, faces) and the function space. Note that the degree of the FunctionSpace can differ from the \"degree\" of the mesh elements : it is possible to build a SingleFESpace with P2 polynomials on a mesh only containing straight lines (defined by only two nodes, Bar2_t). Optionaly, a SingleFESpace can also contain the tags of the boundaries where Dirichlet condition(s) applies. A MultiFESpace is simply a set of SingleFESpace, eventually of different natures. Its befenit is that it allows to build a \"global\" numbering of all the dofs represented by this space. This is especially convenient to solve systems of equations.","category":"page"},{"location":"manual/function_space/#AbstractFEFunction","page":"Function and FE spaces","title":"AbstractFEFunction","text":"","category":"section"},{"location":"manual/function_space/","page":"Function and FE spaces","title":"Function and FE spaces","text":"With a SingleFESpace, one can build the representation of a function discretized on this space: a FEFunction. This structure stores a vector of values, one for each degree of freedom of the finite element space. To set or get the values of a FEFunction, the functions set_dof_values! and get_dof_values are available respectively. A FEFunction can be projected on another FESpace; or evaluated at some specific mesh location (a coordinates, all the nodes, all the mesh centers, etc).","category":"page"},{"location":"manual/operator/#LazyOperators","page":"LazyOperators","title":"LazyOperators","text":"","category":"section"},{"location":"manual/operator/","page":"LazyOperators","title":"LazyOperators","text":"WORK IN PROGRESS","category":"page"},{"location":"manual/integration/#Integration","page":"Integration","title":"Integration","text":"","category":"section"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"To compute an integral on a geometrical element, for instance a curved element, a variable substitution is used to compute the integral on the corresponding reference Shape. This variable substitution reads:","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"int_Omega g(x) mathrmd Omega = int_hatOmega J(x) left(g circ F right)(hatx) mathrmd hatOmega","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"where we recall that F is the reference to physical mapping and J is the determinant of the jacobian matrix of this mapping. Depending on the shape and element order, this determinant is either hard-coded or computed with ForwardDiff.","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"Now, to compute the right side, i.e the integral on the reference shape, quadrature rules are applied to hatg = g circ F:","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"int_hatOmega hatg(hatx) mathrmd hatOmega = sum_i =1^N_q omega_i hatg(hatx_i)","category":"page"},{"location":"manual/integration/","page":"Integration","title":"Integration","text":"A specific procedure is applied to compute integrals on a face of a cell (i.e a surfacic integral on a face of a volumic element).","category":"page"},{"location":"api/interpolation/shape/#Reference-shape","page":"Reference shape","title":"Reference shape","text":"","category":"section"},{"location":"api/interpolation/shape/","page":"Reference shape","title":"Reference shape","text":"Modules = [Bcube]\nPages   = [\"shape.jl\"]","category":"page"},{"location":"api/interpolation/shape/#Bcube.center-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.center","text":"center(::AbstractShape)\n\nCenter of the AbstractShape.\n\nImplementation\n\nSpecialize for better performances\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.coords-Tuple{Bcube.AbstractShape, Any}","page":"Reference shape","title":"Bcube.coords","text":"coords(shape::AbstractShape,i)\n\nReturn the coordinates of the ith shape vertices. i can be a tuple of indices, then the multiples vertices's coordinates are returned.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.coords-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.coords","text":"coords(::AbstractShape)\n\nReturn node coordinates of the shape in the reference space.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.entity-Union{Tuple{D}, Tuple{Bcube.AbstractShape, Val{D}}} where D","page":"Reference shape","title":"Bcube.entity","text":"entity(s::AbstractShape, ::Val{D}) where D\n\nReturn the geometrical Entity corresponding to the AbstractShape of a given degree D.\n\nRemark : Returned entity must be consistent with the corresponding Lagrange function space.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.face_area-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.face_area","text":"face_area(::AbstractShape)\n\nReturn the length/area of the faces of a shape.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.face_shapes-Tuple{Bcube.AbstractShape, Any}","page":"Reference shape","title":"Bcube.face_shapes","text":"face_shapes(shape::AbstractShape, i)\n\nShape of i-th shape of the input shape.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.face_shapes-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.face_shapes","text":"face_shapes(::AbstractShape)\n\nReturn a tuple of the Shape of each face of the given (cell) Shape. For instance, a Triangle has three faces, all of them are Line.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.faces2nodes-Tuple{Bcube.AbstractShape, Any}","page":"Reference shape","title":"Bcube.faces2nodes","text":"faces2nodes(shape::AbstractShape, side)\n\nReturn the index of the vertices on the iside-th face of a shape. If side is positive, the face is oriented preserving the cell normal. If side is negative, the face is returned with the opposite direction (i.e reverse node order).\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.faces2nodes-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.faces2nodes","text":"faces2nodes(::AbstractShape)\n\nReturn the index of the vertices on the faces of a shape.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.nedges-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.nedges","text":"nedges(::AbstractShape)\n\nGeneric function. Indicate how many edges a shape has.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.nfaces-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.nfaces","text":"nfaces(::AbstractShape)\n\nIndicate how many faces a shape has.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.normal-Tuple{Bcube.AbstractShape, Any}","page":"Reference shape","title":"Bcube.normal","text":"normal(shape::AbstractShape, i)\n\nReturn the outward normal of the ith face of the shape.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.normals-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.normals","text":"normals(::AbstractShape)\n\nReturn the outward normals of all the faces of the shape.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.nvertices-Tuple{Bcube.AbstractShape}","page":"Reference shape","title":"Bcube.nvertices","text":"nvertices(::AbstractShape)\n\nIndicate how many vertices a shape has.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/shape/#Bcube.shape-Tuple{Bcube.AbstractEntityType}","page":"Reference shape","title":"Bcube.shape","text":"shape(::AbstractEntityType)\n\nReturn the reference Shape corresponding to the given AbstractEntityType.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Function-spaces","page":"Function spaces","title":"Function spaces","text":"","category":"section"},{"location":"api/interpolation/function_space/#Generic","page":"Function spaces","title":"Generic","text":"","category":"section"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"Modules = [Bcube]\nPages   = [\"function_space.jl\"]","category":"page"},{"location":"api/interpolation/function_space/#Bcube.AbstractFunctionSpaceType","page":"Function spaces","title":"Bcube.AbstractFunctionSpaceType","text":"Abstract structure for the different types of function space, for instance the Lagrange function space, the Taylor function space etc.\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/function_space/#Bcube.FunctionSpace-Tuple{Bcube.AbstractFunctionSpaceType, Integer}","page":"Function spaces","title":"Bcube.FunctionSpace","text":"FunctionSpace(fstype::Symbol, degree::Integer)\nFunctionSpace(fstype::AbstractFunctionSpaceType, degree::Integer)\n\nBuild a FunctionSpace of the designated FunctionSpaceType and degree.\n\nExamples\n\njulia> FunctionSpace(:Lagrange, 2)\nFunctionSpace{Bcube.Lagrange{:Uniform}, 2}()\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.basis_functions_style-Tuple{Bcube.AbstractFunctionSpace}","page":"Function spaces","title":"Bcube.basis_functions_style","text":"basis_functions_style(fs::AbstractFunctionSpace)\n\nReturn the style (modal or nodal) corresponding to the basis functions of the 'fs'.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.coords-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.coords","text":"coords(fs::AbstractFunctionSpace,::AbstractShape)\n\nReturn node coordinates in the reference space for associated function space and shape.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.get_degree-Union{Tuple{Bcube.AbstractFunctionSpace{type, degree}}, Tuple{degree}, Tuple{type}} where {type, degree}","page":"Function spaces","title":"Bcube.get_degree","text":"get_degree(::AbstractFunctionSpace{type, degree}) where{type, degree}\n\nReturn the degree associated to the AbstractFunctionSpace.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.get_type-Union{Tuple{Bcube.AbstractFunctionSpace{type}}, Tuple{type}} where type","page":"Function spaces","title":"Bcube.get_type","text":"get_type(::AbstractFunctionSpace{type})\n\nGetter for the type of the AbstractFunctionSpace\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.idof_by_edge-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.idof_by_edge","text":"idof_by_edge(::AbstractFunctionSpace, ::AbstractShape)\n\nReturn the local indices of the dofs lying on each edge of the Shape.\n\nDofs lying on the edge vertices are excluded.\n\nThe result is a Tuple of arrays of integers. Arrays maybe be empty. See Lagrange interpolation for simple examples.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.idof_by_edge_with_bounds-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.idof_by_edge_with_bounds","text":"idof_by_edge_with_bounds(::AbstractFunctionSpace, ::AbstractShape)\n\nReturn the local indices of the dofs lying on each edge of the Shape.\n\nDofs lying on the edge vertices are included.\n\nThe result is a Tuple of arrays of integers. Arrays maybe be empty. See Lagrange interpolation for simple examples.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.idof_by_face-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.idof_by_face","text":"idof_by_face(::AbstractFunctionSpace, ::AbstractShape)\n\nReturn the local indices of the dofs lying on each face of the Shape.\n\nDofs lying on the face edges are excluded, only \"face-interior\" dofs are considered.\n\nThe result is a Tuple of arrays of integers. Arrays maybe be empty. See Lagrange interpolation for simple examples.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.idof_by_face_with_bounds-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.idof_by_face_with_bounds","text":"idof_by_face_with_bounds(::AbstractFunctionSpace, ::AbstractShape)\n\nReturn the local indices of the dofs lying on each face of the Shape.\n\nDofs lying on the face edges are included\n\nThe result is a Tuple of arrays of integers. Arrays maybe be empty. See Lagrange interpolation for simple examples.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.idof_by_vertex-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.idof_by_vertex","text":"idof_by_vertex(::AbstractFunctionSpace, ::AbstractShape)\n\nReturn the local indices of the dofs lying on each vertex of the Shape.\n\nBeware that we are talking about the Shape, not the EntityType. So 'interior' vertices of the EntityType are not taken into account for instance. See Lagrange interpolation for simple examples.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.ndofs-Tuple{Bcube.AbstractFunctionSpace, Bcube.AbstractShape}","page":"Function spaces","title":"Bcube.ndofs","text":"ndofs(fs::AbstractFunctionSpace, shape::AbstractShape)\n\nNumber of dofs associated to the given interpolation.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.shape_functions-Union{Tuple{N}, Tuple{Bcube.AbstractFunctionSpace, Val{N}, Bcube.AbstractShape, Any}} where N","page":"Function spaces","title":"Bcube.shape_functions","text":"shape_functions(::AbstractFunctionSpace, ::Val{N}, shape::AbstractShape, ξ) where N\nshape_functions(::AbstractFunctionSpace, shape::AbstractShape, ξ)\n\nReturn the list of shape functions corresponding to a FunctionSpace and a Shape. N is the size of the finite element space (default: N=1 if the argument is not provided).\n\nThe result is a vector of all the shape functions evaluated at position ξ, and not a tuple of the different shape functions. This choice is optimal for performance.\n\nNote : λ = ξ -> shape_functions(fs, shape, ξ); λ(ξ)[i] is faster than λ =shape_functions(fs, shape); λ[i](ξ)\n\nImplementation\n\nDefault version, should be overriden for each concrete FunctionSpace.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.shape_functions_vec-Union{Tuple{N}, Tuple{Bcube.AbstractFunctionSpace, Val{N}, Bcube.AbstractShape, Any}} where N","page":"Function spaces","title":"Bcube.shape_functions_vec","text":"shape_functions_vec(fs::AbstractFunctionSpace, ::Val{N}, shape::AbstractShape, ξ) where {N}\n\nReturn all the shape functions of FunctionSpace on a Shape evaluated in ξ as a vector.\n\nN is the the size (number of components) of the finite element space.\n\n\n\nshape_functions_vec(fs::AbstractFunctionSpace{T,D}, n::Val{N}, shape::AbstractShape) where {T,D, N}\n\nThe shape functions are returned as a vector of functions.\n\nImplementation\n\nThis is implementation is not always valid, but it is for Lagrange and Taylor spaces (the only two spaces available up to 20/01/23).\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.∂λξ_∂ξ","page":"Function spaces","title":"Bcube.∂λξ_∂ξ","text":"∂λξ_∂ξ(::AbstractFunctionSpace, ::Val{N}, shape::AbstractShape) where N\n\nGradient, with respect to the reference coordinate system, of shape functions for any function space. The result is an array whose elements are the gradient of each shape functions. N is the size of the finite element space.\n\nImplementation\n\nDefault version using automatic differentiation. Specialize to increase performance.\n\n\n\n\n\n","category":"function"},{"location":"api/interpolation/function_space/#Lagrange","page":"Function spaces","title":"Lagrange","text":"","category":"section"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"Modules = [Bcube]\nPages   = [\"lagrange.jl\"]","category":"page"},{"location":"api/interpolation/function_space/#Bcube._scalar_shape_functions-Tuple{FunctionSpace{<:Bcube.Lagrange, 1}, Bcube.Tetra, Any}","page":"Function spaces","title":"Bcube._scalar_shape_functions","text":"shape_functions(::FunctionSpace{<:Lagrange, 1}, ::Tetra, ξ)\n\nShape functions for Tetra Lagrange element of degree 1 in a 3D space.\n\nhatlambda_1(xi eta zeta) = (1 - xi - eta - zeta) hspace1cm\nhatlambda_2(xi eta zeta) = xi                        hspace1cm\nhatlambda_3(xi eta zeta) = eta                       hspace1cm\nhatlambda_5(xi eta zeta) = zeta                      hspace1cm\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.shape_functions-Union{Tuple{N}, Tuple{D}, Tuple{FunctionSpace{<:Bcube.Lagrange, D}, Val{N}, Bcube.AbstractShape, Any}} where {D, N}","page":"Function spaces","title":"Bcube.shape_functions","text":"shape_functions(::FunctionSpace{<:Lagrange}, :: Val{N}, ::AbstractShape, ξ) where {N}\n\nImplementation\n\nFor N > 1, the default version consists in \"replicating\" the shape functions. If shape_functions returns the vector [λ₁; λ₂; λ₃], and if the FESpace is of size 2, then this default behaviour consists in returning the matrix [λ₁ 0; λ₂ 0; λ₃ 0; 0 λ₁; 0 λ₂; 0 λ₃].\n\nTriangle\n\nOrder 1\n\nhatlambda_1(xi eta) = 1 - xi - eta hspace1cm\nhatlambda_2(xi eta) = xi                hspace1cm\nhatlambda_3(xi eta) = eta\n\nOrder 2\n\nbeginaligned\n     hatlambda_1(xi eta) = (1 - xi - eta)(1 - 2 xi - 2 eta) \n     hatlambda_2(xi eta) = xi (2xi - 1) \n     hatlambda_3(xi eta) = eta (2eta - 1) \n     hatlambda_12(xi eta) = 4 xi (1 - xi - eta) \n     hatlambda_23(xi eta) = 4 xi eta \n     hatlambda_31(xi eta) = 4 eta (1 - xi - eta)\nendaligned\n\nPrism\n\nOrder 1\n\nbeginaligned\n    hatlambda_1(xi eta zeta) = (1 - xi - eta)(1 - zeta)2 hspace1cm\n    hatlambda_2(xi eta zeta) = xi (1 - zeta)2          hspace1cm\n    hatlambda_3(xi eta zeta) = eta (1 - zeta)2  hspace1cm\n    hatlambda_5(xi eta zeta) = (1 - xi - eta)(1 + zeta)2 hspace1cm\n    hatlambda_6(xi eta zeta) = xi (1 + zeta)2          hspace1cm\n    hatlambda_7(xi eta zeta) = eta (1 + zeta)2  hspace1cm\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.shape_functions_symbolic-Union{Tuple{D}, Tuple{FunctionSpace{<:Bcube.Lagrange, D}, Bcube.Line, Any}} where D","page":"Function spaces","title":"Bcube.shape_functions_symbolic","text":"shape_functions_symbolic(fs::FunctionSpace{<:Lagrange, D}, ::Shape, ξ) where {D, Shape<:Line}\n∂λξ_∂ξ_symbolic(fs::FunctionSpace{<:Lagrange, D}, ::Shape, ξ) where {D, Shape<:Line}\n\nImplementation\n\nBased on Symbolic.jl. First tests show that this version is slower than the implementation based on meta when D is greater. Further investigations are needed to understand this behavior.\n\nshape_functions_symbolic uses a \"generated\" function named _shape_functions_symbolic. The core of the generated function is an Expression that is created by __shape_functions_symbolic. This latter function uses the Symbolics package and the lagrange polynomials (defined in _lagrange_poly).\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.∂λξ_∂ξ-Tuple{FunctionSpace{<:Bcube.Lagrange, 0}, Val{1}, Bcube.Line, Number}","page":"Function spaces","title":"Bcube.∂λξ_∂ξ","text":"∂λξ_∂ξ(::FunctionSpace{<:Lagrange}, ::Val{1}, ::AbstractShape, ξ)\n\nTriangle\n\nOrder 0\n\nnabla hatlambda(xi eta) =\nbeginpmatrix\n    0  0\nendpmatrix\n\nOrder 1\n\nbeginaligned\n     nabla hatlambda_1(xi eta) =\n        beginpmatrix\n            -1  -1\n        endpmatrix \n     nabla hatlambda_2(xi eta) =\n        beginpmatrix\n            1  0\n        endpmatrix \n     nabla hatlambda_3(xi eta) =\n        beginpmatrix\n            0  1\n        endpmatrix \nendaligned\n\nOrder 2\n\nbeginaligned\n     nabla hatlambda_1(xi eta) =\n        beginpmatrix\n            -3 + 4 (xi + eta)  -3 + 4 (xi + eta)\n        endpmatrix \n     nabla hatlambda_2(xi eta) =\n        beginpmatrix\n            -1 + 4 xi  0\n        endpmatrix \n     nabla hatlambda_3(xi eta) =\n        beginpmatrix\n            0  -1 + 4 eta\n        endpmatrix \n     nabla hatlambda_12(xi eta) =\n        4 beginpmatrix\n            1 - 2 xi - eta  - xi\n        endpmatrix \n     nabla hatlambda_23(xi eta) =\n        4 beginpmatrix\n            eta  xi\n        endpmatrix \n     nabla hatlambda_31(xi eta) =\n        4 beginpmatrix\n            - eta  1 - 2 eta - xi\n        endpmatrix \nendaligned\n\nSquare\n\nOrder 0\n\nnabla hatlambda(xi eta) =\nbeginpmatrix\n    0  0\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Taylor","page":"Function spaces","title":"Taylor","text":"","category":"section"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"The Taylor function space corresponds to a function space where functions are approximated by a Taylor series expansion of order n in each cell:","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"    forall x in Omega_ig(x) = g(x_0) + (x - x_0) g(x_0) + o(x)","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"where x_0 is the cell center.","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"Note that a Taylor-P0 is strictly equivalent to a 1st-order Finite Volume discretization (beware that \"order\" can have different meaning depending on whether one refers to the order of the function space basis or the order of the discretization method).","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"Recall that any function space implies that any function g is interpolated by g(x) = sum g_i lambda_i(x) where lambda_i are the shape functions. For a Taylor expansion, the definition of lambda_i is not unique. For instance for the Taylor expansion of order 1 on a 1D line above, we may be tempted to set lambda_1(x) = 1 and lambda_2(x) = (x - x_0). If you do so, what are the corresponding shape functions in the reference element, the hatlambda_i? We immediately recover hatlambda_1(hatx)  = 1. For hatlambda_2:","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"    hatlambda_2(hatx) = (lambda circ F)(hatx) = (x rightarrow x - x_0) circ (hatx rightarrow fracx_r - x_l2 hatx + fracx_r + x_l2) = fracx_r - x_l2 hatx","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"So if you set lambda_2(x) = (x - x_0) then hatlambda_2 depends on the element length (Delta x = x_r-x_l), which is pointless. So lambda_2 must be proportional to the element length to obtain a universal definition for hatlambda_2. For instance, we may choose lambda_2(x) = (x - x_0)  Delta x, leading to hatlambda_2(hatx) = hatx  2. But we could have chosen an other element length multiple.","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"Don't forget that choosing lambda_2(x) = (x - x_0)  Delta x leads to g(x) = g(x_0) + fracx - x_0Delta x g(x_0) Δx hence g_2 = g(x_0) Δx in the interpolation.","category":"page"},{"location":"api/interpolation/function_space/","page":"Function spaces","title":"Function spaces","text":"Modules = [Bcube]\nPages   = [\"taylor.jl\"]","category":"page"},{"location":"api/interpolation/function_space/#Bcube.shape_functions-Union{Tuple{N}, Tuple{FunctionSpace{<:Bcube.Taylor}, Val{N}, Bcube.AbstractShape, Any}} where N","page":"Function spaces","title":"Bcube.shape_functions","text":"shape_functions(::FunctionSpace{<:Taylor}, ::AbstractShape, ξ)\n\nImplementation\n\nFor N > 1, the default version consists in \"replicating\" the shape functions. If shape_functions returns the vector [λ₁; λ₂; λ₃], and if the FESpace is of size 2, then this default behaviour consists in returning the matrix [λ₁ 0; λ₂ 0; λ₃ 0; 0 λ₁; 0 λ₂; 0 λ₃].\n\nAny shape, order 0\n\nhatlambda(xi) = 1\n\nLine\n\nOrder 1\n\nhatlambda_1(xi) = 1 hspace1cm hatlambda_1(xi) = fracxi2\n\nSquare\n\nOrder 1\n\nbeginaligned\n     hatlambda_1(xi eta) = 0 \n     hatlambda_2(xi eta) = fracxi2 \n     hatlambda_3(xi eta) = fraceta2\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/function_space/#Bcube.∂λξ_∂ξ-Tuple{FunctionSpace{<:Bcube.Taylor, 0}, Val{1}, Bcube.Line, Any}","page":"Function spaces","title":"Bcube.∂λξ_∂ξ","text":"∂λξ_∂ξ(::FunctionSpace{<:Taylor}, ::Val{1}, ::AbstractShape, ξ)\n\nLine\n\nOrder 0\n\nnabla hatlambda(xi) = 0\n\nOrder 1\n\nnabla hatlambda_1(xi) = 0 hspace1cm nabla hatlambda_1(xi) = frac12\n\nSquare\n\nOrder 0\n\nhatlambda_1(xi eta) = beginpmatrix 0  0 endpmatrix\n\nOrder 1\n\nbeginaligned\n     nabla hatlambda_1(xi eta) = beginpmatrix 0  0 endpmatrix \n     nabla hatlambda_2(xi eta) = beginpmatrix frac12  0 endpmatrix \n     nabla hatlambda_3(xi eta) = beginpmatrix 0  frac12 endpmatrix\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"api/output/vtk/#VTK","page":"VTK","title":"VTK","text":"","category":"section"},{"location":"api/output/vtk/","page":"VTK","title":"VTK","text":"Modules = [Bcube]\nPages   = [\"vtk.jl\"]","category":"page"},{"location":"api/output/vtk/#Bcube._build_fname_with_iterations-Tuple{String, Integer}","page":"VTK","title":"Bcube._build_fname_with_iterations","text":"Append the number of iteration (if positive) to the basename\n\n\n\n\n\n","category":"method"},{"location":"api/output/vtk/#Bcube._point_index_from_IJK-Tuple{Val{:VTK_LAGRANGE_QUADRILATERAL}, Any, Any, Any}","page":"VTK","title":"Bcube._point_index_from_IJK","text":"Return the node numbering of the node designated by its position in the x and y direction.\n\nSee https://www.kitware.com/modeling-arbitrary-order-lagrange-finite-elements-in-the-visualization-toolkit/.\n\n\n\n\n\n","category":"method"},{"location":"api/output/vtk/#Bcube._vtk_coords_from_lagrange-Tuple{Union{Bcube.Cube, Bcube.Square}, Any}","page":"VTK","title":"Bcube._vtk_coords_from_lagrange","text":"Coordinates of the nodes in the VTK cell, ordered as expected by VTK.\n\n\n\n\n\n","category":"method"},{"location":"api/output/vtk/#Bcube._vtk_lagrange_node_index_bcube_to_vtk-Tuple{Union{Bcube.Cube, Bcube.Square}, Any}","page":"VTK","title":"Bcube._vtk_lagrange_node_index_bcube_to_vtk","text":"Bcube node numbering -> VTK node numbering (in a cell)\n\n\n\n\n\n","category":"method"},{"location":"api/output/vtk/#Bcube._vtk_lagrange_node_index_vtk_to_bcube-Tuple{Union{Bcube.Cube, Bcube.Square}, Any}","page":"VTK","title":"Bcube._vtk_lagrange_node_index_vtk_to_bcube","text":"VTK node numbering (in a cell) -> Bcube node numbering\n\n\n\n\n\n","category":"method"},{"location":"api/output/vtk/#Bcube.vtk_entity-Tuple{Bcube.AbstractEntityType}","page":"VTK","title":"Bcube.vtk_entity","text":"vtk_entity(t::AbstractEntityType)\n\nConvert an AbstractEntityType into a VTKCellType. To find the correspondance, browse the WriteVTK package AND check the Doxygen (for numbering) : https://vtk.org/doc/nightly/html/classvtkTriQuadraticHexahedron.html\n\n\n\n\n\n","category":"method"},{"location":"api/output/vtk/#Bcube.write_vtk-Union{Tuple{L}, Tuple{V}, Tuple{spaceDim}, Tuple{topoDim}, Tuple{String, Int64, Real, Bcube.AbstractMesh{topoDim, spaceDim}, Dict{String, Tuple{V, L}}}} where {topoDim, spaceDim, V, L<:VTKBase.AbstractFieldData}","page":"VTK","title":"Bcube.write_vtk","text":"write_vtk(basename::String, it::Int,time::Real, mesh::AbstractMesh{topoDim,spaceDim}, vars::Dict{String,Tuple{V,L}}; append=false) where{topoDim,spaceDim,V,L<:WriteVTK.AbstractFieldData}\n\nWrite a set of variables on the mesh nodes or cell centers to a VTK file.\n\nExample\n\nmesh = basic_mesh()\nu = rand(ncells(mesh))\nv = rand(nnodes(mesh))\ndict_vars = Dict( \"u\" => (u, VTKCellData()),  \"v\" => (v, VTKPointData()) )\nwrite_vtk(\"output\", 0, 0.0, mesh, dict_vars)\n\n\n\n\n\n","category":"method"},{"location":"api/output/vtk/#Bcube.write_vtk-Union{Tuple{spaceDim}, Tuple{topoDim}, Tuple{String, Bcube.AbstractMesh{topoDim, spaceDim}}} where {topoDim, spaceDim}","page":"VTK","title":"Bcube.write_vtk","text":"write_vtk(basename::String, mesh::AbstractMesh{topoDim,spaceDim}) where{topoDim,spaceDim}\n\nWrite the mesh to a VTK file.\n\nExample\n\nwrite_vtk(\"output\", basic_mesh())\n\n\n\n\n\n","category":"method"},{"location":"api/output/vtk/#Bcube.write_vtk_discontinuous-Union{Tuple{L}, Tuple{V}, Tuple{spaceDim}, Tuple{topoDim}, Tuple{String, Int64, Real, Bcube.AbstractMesh{topoDim, spaceDim}, Dict{String, Tuple{V, L}}, Int64}} where {topoDim, spaceDim, V, L<:VTKBase.AbstractFieldData}","page":"VTK","title":"Bcube.write_vtk_discontinuous","text":"VTK writer for a set of discontinuous functions. vars is a dictionnary of variable name => (values, values_location)\n\nwhere values is an array of numbers.\n\n\n\n\n\n","category":"method"},{"location":"api/output/vtk/#Bcube.write_vtk_lagrange-Union{Tuple{F}, Tuple{String, Dict{String, F}, Bcube.AbstractMesh, Bcube.AbstractFESpace}, Tuple{String, Dict{String, F}, Bcube.AbstractMesh, Bcube.AbstractFESpace, Integer}, Tuple{String, Dict{String, F}, Bcube.AbstractMesh, Bcube.AbstractFESpace, Integer, Real}} where F<:Bcube.LazyOperators.AbstractLazy","page":"VTK","title":"Bcube.write_vtk_lagrange","text":"write_vtk_lagrange(\n    basename::String,\n    vars::Dict{String, F},\n    mesh::AbstractMesh,\n    U_export::AbstractFESpace,\n    it::Integer = -1,\n    time::Real = 0.0;\n    collection_append = false,\n    vtk_kwargs...,\n) where {F <: AbstractLazy}\n\nWrite the provided FEFunction on the mesh with the precision of the Lagrange FESpace provided.\n\nvars is a dictionnary of variable name => FEFunction to write.\n\nExample\n\nmesh = rectangle_mesh(6, 7; xmin = -1, xmax = 1.0, ymin = -1, ymax = 1.0)\nu = FEFunction(TrialFESpace(FunctionSpace(:Lagrange, 4), mesh))\nprojection_l2!(u, PhysicalFunction(x -> x[1]^2 + x[2]^2), mesh)\n\nvars = Dict(\"u\" => u, \"grad_u\" => ∇(u))\n\nfor degree_export in 1:5\n    U_export = TrialFESpace(FunctionSpace(:Lagrange, degree_export), mesh)\n    Bcube.write_vtk_lagrange(\n        joinpath(@__DIR__, \"output\"),\n        vars,\n        mesh,\n        U_export,\n    )\nend\n\nDev notes\n\nin order to write an ASCII file, you must pass both ascii = true and append = false\ncollection_append is not named append to enable passing correct kwargs to vtk_grid\nremove (once fully validated) : write_vtk_discontinuous\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Mesh","page":"Mesh","title":"Mesh","text":"","category":"section"},{"location":"api/mesh/mesh/#Entity","page":"Mesh","title":"Entity","text":"","category":"section"},{"location":"api/mesh/mesh/","page":"Mesh","title":"Mesh","text":"Modules = [Bcube]\nPages   = [\"entity.jl\"]","category":"page"},{"location":"api/mesh/mesh/#Bcube.Node","page":"Mesh","title":"Bcube.Node","text":"A Node is a point in space of dimension dim.\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.topology_style-Union{Tuple{T}, Tuple{spaceDim}, Tuple{topoDim}, Tuple{Bcube.AbstractEntityType{topoDim}, Node{spaceDim, T}}} where {topoDim, spaceDim, T}","page":"Mesh","title":"Bcube.topology_style","text":"topology_style(::AbstractEntityType{topoDim}, ::Node{spaceDim, T}) where {topoDim, spaceDim, T}\ntopology_style(::AbstractEntityType{topoDim}, ::AbstractArray{Node{spaceDim, T}, N}) where {spaceDim, T, N, topoDim}\n\nIndicate the TopologyStyle of an entity of topology topoDim living in space of dimension spaceDim.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Connectivity","page":"Mesh","title":"Connectivity","text":"","category":"section"},{"location":"api/mesh/mesh/","page":"Mesh","title":"Mesh","text":"Modules = [Bcube]\nPages   = [\"connectivity.jl\"]","category":"page"},{"location":"api/mesh/mesh/#Bcube.AbstractConnectivity","page":"Mesh","title":"Bcube.AbstractConnectivity","text":"AbstractConnectivity{T}\n\nSupertype for connectivity with indices of type T.\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.Connectivity","page":"Mesh","title":"Bcube.Connectivity","text":"Connectivity{T}\n\nType for connectivity with elements of type T.\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.inverse_connectivity-Union{Tuple{Bcube.Connectivity{T}}, Tuple{T}} where T","page":"Mesh","title":"Bcube.inverse_connectivity","text":"inverse_connectivity(c::Connectivity{T}) where {T}\n\nReturns the \"inverse\" of the connectivity 'c' and the corresponding 'keys'. 'keys' are provided because indices in 'c' could be sparse in the general case.\n\nExample\n\nmesh = basic_mesh()\nc2n = connectivities_indices(mesh,:c2n)\nn2c, keys = inverse_connectivity(c2n)\n\nHere, 'n2c' is the node->cell graph of connectivity and, 'n2c[i]' contains the indices of the cells connected to the node of index 'keys[i]'. If 'c2n' is dense, 'keys' is not necessary (because keys[i]==i, ∀i)\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Mesh-2","page":"Mesh","title":"Mesh","text":"","category":"section"},{"location":"api/mesh/mesh/","page":"Mesh","title":"Mesh","text":"Modules = [Bcube]\nPages   = [\"mesh.jl\"]","category":"page"},{"location":"api/mesh/mesh/#Bcube.AbstractMesh","page":"Mesh","title":"Bcube.AbstractMesh","text":"Implementation\n\nAll subtypes should implement the following functions:\n\nBase.parent(AbstractMesh) (default should be Base.parent(m::MyMesh) = m)\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.Mesh","page":"Mesh","title":"Bcube.Mesh","text":"bc_names : <boundary tag> => <boundary names> bc_nodes : <boundary tag> => <boundary nodes tags> bc_faces : <boundary tag> => <boundary faces tags>\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.connectivity_cell2cell_by_faces-Tuple{Any}","page":"Mesh","title":"Bcube.connectivity_cell2cell_by_faces","text":"connectivity_cell2cell_by_faces(mesh)\n\nBuild the cell -> cell connectivity by looking at neighbors by faces.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.connectivity_cell2cell_by_nodes-Tuple{Any}","page":"Mesh","title":"Bcube.connectivity_cell2cell_by_nodes","text":"connectivity_cell2cell_by_nodes(mesh)\n\nBuild the cell -> cell connectivity by looking at neighbors by nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.inner_faces-Tuple{Any}","page":"Mesh","title":"Bcube.inner_faces","text":"inner_faces(mesh)\n\nReturn the indices of the inner faces.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.oriented_cell_side-Tuple{Bcube.Mesh, Int64, Int64}","page":"Mesh","title":"Bcube.oriented_cell_side","text":"oriented_cell_side(mesh::Mesh,icell::Int,iface::Int)\n\nReturn the side number to which the face 'iface' belongs in the cell 'icell' of the mesh. A negative side number is returned if the face is inverted. Returns '0' if the face does not belongs the cell.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.outer_faces-Tuple{Any}","page":"Mesh","title":"Bcube.outer_faces","text":"outer_faces(mesh)\n\nReturn the indices of the outer (=boundary) faces.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Domain","page":"Mesh","title":"Domain","text":"","category":"section"},{"location":"api/mesh/mesh/","page":"Mesh","title":"Mesh","text":"Modules = [Bcube]\nPages   = [\"domain.jl\"]","category":"page"},{"location":"api/mesh/mesh/#Bcube.AbstractDomain","page":"Mesh","title":"Bcube.AbstractDomain","text":"An AbstractDomain designates any set of entities from a mesh. For instance a set of cells, a set of faces etc.\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.BoundaryFaceDomain-Tuple{Bcube.Mesh, Tuple{String, Vararg{String}}}","page":"Mesh","title":"Bcube.BoundaryFaceDomain","text":"BoundaryFaceDomain(mesh)\nBoundaryFaceDomain(mesh, label::String)\nBoundaryFaceDomain(mesh, labels::Tuple{String, Vararg{String}})\n\nBuild a BoundaryFaceDomain corresponding to the boundaries designated by one or several labels (=names).\n\nIf no label is provided, all the BoundaryFaceDomain corresponds to all the boundary faces.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.CellDomain","page":"Mesh","title":"Bcube.CellDomain","text":"A CellDomain is a representation of the cells of a mesh. It's primary purpose is to represent a domain to integrate over.\n\nExamples\n\njulia> mesh = rectangle_mesh(10, 10)\njulia> Ω_all = CellDomain(mesh)\njulia> selectedCells = [1,3,5,6]\njulia> Ω_selected = CellDomain(mesh, selectedCells)\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.CellInfo-Tuple{Any, Any, Any}","page":"Mesh","title":"Bcube.CellInfo","text":"Legacy constructor for CellInfo : no information about node indices \n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.CellInfo-Tuple{Any, Any}","page":"Mesh","title":"Bcube.CellInfo","text":"CellInfo(mesh, icell)\n\nDEBUG constructor for icell-th cell of mesh. For performance issues, don't use this version in production.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.FaceInfo","page":"Mesh","title":"Bcube.FaceInfo","text":"FaceInfo{CN<:CellInfo,CP<:CellInfo,FT,FN,F2N,I}\n\nType describing a face as the common side of two adjacent cells. CellInfo of cells from both sides is stored with the local side index of the face relative to each adjacent cell.\n\niface is the mesh-face-index (and not the domain-face-index).\n\nRemark:\n\nFor boundary face with no periodic condition, positive cell side info\n\nare duplicate from the negative ones.\n\nFor performance reason (type stability), nodes and type of the face\n\nis stored explicitely in FaceInfo even if it could have been computed by collecting info from the side of the negative or positive cells.\n\n\n\n\n\n","category":"type"},{"location":"api/mesh/mesh/#Bcube.FaceInfo-Tuple{Bcube.CellInfo, Bcube.CellInfo, Any, Any, AbstractVector, Any}","page":"Mesh","title":"Bcube.FaceInfo","text":"FaceInfo constructor\n\nCell sides are computed automatically.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.FaceInfo-Tuple{Bcube.Mesh, Int64}","page":"Mesh","title":"Bcube.FaceInfo","text":"DEBUG FaceInfo constructor for kface-th cell of mesh. For performance issues, don't use this version in production.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube._compute_periodicity","page":"Mesh","title":"Bcube._compute_periodicity","text":"Find periodic face connectivities sush as :\n(faces of `labels2`) = A(faces of `labels1`)\n\n\n\n\n\n","category":"function"},{"location":"api/mesh/mesh/#Bcube.get_face_normals-Tuple{Bcube.AbstractFaceDomain}","page":"Mesh","title":"Bcube.get_face_normals","text":"Return a LazyOperator representing a face normal \n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh/#Bcube.opposite_side-Tuple{Bcube.FaceInfo}","page":"Mesh","title":"Bcube.opposite_side","text":"Return the opposite side of the FaceInfo : cellside \"n\" because cellside \"p\"\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Mesh-generator","page":"Mesh generator","title":"Mesh generator","text":"","category":"section"},{"location":"api/mesh/mesh_generator/","page":"Mesh generator","title":"Mesh generator","text":"Modules = [Bcube]\nPages   = [\"mesh_generator.jl\"]","category":"page"},{"location":"api/mesh/mesh_generator/#Bcube._duplicate_mesh-Tuple{Bcube.AbstractMesh}","page":"Mesh generator","title":"Bcube._duplicate_mesh","text":"_duplicate_mesh(mesh::AbstractMesh)\n\nMake an exact copy of the input mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.basic_mesh-Tuple{}","page":"Mesh generator","title":"Bcube.basic_mesh","text":"basic_mesh()\n\nGenerate a toy mesh of two quads and one triangle.\n\nv1       v2       v3       v4  +–-e1–>+–-e5–>+–-e8–>+  ^        |        |  c3  / e4   c1   e2   c2  e6   e9  |        |        |  /  +<–e3–-+<–e7–-+/  v5      v6        v7\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.circle_mesh-Tuple{Any}","page":"Mesh generator","title":"Bcube.circle_mesh","text":"circle_mesh(n; r = 1, order = 1)\n\nMesh a circle (in 2D) with n nodes on the circumference.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.line_mesh-Tuple{Any}","page":"Mesh generator","title":"Bcube.line_mesh","text":"line_mesh(n; xmin = 0., xmax = 1., order = 1, names = (\"xmin\", \"xmax\"))\n\nGenerate a mesh of a line of n vertices.\n\nExample\n\njulia> mesh = line_mesh(5)\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.ncube_mesh-Tuple{Vector{Int64}}","page":"Mesh generator","title":"Bcube.ncube_mesh","text":"ncube_mesh(n::Vector{Int}; order = 1)\n\nGenerate either a line mesh, a rectangle mesh, a cubic mesh... depending on the dimension of n.\n\nArgument\n\nn number of vertices in each spatial directions\n\nExample\n\nmesh_of_a_line = ncube_mesh([10])\nmesh_of_a_square = ncube_mesh([4, 5])\nmesh_of_a_hexa = ncube_mesh([4, 5, 6])\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.one_cell_mesh-Tuple{Symbol}","page":"Mesh generator","title":"Bcube.one_cell_mesh","text":"one_cell_mesh(type::Symbol, order = 1)\n\nGenerate a mesh of one cell. type can be :line, :quad, :tri or :hexa.\n\nThe argument order refers to the geometry order. It has the same effect as the -order parameter in gmsh.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.rectangle_mesh-Tuple{Any, Any}","page":"Mesh generator","title":"Bcube.rectangle_mesh","text":"rectangle_mesh(\n    nx,\n    ny;\n    type = :quad,\n    xmin = 0.0,\n    xmax = 1.0,\n    ymin = 0.0,\n    ymax = 1.0,\n    order = 1,\n    bnd_names = (\"xmin\", \"xmax\", \"ymin\", \"ymax\"),\n)\n\nGenerate a 2D mesh of a rectangle with nx and ny vertices in the x and y directions respectively.\n\nExample\n\njulia> mesh = rectangle_mesh(5, 4)\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.scale-Tuple{Bcube.AbstractMesh, Any}","page":"Mesh generator","title":"Bcube.scale","text":"scale(mesh, factor)\n\nScale the input mesh nodes coordinates by a given factor and return the resulted mesh. The factor can be a number or a vector.\n\nUsefull for debugging.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.transform-Tuple{Bcube.AbstractMesh, Any}","page":"Mesh generator","title":"Bcube.transform","text":"transform(mesh::AbstractMesh, fun)\n\nTransform the input mesh nodes coordinates by applying the given fun function and return the resulted mesh.\n\nUsefull for debugging.\n\n\n\n\n\n","category":"method"},{"location":"api/mesh/mesh_generator/#Bcube.translate-Tuple{Bcube.AbstractMesh, AbstractVector}","page":"Mesh generator","title":"Bcube.translate","text":"translate(mesh::AbstractMesh, t::AbstractVector)\n\nTranslate the input mesh with vector t.\n\nUsefull for debugging.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Integration","page":"Integration","title":"Integration","text":"","category":"section"},{"location":"api/integration/integration/#Measure","page":"Integration","title":"Measure","text":"","category":"section"},{"location":"api/integration/integration/","page":"Integration","title":"Integration","text":"Modules = [Bcube]\nPages   = [\"measure.jl\"]","category":"page"},{"location":"api/integration/integration/#Bcube.Measure","page":"Integration","title":"Bcube.Measure","text":"A Measure is geometrical domain of integration associated to a way to integrate on it (i.e a quadrature rule).\n\nQ is the quadrature type used to integrate expressions using this measure.\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.Measure-Tuple{AbstractDomain, Integer}","page":"Integration","title":"Bcube.Measure","text":"Measure(domain::AbstractDomain, degree::Integer)\nMeasure(domain::AbstractDomain, ::Val{degree}) where {degree}\n\nBuild a Measure on the designated AbstractDomain with a default quadrature of degree degree.\n\nArguments\n\ndomain::AbstractDomain : the domain to integrate over\ndegree : the degree of the quadrature rule (Legendre quadrature type by default)\n\nExamples\n\njulia> mesh = line_mesh(10)\njulia> Ω = CellDomain(mesh)\njulia> dΩ = Measure(Ω, 2)\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_face_normals-Tuple{Measure{<:Bcube.AbstractFaceDomain}}","page":"Integration","title":"Bcube.get_face_normals","text":"Return a LazyOperator representing a face normal \n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Integration-methods","page":"Integration","title":"Integration methods","text":"","category":"section"},{"location":"api/integration/integration/","page":"Integration","title":"Integration","text":"Modules = [Bcube]\nPages   = [\"integration.jl\"]","category":"page"},{"location":"api/integration/integration/#Base.:*-Tuple{Number, Bcube.Integration}","page":"Integration","title":"Base.:*","text":"*(a::Number, b::Integration)\n*(a::Integration, b::Number)\n\nMultiplication of an Integration is based on a rewriting rule following the linearity rules of integration : k*∫(f(x))dx => ∫(k*f(x))dx\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Base.:--Tuple{Bcube.Integrand}","page":"Integration","title":"Base.:-","text":"-(a::Integrand)\n\nSoustraction on an Integrand is treated as a multiplication by \"(-1)\" : -a ≡ ((-1)*a)\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Base.:--Tuple{Bcube.Integration}","page":"Integration","title":"Base.:-","text":"-(a::Integration)\n\nSoustraction on an Integration is treated as a multiplication by \"(-1)\" : -a ≡ ((-1)*a)\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.apply_quadrature-Tuple{Any, Bcube.AbstractShape, Bcube.AbstractQuadrature, Bcube.MapComputeQuadratureStyle}","page":"Integration","title":"Bcube.apply_quadrature","text":"apply_quadrature(g_ref, shape::AbstractShape, quadrature::AbstractQuadrature, ::T) where{N,T<:AbstractComputeQuadratureStyle}\n\nApply quadrature rule to function g_ref expressed on reference shape shape. Computation is optimized according to the given concrete type T<:AbstractComputeQuadratureStyle.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.apply_quadrature2-Tuple{Any, Bcube.AbstractShape, Bcube.AbstractQuadrature, Bcube.MapComputeQuadratureStyle}","page":"Integration","title":"Bcube.apply_quadrature2","text":"apply_quadrature2(g_ref, shape::AbstractShape, quadrature::AbstractQuadrature, ::MapComputeQuadratureStyle) where{N}\n\nAlternative version of apply_quadrature thats seems to be more efficient for face integration (this observation is not really understood)\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.getcache_∫-Tuple{Bcube.AbstractEntityType, Any, Bcube.AbstractQuadrature}","page":"Integration","title":"Bcube.getcache_∫","text":"getcache_∫(ctype::AbstractEntityType, cnodes, quadrature::AbstractQuadrature)\n\nReturn the data cache for function ∫\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.integrate-Tuple{Any, Bcube.AbstractEntityType, Any, Bcube.AbstractQuadrature}","page":"Integration","title":"Bcube.integrate","text":"integrate(g, ctype::AbstractEntityType, cnodes, quadrature::AbstractQuadrature)\n\nIntegrate function g expressed in local element. Depending on the cell type and the space dimension, a volumic or a 'surfacic' integration is performed.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.integrate-Tuple{Any, Int64, Bcube.AbstractEntityType, Any, Bcube.AbstractQuadrature}","page":"Integration","title":"Bcube.integrate","text":"integrate(g, iside::Int, ctype::AbstractEntityType, cnodes, quadrature::AbstractQuadrature)\n\nIntegrate function g on the iside-th side of the cell defined by its nodes cnodes and its type ctype. Function g(x) is expressed in the local element.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.integrate_face_ref-Tuple{Any, Bcube.FaceInfo, Bcube.AbstractQuadrature}","page":"Integration","title":"Bcube.integrate_face_ref","text":"Integration on a surface in a volume. We consider that we integrate on the negative side of the face.\n\nWARNING : I need this now, but I am not satisfied. We need to rethink the whole integration API\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.integrate_n-Tuple{Any, Int64, Bcube.AbstractEntityType, Any, Bcube.AbstractQuadrature}","page":"Integration","title":"Bcube.integrate_n","text":"integrate_n(g, iside::Int, ctype::AbstractEntityType, cnodes, quadrature::AbstractQuadrature)\n\nPerform an integration over the isideth face of an element (defined by cnodes and ctype).\n\nHere g is expressed in the cell-local element : n is the normal vector in the local element, and x is in the local element as well.\n\nDev notes:\n\nThis method is DEPRECATED : never used, except in the unit tests...\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.integrate_n_ref-Tuple{Any, Int64, Bcube.AbstractEntityType, Any, Bcube.AbstractQuadrature}","page":"Integration","title":"Bcube.integrate_n_ref","text":"integrate_n_ref(g_ref, iside::Int, ctype::AbstractEntityType, cnodes, quadrature::AbstractQuadrature)\n\nPerform an integration over the isideth face of an element (defined by cnodes and ctype).\n\nHere g_ref is expressed in the cell-reference element but n is the normal vector in the local element.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.integrate_on_ref-Tuple{Any, Bcube.CellInfo, Bcube.AbstractQuadrature}","page":"Integration","title":"Bcube.integrate_on_ref","text":"integrate_on_ref(g, cellinfo::CellInfo, quadrature::AbstractQuadrature, [::T]) where {N,[T<:AbstractComputeQuadratureStyle]}\n\nIntegrate a function g over a cell decribed by cellinfo. The function g can be expressed in the reference or the physical space corresponding to the cell, both cases are automatically handled by applying necessary mapping when needed.\n\nThis function is helpfull to integrate shape functions (for instance int lambda_i lambda_j) when the inverse mapping is not known explicitely (hence only hatlambda are known, not lambda).\n\nIf the last argument is given, computation is optimized according to the given concrete type T<:AbstractComputeQuadratureStyle.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.integrate_ref-Tuple{Any, Bcube.AbstractEntityType, Any, Bcube.AbstractQuadrature}","page":"Integration","title":"Bcube.integrate_ref","text":"integrate_ref(g_ref, ctype::AbstractEntityType, cnodes, quadrature::AbstractQuadrature, [::T]) where {[T<:AbstractComputeQuadratureStyle]}\n\nIntegrate function g_ref expressed in reference element. A variable substitution (involving Jacobian & Cie) is still applied, but the function is considered to be already mapped.\n\nThis function is helpfull to integrate shape functions (for instance int lambda_i lambda_j) when the inverse mapping is not known explicitely (hence only hatlambda are known, not lambda).\n\nIf the last argument is given, computation is optimized according to the given concrete type T<:AbstractComputeQuadratureStyle.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.integrate_ref-Tuple{Any, Int64, Bcube.AbstractEntityType, Any, Bcube.AbstractQuadrature}","page":"Integration","title":"Bcube.integrate_ref","text":"integrate_ref(g_ref, iside::Int, ctype::AbstractEntityType, cnodes, quadrature::AbstractQuadrature)\n\nIntegrate function g_ref on the iside-th side of the cell defined by its nodes cnodes and its type ctype. Function g_ref(x) is expressed in the cell-reference element (not the face reference).\n\nThis function is helpfull to integrate shape functions (for instance int lambda_i lambda_j) when the inverse     mapping is not known explicitely (hence only hatlambda are known, not lambda).\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.integrate_ref-Tuple{Bcube.isCurvilinear, Any, Bcube.AbstractEntityType{1}, Any, Bcube.AbstractQuadrature, Bcube.MapComputeQuadratureStyle}","page":"Integration","title":"Bcube.integrate_ref","text":"integrate_ref(::isCurvilinear, g_ref, ctype::AbstractEntityType{1}, cnodes, quadrature::AbstractQuadrature, ::T) where {T<:AbstractComputeQuadratureStyle}\n\nPerform an integration of the function g_ref (expressed in local element) over a line in a matbbR^n space.\n\nThe applied formulae is: int_Gamma g(x) dx = int_l F(l) g_ref(l) dl where F  mathbbR rightarrow mathbbR^n is the reference segment [-1,1] to the R^n line mapping.\n\nComputation is optimized according to the given concrete type T<:AbstractComputeQuadratureStyle.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.integrate_ref-Tuple{Bcube.isNodal, Any, Any, Any, Bcube.AbstractQuadrature, Bcube.AbstractComputeQuadratureStyle}","page":"Integration","title":"Bcube.integrate_ref","text":"integrate_ref(g_ref, ctype, cnodes, quadrature::AbstractQuadrature)\n\nIntegration on a node in a mathbbR^n space. This trivial function is only to simplify the 'side integral' expression.\n\nImplementation\n\nFor consistency reasons, g_ref is a function but it doesnt actually use its argument : the \"reference-element\" of a Node can be anything. For instance consider integrating g(x) = x on a node named node. Then g_ref(ξ) = g ∘ node.x. As you can see, g_ref doesnt actually depend on ξ\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.integrate_ref-Tuple{Bcube.isVolumic, Any, Bcube.AbstractEntityType, Any, Bcube.AbstractQuadrature, Bcube.MapComputeQuadratureStyle}","page":"Integration","title":"Bcube.integrate_ref","text":"integrate_ref(::isVolumic, g_ref, ctype::AbstractEntityType, cnodes, quadrature::AbstractQuadrature, ::T) where{N, T<:AbstractComputeQuadratureStyle}\n\nIntegrate function g_ref (expressed in reference element) on mesh element of type ctype defined by its cnodes at the quadrature. Computation is optimized according to the given concrete type T<:AbstractComputeQuadratureStyle.\n\nTo do so, a variable substitution is performed to integrate on the reference element.\n\nImplementation\n\nIt has been checked that calling the apply_quadrature method within this function instead of directly applying the quadrature rule (i.e without the anonymous function) does not decrease performance nor allocation.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Quadrature-rules","page":"Integration","title":"Quadrature rules","text":"","category":"section"},{"location":"api/integration/integration/","page":"Integration","title":"Integration","text":"Modules = [Bcube]\nPages   = [\"quadrature.jl\"]","category":"page"},{"location":"api/integration/integration/#Bcube.AbstractQuadrature","page":"Integration","title":"Bcube.AbstractQuadrature","text":"AbstractQuadrature{T,D}\n\nAbstract type representing quadrature of type T and degree D\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.AbstractQuadratureNode","page":"Integration","title":"Bcube.AbstractQuadratureNode","text":"AbstractQuadratureNode{S,Q}\n\nAbstract type representing a quadrature node for a shape S and a quadrature Q. This type is used to represent and identify easily a quadrature node in a quadrature rules.\n\nDerived types must implement the following method:\n\n- get_index(quadnode::AbstractQuadratureNode{S,Q})\n- get_coord(quadnode::AbstractQuadratureNode)\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.AbstractQuadratureRule","page":"Integration","title":"Bcube.AbstractQuadratureRule","text":"AbstractQuadratureRule{S,Q}\n\nAbstract type representing a quadrature rule for a shape S and quadrature Q.\n\nDerived types must implement the following method:     - [get_weights(qr::AbstractQuadratureRule)]     - [get_nodes(qr::AbstractQuadratureRule)]     - [Base.length(qr::AbstractQuadratureRule)]\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.Quadrature","page":"Integration","title":"Bcube.Quadrature","text":"Quadrature{T,D}\n\nQuadrature of type T and degree D\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.QuadratureNode","page":"Integration","title":"Bcube.QuadratureNode","text":"QuadratureNode{S,Q}\n\nType representing a quadrature node for a shape S and a quadrature Q. This type can be used to represent and identify easily a quadrature node in the corresponding parent quadrature rule.\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.QuadratureRule","page":"Integration","title":"Bcube.QuadratureRule","text":"QuadratureRule{S,Q}\n\nAbstract type representing a quadrature rule for a shape S and quadrature Q\n\n\n\n\n\n","category":"type"},{"location":"api/integration/integration/#Bcube.QuadratureRule-Tuple{Bcube.AbstractShape, Bcube.AbstractQuadrature}","page":"Integration","title":"Bcube.QuadratureRule","text":"QuadratureRule(shape::AbstractShape, q::AbstractQuadrature)\n\nReturn the quadrature rule corresponding to the given Shape according to the selected quadrature 'q'.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Base.length-Tuple{Bcube.AbstractQuadratureRule}","page":"Integration","title":"Base.length","text":"length(qr::AbstractQuadratureRule)\n\nReturns the number of quadrature nodes of qr.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube._gausslegendre1D-Union{Tuple{Val{N}}, Tuple{N}} where N","page":"Integration","title":"Bcube._gausslegendre1D","text":"_gausslegendre1D(::Val{N}) where N\n_gausslobatto1D(::Val{N}) where N\n\nReturn N-point Gauss quadrature weights and nodes on the domain [-1:1].\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube._get_num_nodes-Union{Tuple{degree}, Tuple{Bcube.Line, Val{degree}, QuadratureLegendre}} where degree","page":"Integration","title":"Bcube._get_num_nodes","text":"Gauss-Legendre formula with n nodes has degree of exactness 2n-1. Then, to obtain a given degree D, the number of nodes must satisfy: 2n-1  D or equivalently n  (D+1)2\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube._get_num_nodes-Union{Tuple{degree}, Tuple{Bcube.Line, Val{degree}, QuadratureLobatto}} where degree","page":"Integration","title":"Bcube._get_num_nodes","text":"Gauss-Lobatto formula with n+1 nodes has degree of exactness 2n-1, which equivalent to a degree of 2n-3 with n nodes. Then, to obtain a given degree D, the number of nodes must satisfy: 2n-3  D or equivalently n  (D+3)2\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube._get_num_nodes_per_dim-Union{Tuple{Bcube.AbstractQuadratureRule{<:S}}, Tuple{S}} where S","page":"Integration","title":"Bcube._get_num_nodes_per_dim","text":"get_num_nodes_per_dim(quadrule::AbstractQuadratureRule{S}) where S<:Shape\n\nReturns the number of nodes per dimension. This function is defined for shapes for which quadratures are based on a cartesian product : Line, Square, Cube\n\nRemark : Here we assume that the same degree is used along each dimension (no anisotropy for now!)\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.evalquadnode-Tuple{Any, Bcube.AbstractQuadratureNode}","page":"Integration","title":"Bcube.evalquadnode","text":"evalquadnode(f, quadnode::AbstractQuadratureNode)\n\nEvaluate the function f at the coordinates of quadnode.\n\nBasically, it computes:\n\nf(get_coord(quadnode))\n\nRemark:\n\nOptimization could be applied if f is a function based on a nodal basis such as one of the DoF and quadnode are collocated.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_coord-Tuple{Bcube.AbstractQuadratureNode}","page":"Integration","title":"Bcube.get_coord","text":"get_coord(quadnode::AbstractQuadratureNode)\n\nReturns the coordinates of quadnode.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_index-Tuple{Bcube.AbstractQuadratureNode}","page":"Integration","title":"Bcube.get_index","text":"get_index(quadnode::AbstractQuadratureNode{S,Q})\n\nReturns the index of quadnode in the parent quadrature rule AbstractQuadRules{S,Q}\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_nodes-Tuple{Bcube.AbstractQuadratureRule}","page":"Integration","title":"Bcube.get_nodes","text":"get_nodes(qr::AbstractQuadratureRule)\n\nReturns an array containing the coordinates of all quadrature nodes of qr.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_quadnodes-Union{Tuple{QuadratureRule{S, Q, N}}, Tuple{N}, Tuple{Q}, Tuple{S}} where {S, Q, N}","page":"Integration","title":"Bcube.get_quadnodes","text":"get_quadnodes(qr::QuadratureRule{S,Q,N}) where {S,Q,N}\n\nReturns an vector containing each QuadratureNode of qr\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_quadrature_points_gausslegendre-Tuple{Type{Val{:GLTRI12}}}","page":"Integration","title":"Bcube.get_quadrature_points_gausslegendre","text":"Gauss-Legendre quadrature, 12 point rule on triangle.\n\nRef: Witherden, F. D.; Vincent, P. E.      On the identification of symmetric quadrature rules for finite element methods.      Comput. Math. Appl. 69 (2015), no. 10, 1232–1241\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_quadrature_points_gausslegendre-Tuple{Type{Val{:GLTRI16}}}","page":"Integration","title":"Bcube.get_quadrature_points_gausslegendre","text":"Gauss-Legendre quadrature, 16 point rule on triangle, degree 8.\n\nRef: Witherden, F. D.; Vincent, P. E.      On the identification of symmetric quadrature rules for finite element methods.      Comput. Math. Appl. 69 (2015), no. 10, 1232–1241\n\nNote : quadrature is rescale to match our reference triangular shape which is defined in [0:1]² instead of [-1:1]²\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_quadrature_points_gausslegendre-Tuple{Type{Val{:GLTRI7}}}","page":"Integration","title":"Bcube.get_quadrature_points_gausslegendre","text":"Gauss-Legendre quadrature, 7 point rule on triangle. \n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.get_weights-Tuple{Bcube.AbstractQuadratureRule}","page":"Integration","title":"Bcube.get_weights","text":"get_weights(qr::AbstractQuadratureRule)\n\nReturns an array containing the weights of all quadrature nodes of qr.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.quadrature_points-Tuple{Bcube.Triangle, Val{4}, QuadratureLobatto}","page":"Integration","title":"Bcube.quadrature_points","text":"ref : https://www.math.umd.edu/~tadmor/references/files/Chen%20&%20Shu%20entropy%20stable%20DG%20JCP2017.pdf\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.quadrature_rule-Union{Tuple{N}, Tuple{Int64, Bcube.AbstractShape, Val{N}}} where N","page":"Integration","title":"Bcube.quadrature_rule","text":"quadrature_rule(iside::Int, shape::AbstractShape, degree::Val{N}) where N\n\nReturn the quadrature rule, computed with barycentric coefficients, corresponding to the given boundary of a shape and the given degree.\n\n\n\n\n\n","category":"method"},{"location":"api/integration/integration/#Bcube.quadrature_rule_bary-Union{Tuple{N}, Tuple{Int64, Bcube.AbstractShape, Val{N}}} where N","page":"Integration","title":"Bcube.quadrature_rule_bary","text":"quadrature_rule_bary(::Int, ::AbstractShape, degree::Val{N}) where N\n\nReturn the quadrature rule, computed with barycentric coefficients, corresponding to the given boundary of a shape and the given degree.\n\nThis function returns the quadrature weights and the barycentric weights to apply to each vertex of the reference shape. Hence, to apply the quadrature using this function, one needs to do : for (weight, l) in quadrature_rule_bary(iside, shape(etype), degree)     xp = zeros(SVector{td})     for i=1:nvertices         xp += l[i]*vertices[i]     end     # weight, xp is the quadrature couple (weight, node) end\n\n\n\n\n\n","category":"method"},{"location":"manual/geometry/#Geometry-and-mesh","page":"Geometry and mesh","title":"Geometry and mesh","text":"","category":"section"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"A Mesh is a set basically of nodes (Node), a set of entities (the mesh elements) and a list of connectivies that link the entities between themselves and with the nodes.","category":"page"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"In Bcube every mesh entity has corresponding reference Shape, a simplified or canonical representation of this element. A 1D line is mapped on the [-1,1] segment, and a rectangle is mapped on a square for instance. On these reference shapes, (almost) everything is known : the vertices location, the area, the quadrature points... Hence in Bcube we always compute things in the reference shape. For \"Lagrange\" elements (such as Bar*_t, Tri*_t, Quad*_t, Tetra*_t, Hexa*_t, Penta*_t etc), the mapping from the reference shape to a geometrical element is directly obtained from the corresponding Lagrange polynomials and the element node coordinates. Given a geometrical element with n nodes M_i, the mapping reads:","category":"page"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"F(xi) = sum_i=1^n hatlambda_i(xi)M_i","category":"page"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"where (lambda)_i are the Lagrange polynomials whose order matches the element order.","category":"page"},{"location":"manual/geometry/","page":"Geometry and mesh","title":"Geometry and mesh","text":"(Image: sketch)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Bcube","category":"page"},{"location":"#Bcube.jl","page":"Home","title":"Bcube.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bcube is a Julia library providing tools for the spatial discretization of partial differential equation(s) (PDE). It offers a high-level API to discretize linear or non-linear problems on unstructured mesh using continuous or discontinuous finite elements (FEM - DG).","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main features are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"high-level api : a(u, v) = ∫(η * ∇(u) ⋅ ∇(v))dΩ\n1D, 2D, 3D unstructured mesh with high-order geometrical elements (gmsh format)\nLagrange (continuous & discontinuous) and Taylor (discontinuous) finite elements (line, quad, tri, hexa, penta)\narbitrary order for hypercube Lagrange elements","category":"page"},{"location":"","page":"Home","title":"Home","text":"Commented tutorials as well as various examples can be found in the dedicated project BcubeTutorials.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bcube can be added to your Julia environment with this simple line :","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/bcube-project/Bcube.jl","category":"page"},{"location":"#Alternatives","page":"Home","title":"Alternatives","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Numerous FEM-DG Julia packages are available, here is a non-exhaustive list;","category":"page"},{"location":"","page":"Home","title":"Home","text":"Gridap.jl (which has greatly influenced the development of Bcube)\nFerrite.jl\nTrixi.jl","category":"page"},{"location":"#Contribution","page":"Home","title":"Contribution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Any contribution(s) and/or remark(s) are welcome! Don't hesitate to open an issue to ask a question or signal a bug. PRs improving the code (new features, new elements, fixing bugs, ...) will be greatly appreciated.","category":"page"},{"location":"#Gallery","page":"Home","title":"Gallery","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Helmholtz equation Phase field solidification Linear transport equation\n(Image: ) (Image: ) (Image: )","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ghislain Blanchard, Lokman Bennani and Maxime Bouyges","category":"page"},{"location":"api/mapping/mapping/#Mapping","page":"Mapping","title":"Mapping","text":"","category":"section"},{"location":"api/mapping/mapping/#Mappings","page":"Mapping","title":"Mappings","text":"","category":"section"},{"location":"api/mapping/mapping/","page":"Mapping","title":"Mapping","text":"Modules = [Bcube]\nPages   = [\"mapping.jl\"]","category":"page"},{"location":"api/mapping/mapping/#Bcube.mapping-Tuple{Any, Any, Any}","page":"Mapping","title":"Bcube.mapping","text":"mapping(ctype::AbstractEntityType, cnodes, ξ)\nmapping(cshape::AbstractShape, cnodes, ξ)\n\nMap the reference shape on the local shape.\n\nImplementation\n\nThis function must be implemented for all shape.\n\n::Bar2_t\n\nMap the reference 2-nodes bar [-1,1] on the local bar:\n\nF(xi) = dfracx_r - x_l2 xi + dfracx_r + x_l2\n\n::Tri3_t\n\nMap the reference 3-nodes Triangle [0,1] x [0,1] on the local triangle.\n\nF(xi  eta) = (1 - xi - eta) M_1 + x M_2 + y M_3\n\n::Quad4_t\n\nMap the reference 4-nodes square [-1,1] x [-1,1] on the 4-quadrilateral.\n\n::Tri6_t\n\nMap the reference 6-nodes triangle [0,1] x [0,1] on the P2 curved-triangle. F(xi) = sum lambda_i(xi) x_i where lambda_i are the Lagrange P2 shape functions and x_i are the local curved-triangle vertices' coordinates.\n\n::Quad9_t\n\nMap the reference 4-nodes square [-1,1] x [-1,1] on the P2 curved-quadrilateral. F(xi) = sum lambda_i(xi) x_i where lambda_i are the Lagrange P2 shape functions and x_i are the local curved-quadrilateral vertices' coordinates.\n\n::Hexa8_t\n\nMap the reference 8-nodes cube [-1,1] x [-1,1] x [-1,1] on the 8-hexa.\n\n::Hexa27_t\n\nMap the reference 8-nodes cube [-1,1] x [-1,1] x [-1,1] on the 27-hexa.\n\n::Penta6_t\n\nMap the reference 6-nodes prism [0,1] x [0,1] x [-1,1] on the 6-penta (prism).\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping-Tuple{Tetra4_t, Any, Any}","page":"Mapping","title":"Bcube.mapping","text":"mapping(nodes, ::Tetra4_t, ξ)\n\nMap the reference 4-nodes Tetraahedron [0,1] x [0,1] x [0,1] on the local triangle.\n\n```\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_det_jacobian-Tuple{Bcube.AbstractEntityType, Any, Any}","page":"Mapping","title":"Bcube.mapping_det_jacobian","text":"mapping_det_jacobian(ctype::AbstractEntityType, cnodes, ξ)\n\nAbsolute value of the determinant of the mapping Jacobian matrix, expressed in the reference element.\n\nImplementation\n\nDefault version using mapping_jacobian, but can be specified for each shape.\n\n::Bar2_t\n\nAbsolute value of the determinant of the mapping Jacobian matrix for the reference 2-nodes bar [-1,1] to the local bar mapping. det(J(xi)) = dfracx_r - x_l2\n\n::Tri3_t\n\nAbsolute value of the determinant of the mapping Jacobian matrix for the the reference 3-nodes Triangle [0,1] x [0,1] to the local triangle mapping.\n\nJ = (x_2 - x_1) (y_3 - y_1) - (x_3 - x_1) (y_2 - y_1)\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_face-Tuple{Bcube.AbstractShape, Any}","page":"Mapping","title":"Bcube.mapping_face","text":"mapping_face(cshape::AbstractShape, side)\nmapping_face(cshape::AbstractShape, side, permutation)\n\nBuild a mapping from the face reference element (corresponding to the side-th face of cshape) to the cell reference element (i.e the cshape).\n\nBuild a mapping from the face reference element (corresponding to the side-th face of cshape) to the cell reference element (i.e the cshape). If permutation is present, the mapping is built using this permutation.\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_inv-Tuple{Bcube.AbstractEntityType, Any, Any}","page":"Mapping","title":"Bcube.mapping_inv","text":"mapping_inv(::AbstractEntityType, cnodes, x)\n\nMap the local shape on the reference shape.\n\nImplementation\n\nThis function does not have to be implemented for all shape.\n\n::Bar2_t\n\nMap the local bar on the reference 2-nodes bar [-1,1]: F^-1(x) = dfrac2x - x_r - x_lx_r - x_l\n\n::Tri3_t\n\nMap the local triangle on the reference 3-nodes Triangle [0,1] x [0,1].\n\nTODO: check this formulae with SYMPY\n\nF^-1 beginpmatrix x  y endpmatrix =\nfrac1x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)\nbeginpmatrix\n    (y_3-y_1)x + (x_1 - x_3)y + (x_3 y_1 - x_1 y_3) \n    (y_1-y_2)x + (x_2 - x_1)x + (x_1 y_2 - x_2 y_1)\nendpmatrix\n\n::Quad4_t\n\nMap the  PARALLELOGRAM quadrilateral on the reference 4-nodes square [-1,1] x [-1,1]. Warning : this mapping is only corrects for parallelogram quadrilateral, not for any quadrilateral.\n\n\n\nTODO: check this formulae with SYMPY\n\nF^-1 beginpmatrix x  y endpmatrix =\nbeginpmatrix\n    a_1 x + b_1 y + c_1 \n    a_2 x + b_2 y + c_2\nendpmatrix\n\nwith\n\nbeginaligned\n    a_1  = dfrac-2 (y_3-y_2)Delta \n    b_1  = dfrac2 (x_3-x_2)Delta \n    c_1  = -1 - a_1 x_1 - b_1 y_1 \n    a_2  = dfrac-2 (y_1-y_2)Delta \n    b_2  = dfrac2 (x_1 - x_2)Delta \n    c_2  = -1 - a_2 x_1 - b_2 y_1\nendaligned\n\nwhere Delta = (x_1 - x_2)(y_3 - y_2) - (x_3 - x_2)(y_1 - y_2)\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_inv_jacobian-Tuple{Bcube.AbstractEntityType, Any, Any}","page":"Mapping","title":"Bcube.mapping_inv_jacobian","text":"mapping_inv_jacobian(ctype::AbstractEntityType, cnodes, x)\n\nJacobian matrix of the inverse mapping : dfracpartial F_i^-1partial x_j\n\nContrary to mapping_jacobian_inv, this function is not always defined because the inverse mapping, F^-1, is not always defined.\n\nImplementation\n\nDefault version using LinearAlgebra to inverse the matrix, but can be specified for each shape (if it exists).\n\n::Bar2_t\n\nMapping's jacobian matrix for the local bar to the reference 2-nodes bar [-1, 1].\n\ndfracpartial F^-1partial x = dfrac2x_r - x_l\n\n::Tri3_t\n\nMapping's jacobian matrix for the local triangle to the reference 3-nodes Triangle [0,1] x [0,1] mapping.\n\n\n\nTODO: check this formulae with SYMPY\n\nfracpartial F_i^-1partial x_j =\nfrac1x_1 (y_2 - y_3) + x_2 (y_3 - y_1) + x_3 (y_1 - y_2)\nbeginpmatrix\n    y_3 - y_1  x_1 - x_3 \n    y_1 - y_2  x_2 - x_1\nendpmatrix\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_jacobian-Tuple{Bcube.AbstractEntityType, Any, Any}","page":"Mapping","title":"Bcube.mapping_jacobian","text":"mapping_jacobian(ctype::AbstractEntityType, cnodes, ξ)\n\nJacobian matrix of the mapping : dfracpartial F_ipartial xi_j.\n\nImplementation\n\nDefault version using ForwardDiff, but can be specified for each shape.\n\n::Bar2_t\n\nMapping's jacobian matrix for the reference 2-nodes bar [-1, 1] to the local bar. dfracpartial Fpartial xi = dfracx_r - x_l2\n\n::Bar3_t\n\nMapping's jacobian matrix for the reference 2-nodes bar [-1, 1] to the local bar. ``\\dfrac{\\partial F}{\\partial \\xi} = \\frac{1}{2} \\left( (2\\xi - 1) M1 + (2\\xi + 1)M2 - 4 \\xi M_3\\right)\n\n::Tri3_t\n\nMapping's jacobian matrix for the reference 3-nodes Triangle [0,1] x [0,1] to the local triangle mapping.\n\ndfracpartial F_ipartial xi_j =\nbeginpmatrix\n    M_2 - M_1  M_3 - M_1\nendpmatrix\n\n::Quad4_t\n\nMapping's jacobian matrix for the reference square [-1,1] x [-1,1] to the 4-quadrilateral\n\nfracpartial Fpartial xi = -M_1 + M_2 + M_3 - M_4 + eta (M_1 - M_2 + M_3 - M_4)\n\nfracpartial Fpartial eta = -M_1 - M_2 + M_3 + M_4 + xi (M_1 - M_2 + M_3 - M_4)\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_jacobian_inv-Tuple{Bcube.AbstractEntityType, Any, Any}","page":"Mapping","title":"Bcube.mapping_jacobian_inv","text":"mapping_jacobian_inv(ctype::AbstractEntityType, cnodes, ξ)\n\nInverse of the mapping jacobian matrix. This is not exactly equivalent to the mapping_inv_jacobian since this function is evaluated in the reference element.\n\nImplementation\n\nDefault version using ForwardDiff, but can be specified for each shape.\n\n::Bar2_t\n\nInverse of mapping's jacobian matrix for the reference 2-nodes bar [-1, 1] to the local bar.\n\ndfracpartial Fpartial xi^-1 = dfrac2x_r - x_l\n\n::Bar3_t\n\nInverse of mapping's jacobian matrix for the reference 2-nodes bar [-1, 1] to the local bar.\n\ndfracpartial Fpartial xi^-1 = frac2(2xi - 1) M_1 + (2xi + 1)M_2 - 4 xi M_3\n\n::Tri3_t\n\nInverse of mapping's jacobian matrix for the reference 3-nodes Triangle [0,1] x [0,1] to the local triangle mapping.\n\ndfracpartial F_ipartial xi_j^-1 =\nfrac1(x_1 - x_2)(y_1 - y_3) - (x_1 - x_3)(y_1 - y_2)\nbeginpmatrix\n    -y_1 + y_3   x_1 - x_3 \n     y_1 - y_2  -x_1 + x_2\nendpmatrix\n\n::Quad4_t\n\nInverse of mapping's jacobian matrix for the reference square [-1,1] x [-1,1] to the 4-quadrilateral\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Reference-to-physical","page":"Mapping","title":"Reference to physical","text":"","category":"section"},{"location":"api/mapping/mapping/","page":"Mapping","title":"Mapping","text":"Modules = [Bcube]\nPages   = [\"ref2phys.jl\"]","category":"page"},{"location":"api/mapping/mapping/#Bcube.cell_normal-Union{Tuple{N}, Tuple{T}, Tuple{Bcube.AbstractEntityType{1}, AbstractArray{Node{2, T}, N}, Any}} where {T, N}","page":"Mapping","title":"Bcube.cell_normal","text":"cell_normal(ctype::AbstractEntityType, cnodes, ξ) where {T, N}\n\nCompute the cell normal vector of an entity of topology dimension equals to (d-1) in a n-D space, for instance a curve in a 2D space. This vector is expressed in the cell-reference coordinate system.\n\nDo not confuse the cell normal vector with the cell-side (i.e face) normal vector.\n\nTopology dimension 1\n\nthe curve direction vector, u, is J/||J||. Then n = [-u.y, u.x].\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.center-Tuple{Bcube.AbstractEntityType, Any}","page":"Mapping","title":"Bcube.center","text":"center(ctype::AbstractEntityType, cnodes)\n\nReturn the center of the AbstractEntityType by mapping the center of the corresponding Shape.\n\nWarning\n\nDo not use this function on a face of a cell : since the face is of dimension \"n-1\", the mapping won't be appropriate.\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.get_cell_centers-Tuple{Bcube.Mesh}","page":"Mapping","title":"Bcube.get_cell_centers","text":"get mesh cell centers coordinates (assuming perfectly flat cells)\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.interpolate-Tuple{Any, Any}","page":"Mapping","title":"Bcube.interpolate","text":"interpolate(λ, q)\ninterpolate(λ, q, ncomps)\n\nCreate the interpolation function from a set of value on dofs and the shape functions, given by:\n\n    f(x) = sum_i=1^N q_i lambda_i(x)\n\nSo q is a vector whose size equals the number of dofs in the cell.\n\nIf ncomps is present, create the interpolation function for a vector field given by a set of value on dofs and the shape functions.\n\nThe interpolation formulae is the same than interpolate(λ, q) but the result is a vector function. Here q is a vector whose size equals the total number of dofs in the cell (all components mixed).\n\nNote that the result function is expressed in the same coordinate system as the input shape functions (i.e reference or local).\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.mapping_jacobian_hypersurface-Tuple{Any, Any, Any}","page":"Mapping","title":"Bcube.mapping_jacobian_hypersurface","text":"mapping_jacobian_hypersurface(ctype, cnodes, ξ)\n\n\"Augmented\" jacobian matrix of the mapping.\n\nLet's consider a mathbbR^2 surface in mathbbR^3. The mapping F_Gamma(xi eta) maps the reference coordinate system to the physical coordinate system. It's jacobian J_Gamma is not squared. We can 'extend' this mapping to reach any point in mathbbR^3 (and not only the surface) using\n\nF(xi eta zeta) = F_Gamma(xi eta) + zeta nu\n\nwhere nu is the conormal. Then the restriction of the squared jacobian of F to the surface is simply\n\nJ_Gamma = (J_Gammanu)\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.normal-Tuple{Bcube.AbstractEntityType, Any, Any, Any}","page":"Mapping","title":"Bcube.normal","text":"normal(ctype::AbstractEntityType, cnodes, iside, ξ)\nnormal(::TopologyStyle, ctype::AbstractEntityType, cnodes, iside, ξ)\n\nNormal vector of the isideth face of a cell, evaluated at position ξ in the face reference element. So for the normal vector of the face of triangle living in a 3D space, ξ will be 1D (because the face is a line, which 1D).\n\nBeware this function needs the nodes cnodes and the type ctype of the cell (and not of the face).\n\nTODO: If iside is positive, then the outward normal (with respect to the cell) is returned, otherwise the inward normal is returned.\n\n::isCurvilinear\n\nNote that the \"face\" normal vector of a curve is the \"direction\" vector at the given extremity.\n\n::isVolumic\n\nn^loc = J^-intercal n^ref\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.∂fξ_∂x-Union{Tuple{F}, Tuple{F, Val{1}, Bcube.AbstractEntityType, Any, Any}} where F","page":"Mapping","title":"Bcube.∂fξ_∂x","text":"∂fξ_∂x(f, n::Val{N}, ctype::AbstractEntityType, cnodes, ξ) where N\n\nCompute the gradient, with respect to the physical coordinates, of a function f on a point in the reference domain. N is the size of the codomain of f.\n\n\n\n\n\n","category":"method"},{"location":"api/mapping/mapping/#Bcube.∂λξ_∂x","page":"Mapping","title":"Bcube.∂λξ_∂x","text":"∂λξ_∂x(::AbstractFunctionSpace, ::Val{N}, ctype::AbstractEntityType, cnodes, ξ) where N\n\nGradient, with respect to the physical coordinate system, of the shape functions associated to the FunctionSpace.\n\nDepending on the value of N, the shape functions are interpreted as associated to a scalar FESpace (N = 1) or a vector FESpace. For a vector FESpace, the result gradient is an array of size (n*Nc, n, d) where Nc is the number of dofs of one component (i.e scalar case), n is the size of the FESpace, and d the number of spatial dimensions.\n\nDefault version : the gradient shape functions are \"replicated\".\n\nSpecialize with a given FESpace for a custom behaviour.\n\nImplementation\n\nWe cannot use the topology_style to dispatch because this style is too specific to integration methods. For instance for the integration it is important the consider any line as isCurvilinear. However for the gradient computation we must distinguish a line in 1D, a line in 2D and a line in 3D...\n\n\n\n\n\n\n\n","category":"function"}]
}
