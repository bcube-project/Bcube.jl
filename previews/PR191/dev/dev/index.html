<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dev · Bcube</title><meta name="title" content="Dev · Bcube"/><meta property="og:title" content="Dev · Bcube"/><meta property="twitter:title" content="Dev · Bcube"/><meta name="description" content="Documentation for Bcube."/><meta property="og:description" content="Documentation for Bcube."/><meta property="twitter:description" content="Documentation for Bcube."/><meta property="og:url" content="https://bcube-project.github.io/Bcube.jl/dev/dev/"/><meta property="twitter:url" content="https://bcube-project.github.io/Bcube.jl/dev/dev/"/><link rel="canonical" href="https://bcube-project.github.io/Bcube.jl/dev/dev/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.jpg" alt="Bcube logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Bcube</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/conventions/">Conventions</a></li><li><a class="tocitem" href="../../manual/geometry/">Geometry and mesh</a></li><li><a class="tocitem" href="../../manual/integration/">Integration</a></li><li><a class="tocitem" href="../../manual/function_space/">Function and FE spaces</a></li><li><a class="tocitem" href="../../manual/cellfunction/">Cell function</a></li><li><a class="tocitem" href="../../manual/assembler/">Assemble (bi)linear forms</a></li><li><a class="tocitem" href="../../manual/operator/">LazyOperators</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../api/mesh/mesh/">Mesh</a></li><li><a class="tocitem" href="../../api/mesh/gmsh_utils/">GMSH</a></li><li><a class="tocitem" href="../../api/mesh/mesh_generator/">Mesh generator</a></li><li><a class="tocitem" href="../../api/interpolation/shape/">Reference shape</a></li><li><a class="tocitem" href="../../api/interpolation/function_space/">Function spaces</a></li><li><a class="tocitem" href="../../api/interpolation/fespace/">Finite element spaces</a></li><li><a class="tocitem" href="../../api/mapping/mapping/">Mapping</a></li><li><a class="tocitem" href="../../api/integration/integration/">Integration</a></li><li><a class="tocitem" href="../../api/dof/dof/">Degree of freedom</a></li><li><a class="tocitem" href="../../api/io/io_interface/">IO interface</a></li></ul></li><li><a class="tocitem" href="../../howto/howto/">How to... (FAQ)</a></li><li class="is-active"><a class="tocitem" href>Dev</a><ul class="internal"><li><a class="tocitem" href="#Interpolating-a-vector-field-on-a-curved-surfacic-element"><span>Interpolating a vector field on a curved surfacic element</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Dev</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dev</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bcube-project/Bcube.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bcube-project/Bcube.jl/blob/main/docs/src/dev/dev.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Dev"><a class="docs-heading-anchor" href="#Dev">Dev</a><a id="Dev-1"></a><a class="docs-heading-anchor-permalink" href="#Dev" title="Permalink"></a></h1><p>This section is intended for <code>Bcube</code> developers.</p><h2 id="Interpolating-a-vector-field-on-a-curved-surfacic-element"><a class="docs-heading-anchor" href="#Interpolating-a-vector-field-on-a-curved-surfacic-element">Interpolating a vector field on a curved surfacic element</a><a id="Interpolating-a-vector-field-on-a-curved-surfacic-element-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolating-a-vector-field-on-a-curved-surfacic-element" title="Permalink"></a></h2><p>Here we consider an <span>$n$</span>-dimensionnal surface in a <span>$\mathbb{R}^{n+1}$</span> space, i.e an hypersurface (for instance a sphere in <span>$\mathbb{R}^3$</span>). To ease the notations, we consider a 2-dimensionnal surface in <span>$\mathbb{R}^3$</span>. The physical coordinate system <span>$(x,y,z)$</span> is associated to the &quot;universe&quot; vector basis <span>$\mathcal{B}_p = (\vec{e}_x,\vec{e}_y,\vec{e}_z)$</span>. On each point of the surface, there also exists a so-called &quot;local&quot; vector basis <span>$\mathcal{B}_l(x,y,z)$</span> formed by the surface tangent plane and the normal. Recall that this vector basis depends on the position on the surface. Finally, the vector basis associated with the reference element is noted <span>$\mathcal{B}_r$</span>, and the coordinates are noted <span>$(\xi,\eta)$</span>. Since our reference elements are &quot;flat&quot; (a square, a cube, etc), the basis <span>$\mathcal{B}_r$</span> does not depend on the position in the reference element. Note that in practice <span>$\mathcal{B}_r$</span> is actually identified to <span>$\mathcal{B}_p$</span> by considering an additionnal direction along the normal of the reference element.</p><p>To ease the notations, we introduce the vectors <span>$\vec{x}=(x,y,z)$</span> and <span>$\vec{\xi}=(\xi,\eta,\zeta)$</span>. The mapping between the reference element and the physical element is noted <span>$\vec{x} = \vec{F}(\vec{\xi})$</span>. For an hypersurface, since the mapping is <span>$\vec{F}(\vec{\xi}) = \vec{F}_\Gamma(\xi,\eta) + \vec{\nu}(\xi,\eta) \zeta$</span> where <span>$\vec{F}_\Gamma$</span> is the &quot;classic&quot; <a href="#geometry-and-mesh">reference to physical mapping</a> and <span>$\vec{\nu}$</span> is the surface normal vector (in <span>$\mathcal{B}_p$</span>). This allows to identify the <span>$\mathcal{B}_l(x,y,z)$</span> basis vectors as <span>$(\partial_\xi \vec{F}_\Gamma, \partial_\eta \vec{F}_\Gamma, \vec{\nu})$</span>. This triplet of vectors form the mapping jacobian <span>$J(\xi)$</span>. This jacobian is nothing else than the change-of-basis operator/matrix between <span>$\mathcal{B}_l$</span> and <span>$\mathcal{B}_p$</span>.</p><p>Now, let&#39;s a cell in the mesh of the surface, and consider a discrete vector field <span>$\vec{q}$</span> over this cell. We restrict ourselves to nodal FE basis. For a &quot;planar&quot; (ie not curved) element the discrete representation of <span>$\vec{q}$</span> on a point <span>$\vec{\xi}$</span> in the reference element reads</p><p class="math-container">\[\begin{equation}
    \label{eqn-std-interpolation}
    \vec{q}(\vec{\xi}) = \sum_{i=1}^N \vec{q}_i \hat{\lambda}_i(\vec{\xi})
\end{equation}\]</p><p>where <span>$N$</span> is the number of dofs and <span>$\vec{q}_i$</span> are the dof values of the vector <span>$\vec{q}$</span> in the physical basis <span>$\mathcal{B}_p$</span>. Since we resctrict to Lagrange element, <span>$\vec{q}_i = \vec{q}(\vec{\xi_i})$</span>.</p><p>It gets harder when dealing with a curved element. Imagine that all <span>$\vec{q}_i$</span> have a given angle with respect to the surface. We would like the interpolation of <span>$\vec{q}$</span> to have this angle with the surface on any point <span>$\vec{\xi}$</span>. A standard interpolation like <span>$\eqref{eqn-std-interpolation}$</span> doesn&#39;t ensure this property. Imagine that instead of knowning the <span>$\vec{q}_i$</span> (in the physical element), we know <span>$\vec{\tilde{q}}_i$</span>, the dof values of <span>$\vec{q}$</span> in the local basis <span>$\mathcal{B}_l$</span>. We would then write</p><p class="math-container">\[\begin{equation}
    \label{eqn-interpolation-in-ref}
    \vec{q}(\xi) = J(\xi) \sum_{i=1}^N \vec{\tilde{q}}_i \hat{\lambda}_i(\vec{\xi})
\end{equation}\]</p><p>where we recall that <span>$J$</span> is the change-of-basis matrix from <span>$\mathcal{B}_l(\xi)$</span> to <span>$\mathcal{B}_p$</span>. In other words, the interpolation is performed in the local basis, and the result is mapped to the physical basis. Now, if we don&#39;t know the <span>$\vec{\tilde{q}}_i$</span> but only the <span>$\vec{q}_i$</span> (ie the dofs in the physical basis), we look for the rotation / linear map <span>$R_\xi^x$</span> to apply on each dof such that</p><p class="math-container">\[\begin{equation}
  \label{eqn-interpolation-in-phys-with-rot}
    \vec{q}(\vec{\xi}) = \sum_{i=1}^N R_\xi^x(\vec{\xi}, \vec{\xi}_i) \vec{q}_i \hat{\lambda}_i(\vec{\xi}).
\end{equation}\]</p><p>We used two arguments (<span>$\vec{\xi}$</span> and <span>$\vec{\xi}_i$</span>) for <span>$R_\xi^x$</span> to emphasize that for each point <span>$\vec{\xi}$</span>, there is one different <span>$R_\xi^x$</span> to apply on each dof node <span>$\vec{\xi}_i$</span>. Combining <span>$\eqref{eqn-interpolation-in-ref}$</span> with <span>$\eqref{eqn-interpolation-in-phys-with-rot}$</span> leads to</p><p class="math-container">\[    \forall i,~J(\vec{\xi})\vec{\tilde{q}}_i = R_\xi^x(\vec{\xi}, \vec{\xi}_i) \vec{q}_i.\]</p><p>Then, by definition the <span>$\vec{\tilde{q}}_i$ are the representation of $\vec{q}_i$ in the local basis, that is to say $$\vec{\tilde{q}}_i = P_x^\xi(\vec{x_i}) \vec{q}_i$</span>, where <span>$P_x^\xi(\vec{x_i})$</span> is the change-of-basis matrix from <span>$\mathcal{B}_p$</span> to <span>$\mathcal{B}_l(F^{-1}(\vec{x_i}))$</span>. And note that</p><p class="math-container">\[    P_x^\xi(\vec{x_i}) = (P_\xi^x(\vec{F}^{-1}(\vec{x}_i)))^{-1} = (J(\vec{\xi}_i))^{-1}.\]</p><p>Hence, <span>$R_\xi^x(\vec{\xi}, \vec{\xi}_i)$</span> is identified to <span>$J(\vec{\xi})J^{-1}(\vec{F}(\vec{\xi}_i))$</span>. Finally, the correct interpolation to apply is</p><p class="math-container">\[\begin{equation}
    \label{eqn-corrected-interpolation}
    \vec{q}(\vec{\xi}) = J(\vec{\xi}) \sum_{i=1}^N (J(\vec{\xi}_i))^{-1} \vec{q}_i \hat{\lambda_i}(\vec{\xi}_i).
\end{equation}\]</p><div class="admonition is-info" id="Implementation-details-84fa01a3259e3a95"><header class="admonition-header">Implementation details<a class="admonition-anchor" href="#Implementation-details-84fa01a3259e3a95" title="Permalink"></a></header><div class="admonition-body"><p>It might be tempting to implement <span>$\eqref{eqn-interpolation-in-ref}$</span> instead of <span>$\eqref{eqn-corrected-interpolation}$</span>. Although possible, note that equations are solved in the physical space in <code>Bcube</code>, so the &quot;result&quot; (or &quot;rhs&quot;) of the equation will be in the physical space. If the dof values are (stored) in the reference space, any update of an <code>FEFunction</code> with the <em>rhs</em> would require a custom <code>set_dof_values!</code> function that apply the <span>$P_x^\xi$</span> operation on each dof. Hence, the mesh would be required to pass to <code>set_dof_values!</code> etc, even for planar cases. For now, it&#39;s seem more reasonable to keep the dof in the physical space, and apply and a specific treatment for surfacic curved elements.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../howto/howto/">« How to... (FAQ)</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 12 September 2025 14:33">Friday 12 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
