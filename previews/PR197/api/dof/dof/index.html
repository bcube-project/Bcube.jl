<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Degree of freedom · Bcube</title><meta name="title" content="Degree of freedom · Bcube"/><meta property="og:title" content="Degree of freedom · Bcube"/><meta property="twitter:title" content="Degree of freedom · Bcube"/><meta name="description" content="Documentation for Bcube."/><meta property="og:description" content="Documentation for Bcube."/><meta property="twitter:description" content="Documentation for Bcube."/><meta property="og:url" content="https://bcube-project.github.io/Bcube.jl/api/dof/dof/"/><meta property="twitter:url" content="https://bcube-project.github.io/Bcube.jl/api/dof/dof/"/><link rel="canonical" href="https://bcube-project.github.io/Bcube.jl/api/dof/dof/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.jpg" alt="Bcube logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Bcube</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../manual/conventions/">Conventions</a></li><li><a class="tocitem" href="../../../manual/geometry/">Geometry and mesh</a></li><li><a class="tocitem" href="../../../manual/integration/">Integration</a></li><li><a class="tocitem" href="../../../manual/function_space/">Function and FE spaces</a></li><li><a class="tocitem" href="../../../manual/cellfunction/">Cell function</a></li><li><a class="tocitem" href="../../../manual/assembler/">Assemble (bi)linear forms</a></li><li><a class="tocitem" href="../../../manual/operator/">LazyOperators</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../mesh/mesh/">Mesh</a></li><li><a class="tocitem" href="../../mesh/gmsh_utils/">GMSH</a></li><li><a class="tocitem" href="../../mesh/mesh_generator/">Mesh generator</a></li><li><a class="tocitem" href="../../interpolation/shape/">Reference shape</a></li><li><a class="tocitem" href="../../interpolation/function_space/">Function spaces</a></li><li><a class="tocitem" href="../../interpolation/fespace/">Finite element spaces</a></li><li><a class="tocitem" href="../../mapping/mapping/">Mapping</a></li><li><a class="tocitem" href="../../integration/integration/">Integration</a></li><li class="is-active"><a class="tocitem" href>Degree of freedom</a><ul class="internal"><li><a class="tocitem" href="#Assembler"><span>Assembler</span></a></li><li><a class="tocitem" href="#DofHandler"><span>DofHandler</span></a></li></ul></li><li><a class="tocitem" href="../../io/io_interface/">IO interface</a></li></ul></li><li><a class="tocitem" href="../../../howto/howto/">How to... (FAQ)</a></li><li><a class="tocitem" href="../../../dev/dev/">Dev</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Degree of freedom</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Degree of freedom</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bcube-project/Bcube.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bcube-project/Bcube.jl/blob/main/docs/src/api/dof/dof.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="dof"><a class="docs-heading-anchor" href="#dof">Degree of freedom</a><a id="dof-1"></a><a class="docs-heading-anchor-permalink" href="#dof" title="Permalink"></a></h1><h2 id="Assembler"><a class="docs-heading-anchor" href="#Assembler">Assembler</a><a id="Assembler-1"></a><a class="docs-heading-anchor-permalink" href="#Assembler" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Bcube.AbstractBilinearFaceSidePair"><a class="docstring-binding" href="#Bcube.AbstractBilinearFaceSidePair"><code>Bcube.AbstractBilinearFaceSidePair</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractBilinearFaceSidePair{A} &lt;: AbstractLazyWrap{A}</code></pre><p>Abstract base type for wrapping bilinear form shape functions on face pairs.</p><p>Specializes AbstractFaceSidePair for use in bilinear forms with trial and test functions.</p><p><strong>Interface:</strong></p><ul><li><code>get_args_bilinear(a::AbstractBilinearFaceSidePair)</code> - Extract bilinear arguments</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1402-L1411">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.AbstractFaceSidePair"><a class="docstring-binding" href="#Bcube.AbstractFaceSidePair"><code>Bcube.AbstractFaceSidePair</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractFaceSidePair{A} &lt;: AbstractLazyWrap{A}</code></pre><p>Abstract base type for wrapping shape functions on face pairs (two sides of a face).</p><p><strong>Interface:</strong></p><ul><li><code>side_n(a::AbstractFaceSidePair)</code></li><li><code>side_p(a::AbstractFaceSidePair)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1330-L1338">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.BilinearTestFaceSidePair"><a class="docstring-binding" href="#Bcube.BilinearTestFaceSidePair"><code>Bcube.BilinearTestFaceSidePair</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BilinearTestFaceSidePair{A}</code></pre><p>Concrete wrapper for test shape functions on face pairs.</p><p>Stores four combinations: (nn, pn, np, pp) where n denotes negative side and p denotes positive side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1472-L1478">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.BilinearTestFaceSidePair-Tuple"><a class="docstring-binding" href="#Bcube.BilinearTestFaceSidePair-Tuple"><code>Bcube.BilinearTestFaceSidePair</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BilinearTestFaceSidePair(a...)</code></pre><p>Construct a BilinearTestFaceSidePair from variable arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1483-L1487">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.BilinearTrialFaceSidePair"><a class="docstring-binding" href="#Bcube.BilinearTrialFaceSidePair"><code>Bcube.BilinearTrialFaceSidePair</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BilinearTrialFaceSidePair{A}</code></pre><p>Concrete wrapper for trial shape functions on face pairs.</p><p>Stores four combinations: (nn, pn, np, pp) where n denotes negative side and p denotes positive side.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1444-L1450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.BilinearTrialFaceSidePair-Tuple"><a class="docstring-binding" href="#Bcube.BilinearTrialFaceSidePair-Tuple"><code>Bcube.BilinearTrialFaceSidePair</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">BilinearTrialFaceSidePair(a...)</code></pre><p>Construct a BilinearTrialFaceSidePair from variable arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1455-L1459">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.FaceSidePair"><a class="docstring-binding" href="#Bcube.FaceSidePair"><code>Bcube.FaceSidePair</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FaceSidePair{A}</code></pre><p>Concrete wrapper for shape functions on face pairs.</p><p>Stores data as <code>(side_n_data, side_p_data)</code> tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1344-L1350">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.FaceSidePair-Tuple{Any, Any}"><a class="docstring-binding" href="#Bcube.FaceSidePair-Tuple{Any, Any}"><code>Bcube.FaceSidePair</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">FaceSidePair(a, b)</code></pre><p>Construct a FaceSidePair from two arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1355-L1359">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.repeat-Union{Tuple{N}, Tuple{StaticArraysCore.SVector, Val{N}}} where N"><a class="docstring-binding" href="#Base.repeat-Union{Tuple{N}, Tuple{StaticArraysCore.SVector, Val{N}}} where N"><code>Base.repeat</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.repeat(a::SVector, ::Val{N})</code></pre><p>Repeat a static vector N times by vertical concatenation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1249-L1253">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.__assemble_bilinear!-Union{Tuple{F}, Tuple{Any, Any, Any, Int64, F, Measure, TrialFESpace, TestFESpace, Bcube.AbstractBcubeBackend}} where F&lt;:Function"><a class="docstring-binding" href="#Bcube.__assemble_bilinear!-Union{Tuple{F}, Tuple{Any, Any, Any, Int64, F, Measure, TrialFESpace, TestFESpace, Bcube.AbstractBcubeBackend}} where F&lt;:Function"><code>Bcube.__assemble_bilinear!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">__assemble_bilinear!(
    I,
    J,
    X,
    offset0::Int,
    f::F,
    measure::Measure,
    U::TrialFESpace,
    V::TestFESpace,
    backend::AbstractBcubeBackend,
) where {F &lt;: Function}</code></pre><p>Perform assembly of a bilinear form (function <code>f</code> integrated on the <code>measure</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L264-L279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.__assemble_bilinear!-Union{Tuple{N}, Tuple{F}, Tuple{AbstractVector, AbstractVector, AbstractVector, Int64, F, Measure, Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TrialFESpace, N}}}, Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TestFESpace, N}}}, Bcube.AbstractBcubeBackend}} where {F&lt;:Function, N}"><a class="docstring-binding" href="#Bcube.__assemble_bilinear!-Union{Tuple{N}, Tuple{F}, Tuple{AbstractVector, AbstractVector, AbstractVector, Int64, F, Measure, Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TrialFESpace, N}}}, Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TestFESpace, N}}}, Bcube.AbstractBcubeBackend}} where {F&lt;:Function, N}"><code>Bcube.__assemble_bilinear!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">__assemble_bilinear!(
    I::AbstractVector,
    J::AbstractVector,
    X::AbstractVector,
    offset::Int,
    f::F,
    measure::Measure,
    U::AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TrialFESpace, N}}},
    V::AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TestFESpace, N}}},
    backend::AbstractBcubeBackend,
) where {F &lt;: Function, N}</code></pre><p>Assemble bilinear form over all combinations of component spaces in MultiFESpaces.</p><p>Loops over all pairs of component spaces (i, j) and calls <code>assemble_bilinear_by_singleFE!</code> to handle each component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L309-L326">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.__assemble_linear!-Tuple{Any, Any, Any, Measure, Bcube.AbstractBcubeBackend}"><a class="docstring-binding" href="#Bcube.__assemble_linear!-Tuple{Any, Any, Any, Measure, Bcube.AbstractBcubeBackend}"><code>Bcube.__assemble_linear!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong>Dev notes</strong></p><p>Two levels of &quot;LazyMapOver&quot; because first we LazyMapOver the Tuple of argument of the linear form, and the for each item of this Tuple we LazyMapOver the shape functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L518-L522">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.__map_idofs-Union{Tuple{N}, Tuple{Tuple{Vararg{AbstractArray, N}}, Tuple{Vararg{StaticArraysCore.SVector, N}}}} where N"><a class="docstring-binding" href="#Bcube.__map_idofs-Union{Tuple{N}, Tuple{Tuple{Vararg{AbstractArray, N}}, Tuple{Vararg{StaticArraysCore.SVector, N}}}} where N"><code>Bcube.__map_idofs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">__map_idofs(mappings::Tuple{Vararg{AbstractArray, N}}, idofs::Tuple{Vararg{SVector, N}})</code></pre><p>Recursively map DoF indices using component-specific mappings.</p><p>Applies each mapping to the corresponding component space&#39;s DoFs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L707-L713">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.__update_b!-Tuple{AbstractVector, Any, Bcube.LazyOperators.NullOperator, Bcube.AbstractBcubeBackend}"><a class="docstring-binding" href="#Bcube.__update_b!-Tuple{AbstractVector, Any, Bcube.LazyOperators.NullOperator, Bcube.AbstractBcubeBackend}"><code>Bcube.__update_b!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">__update_b!(b, dofs, vals::NullOperator, backend)</code></pre><p>No-op update when values are null operators.</p><p>Skips processing when there are no actual values to add.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L865-L871">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.__update_b!-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector, Tuple{Tuple{Vararg{T2, N}}}, Bcube.AbstractBcubeBackend}} where {T1&lt;:Number, T2&lt;:Number, N}"><a class="docstring-binding" href="#Bcube.__update_b!-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector, Tuple{Tuple{Vararg{T2, N}}}, Bcube.AbstractBcubeBackend}} where {T1&lt;:Number, T2&lt;:Number, N}"><code>Bcube.__update_b!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">__update_b!(b, idofs::AbstractVector, intvals::Tuple, backend)</code></pre><p>Update linear form vector with integrated values for a single component.</p><p>Maps over the tuple of values and recursively calls <code>__update_b!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L829-L835">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.__update_b!-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{&lt;:Integer}, Tuple{Vararg{T2, N}}, Bcube.BcubeBackendCPUSerial}} where {T1&lt;:Number, T2&lt;:Number, N}"><a class="docstring-binding" href="#Bcube.__update_b!-Union{Tuple{N}, Tuple{T2}, Tuple{T1}, Tuple{AbstractVector{T1}, AbstractVector{&lt;:Integer}, Tuple{Vararg{T2, N}}, Bcube.BcubeBackendCPUSerial}} where {T1&lt;:Number, T2&lt;:Number, N}"><code>Bcube.__update_b!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">__update_b!(b, dofs::AbstractVector{&lt;:Integer}, vals::NTuple, backend::BcubeBackendCPUSerial)</code></pre><p>Actually update the linear form vector entries for CPU serial backend.</p><p>Adds the integrated values to the corresponding DoF entries in the result vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L846-L852">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.__update_b!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{T}, Tuple{Vararg{Union{Tuple, StaticArraysCore.SVector}, N}}, Tuple{Vararg{Any, N}}, Bcube.AbstractBcubeBackend}} where {N, T}"><a class="docstring-binding" href="#Bcube.__update_b!-Union{Tuple{T}, Tuple{N}, Tuple{AbstractVector{T}, Tuple{Vararg{Union{Tuple, StaticArraysCore.SVector}, N}}, Tuple{Vararg{Any, N}}, Bcube.AbstractBcubeBackend}} where {N, T}"><code>Bcube.__update_b!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">__update_b!(b, idofs::Tuple, intvals::Tuple, backend)</code></pre><p>Update linear form vector for multi-space with component-wise updates.</p><p>Maps over each component space, updating its DoFs with the corresponding values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L811-L817">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._append_bilinear!-Tuple{Any, Any, Any, Any, Any, Any, Any, Bcube.AbstractBcubeBackend}"><a class="docstring-binding" href="#Bcube._append_bilinear!-Tuple{Any, Any, Any, Any, Any, Any, Any, Bcube.AbstractBcubeBackend}"><code>Bcube._append_bilinear!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_append_bilinear!(I, J, X, offset, row, col, vals, backend)</code></pre><p>Append a bilinear contribution to the COO format arrays.</p><p>Takes row and column DoF arrays and computes their Cartesian product, then appends the resulting indices and values to the sparse matrix arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L623-L630">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._append_contribution!-Tuple{Any, Any, Any, Any, Any, Any, Any, Bcube.CellInfo, Any, Bcube.AbstractBcubeBackend}"><a class="docstring-binding" href="#Bcube._append_contribution!-Tuple{Any, Any, Any, Any, Any, Any, Any, Bcube.CellInfo, Any, Bcube.AbstractBcubeBackend}"><code>Bcube._append_contribution!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_append_contribution!(X, I, J, offset, U, V, values, elementInfo::CellInfo, domain, backend)</code></pre><p>Append contributions to the COO format arrays for a cell element.</p><p>Extracts DoF indices for the trial and test spaces and appends the computed values to the sparse matrix arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L547-L554">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._append_contribution!-Tuple{Any, Any, Any, Any, Any, Any, Any, Bcube.FaceInfo, Any, Bcube.AbstractBcubeBackend}"><a class="docstring-binding" href="#Bcube._append_contribution!-Tuple{Any, Any, Any, Any, Any, Any, Any, Bcube.FaceInfo, Any, Bcube.AbstractBcubeBackend}"><code>Bcube._append_contribution!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_append_contribution!(X, I, J, offset, U, V, values, elementInfo::FaceInfo, domain, backend)</code></pre><p>Append contributions to the COO format arrays for a face element.</p><p>Handles both sides of a face (n⁻ and n⁺) and adds all four combinations of DoF interactions (n⁻-n⁻, n⁻-n⁺, n⁺-n⁻, n⁺-n⁺) to the sparse matrix arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L577-L584">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._assemble_bilinear!-Union{Tuple{F}, Tuple{AbstractVector, AbstractVector, AbstractVector, Int64, F, Any, Any, Bcube.Integration, Bcube.AbstractBcubeBackend}} where F&lt;:Function"><a class="docstring-binding" href="#Bcube._assemble_bilinear!-Union{Tuple{F}, Tuple{AbstractVector, AbstractVector, AbstractVector, Int64, F, Any, Any, Bcube.Integration, Bcube.AbstractBcubeBackend}} where F&lt;:Function"><code>Bcube._assemble_bilinear!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_assemble_bilinear!(I, J, X, offset, a, U, V, integration::Integration, backend)</code></pre><p>Internal assembly function that dispatches over a single integration.</p><p>Extracts the function from the integrand and calls <code>__assemble_bilinear!</code> with the measure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L240-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._assemble_bilinear!-Union{Tuple{N}, Tuple{F}, Tuple{AbstractVector, AbstractVector, AbstractVector, Int64, F, Any, Any, Bcube.MultiIntegration{N, I} where I&lt;:Tuple{Vararg{Bcube.Integration, N}}, Bcube.AbstractBcubeBackend}} where {F&lt;:Function, N}"><a class="docstring-binding" href="#Bcube._assemble_bilinear!-Union{Tuple{N}, Tuple{F}, Tuple{AbstractVector, AbstractVector, AbstractVector, Int64, F, Any, Any, Bcube.MultiIntegration{N, I} where I&lt;:Tuple{Vararg{Bcube.Integration, N}}, Bcube.AbstractBcubeBackend}} where {F&lt;:Function, N}"><code>Bcube._assemble_bilinear!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_assemble_bilinear!(I, J, X, offset, a, U, V, multiIntegration::MultiIntegration{N}, backend)</code></pre><p>Internal assembly function that dispatches over multiple integration domains.</p><p>Loops over each integration in the <code>MultiIntegration</code> and calls <code>_assemble_bilinear!</code> recursively with the extracted bilinear form component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L212-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._assemble_linear!-Tuple{Any, Any, Any, Bcube.Integration, Bcube.AbstractBcubeBackend}"><a class="docstring-binding" href="#Bcube._assemble_linear!-Tuple{Any, Any, Any, Bcube.Integration, Bcube.AbstractBcubeBackend}"><code>Bcube._assemble_linear!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_assemble_linear!(b, l, V, integration::Integration, backend::AbstractBcubeBackend)
_assemble_linear!(b, l, V, integration::MultiIntegration{N}, backend::AbstractBcubeBackend) where {N}</code></pre><p>These functions act as a function barrier in order to:</p><ul><li>get the function corresponding to the operand in the linear form</li><li>reshape <code>b</code> internally to deal with cases when <code>V</code> is a <code>AbstractMultiTestFESpace</code></li><li>call <code>__assemble_linear!</code> to apply dispatch on the type of <code>measure</code> of the integration and improve type stability during the assembling loop.</li></ul><p><strong>Dev note:</strong></p><p>The case <code>integration::MultiIntegration{N}</code> is treated by looping over each <code>Integration</code> contained in the <code>MultiIntegration</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L475-L488">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._bilinear_integration_type-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#Bcube._bilinear_integration_type-Tuple{Any, Any, Any}"><code>Bcube._bilinear_integration_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_bilinear_integration_type(a, U, V)</code></pre><p>Determine the integration type (Single or Multi) by evaluating the bilinear form with null operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L19-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._blockmap_bilinear-Union{Tuple{N2}, Tuple{N1}, Tuple{Tuple{Vararg{T, N1}} where T, Tuple{Vararg{T, N2}} where T}} where {N1, N2}"><a class="docstring-binding" href="#Bcube._blockmap_bilinear-Union{Tuple{N2}, Tuple{N1}, Tuple{Tuple{Vararg{T, N1}} where T, Tuple{Vararg{T, N2}} where T}} where {N1, N2}"><code>Bcube._blockmap_bilinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_blockmap_bilinear(a::NTuple{N1}, b::NTuple{N2})</code></pre><p>From tuples <span>$a=(a_1, a_2, …, a_i, …, a_m)$</span> and <span>$b=(b_1, b_2, …, b_j, …, b_n)$</span>, it builds <code>A</code> and <code>B</code> which correspond formally to the following two matrices :</p><p class="math-container">\[A \equiv \begin{pmatrix}
a_1 &amp; a_1 &amp; ⋯ &amp; a_1\\
a_2 &amp; a_2 &amp; ⋯ &amp; a_2\\
 ⋮  &amp;  ⋮  &amp; ⋮ &amp; ⋮  \\
a_m &amp; a_m &amp; ⋯ &amp; a_m
\end{pmatrix}
\qquad and \qquad
B \equiv \begin{pmatrix}
b_1 &amp; b_2 &amp; ⋯ &amp; b_n\\
b_1 &amp; b_2 &amp; ⋯ &amp; b_n\\
 ⋮  &amp;  ⋮  &amp; ⋮ &amp; ⋮  \\
b_1 &amp; b_2 &amp; ⋯ &amp; b_n
\end{pmatrix}\]</p><p><code>A</code> and <code>B</code> are wrapped in <code>LazyMapOver</code> structures so that all operations on them are done elementwise by default (in other words, it can be considered that the operations are automatically broadcasted).</p><p><strong>Dev note :</strong></p><p>Both <code>A</code> and <code>B</code> are stored as a tuple of tuples, wrapped by <code>LazyMapOver</code>, where inner tuples correspond to each columns of a matrix. This hierarchical structure reduces both inference and compile times by avoiding the use of large tuples.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1185-L1214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._cartesian_product-Union{Tuple{N2}, Tuple{N1}, Tuple{Tuple{Vararg{T, N1}} where T, Tuple{Vararg{T, N2}} where T}} where {N1, N2}"><a class="docstring-binding" href="#Bcube._cartesian_product-Union{Tuple{N2}, Tuple{N1}, Tuple{Tuple{Vararg{T, N1}} where T, Tuple{Vararg{T, N2}} where T}} where {N1, N2}"><code>Bcube._cartesian_product</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_cartesian_product(a::NTuple{N1}, b::NTuple{N2})
_cartesian_product(a::SVector{N1}, b::SVector{N2})</code></pre><p>Compute the Cartesian product of two tuples or static vectors.</p><p>Returns two tuples where the first contains all combinations from <code>a</code> repeated, and the second contains all combinations from <code>b</code> with proper ordering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1225-L1233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._cellpair_blockmap_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractShape, Bcube.AbstractShape}"><a class="docstring-binding" href="#Bcube._cellpair_blockmap_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractShape, Bcube.AbstractShape}"><code>Bcube._cellpair_blockmap_shape_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_cellpair_blockmap_shape_functions(feSpace::AbstractFESpace,
                                   cshape_i::AbstractShape, cshape_j::AbstractShape)</code></pre><p>Create shape function pair for two cell shapes in a single FESpace.</p><p>Returns a FaceSidePair wrapped in LazyMapOver for use in face integrations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1080-L1087">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._cellpair_blockmap_shape_functions-Tuple{Bcube.AbstractMultiFESpace, Bcube.AbstractShape, Bcube.AbstractShape}"><a class="docstring-binding" href="#Bcube._cellpair_blockmap_shape_functions-Tuple{Bcube.AbstractMultiFESpace, Bcube.AbstractShape, Bcube.AbstractShape}"><code>Bcube._cellpair_blockmap_shape_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_cellpair_blockmap_shape_functions(multiFESpace::AbstractMultiFESpace,
                                   cshape_i::AbstractShape, cshape_j::AbstractShape)</code></pre><p>Create block-diagonal shape function pairs for two cell shapes in a MultiFESpace.</p><p>Returns FaceSidePairs with LazyMapOver wrappers for each component space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1061-L1068">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._check_domains_compatibility-Union{Tuple{Bcube.MultiIntegration{N, I} where I&lt;:Tuple{Vararg{Bcube.Integration, N}}}, Tuple{N}} where N"><a class="docstring-binding" href="#Bcube._check_domains_compatibility-Union{Tuple{Bcube.MultiIntegration{N, I} where I&lt;:Tuple{Vararg{Bcube.Integration, N}}}, Tuple{N}} where N"><code>Bcube._check_domains_compatibility</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_check_domains_compatibility(multi::MultiIntegration) -&gt; Bool</code></pre><p>Return <code>true</code> iff all integrals in <code>multi</code> are defined on:</p><ol><li>the <strong>same mesh instance</strong> (pointer-equality with <code>===</code>), and</li><li>the <strong>same entity kind</strong> (all <code>AbstractCellDomain</code> or all <code>AbstractFaceDomain</code>).</li></ol><p>Overlaps between subdomains are allowed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1297-L1305">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._diag_tuples-Union{Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Any}} where N"><a class="docstring-binding" href="#Bcube._diag_tuples-Union{Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Any}} where N"><code>Bcube._diag_tuples</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_diag_tuples(diag::Tuple{Vararg{Any,N}}, b) where N</code></pre><p>Return <code>N</code> tuples of length <code>N</code>. For each tuple <code>tᵢ</code>, its values are defined so that <code>tᵢ[k]=diag[k]</code> if <code>k==i</code>, <code>tᵢ[k]=b</code> otherwise. The result can be seen as a dense diagonal-like array using tuple.</p><p><strong>Example for <code>N=3</code>:</strong></p><pre><code class="nohighlight hljs">(diag[1],  b,       b      ),
(b,        diag[2], b      ),
(b,        b,       diag[3]))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L967-L979">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._get_all_tuple_var_impl-Tuple{Any}"><a class="docstring-binding" href="#Bcube._get_all_tuple_var_impl-Tuple{Any}"><code>Bcube._get_all_tuple_var_impl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_all_tuple_var_impl(N)</code></pre><p>Generate code expression for creating N tuples of diagonal-like structure.</p><p>Used by <code>@generated</code> function <code>_diag_tuples</code> to create efficient code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L955-L961">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._get_multi_tuple_var-Union{Tuple{Tuple{Vararg{Any, N}}}, Tuple{N}} where N"><a class="docstring-binding" href="#Bcube._get_multi_tuple_var-Union{Tuple{Tuple{Vararg{Any, N}}}, Tuple{N}} where N"><code>Bcube._get_multi_tuple_var</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_multi_tuple_var(V::Tuple{Vararg{Any, N}})
_get_multi_tuple_var(a::LazyMapOver)</code></pre><p>Create block-diagonal tuple structure for multi-space shape functions.</p><p>For use in MultiFESpace assembly, where each component space is mapped in a diagonal block pattern with NullOperators elsewhere.</p><p>For N=3 for example:     (LazyMapOver((LazyMapOver(V[1]), NullOperator(),  NullOperator())),      LazyMapOver((NullOperator(),  LazyMapOver(V[2]), NullOperator())),      LazyMapOver((NullOperator(),  NullOperator(),  LazyMapOver(V[3]))))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L988-L1001">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._get_tuple_var-Tuple{Tuple, Any}"><a class="docstring-binding" href="#Bcube._get_tuple_var-Tuple{Tuple, Any}"><code>Bcube._get_tuple_var</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_tuple_var(λ::Tuple, k)
_get_tuple_var(λ, k)</code></pre><p>Create a function that wraps a value into a tuple of NullOperators except at position k.</p><p>For tuple input, returns a function creating tuple of same length. For other inputs, returns identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L928-L936">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._get_tuple_var-Union{Tuple{N}, Tuple{Val{N}, Any}} where N"><a class="docstring-binding" href="#Bcube._get_tuple_var-Union{Tuple{N}, Tuple{Val{N}, Any}} where N"><code>Bcube._get_tuple_var</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_tuple_var(::Val{N}, k)</code></pre><p>Create a function that wraps a value into a tuple of length N with NullOperators.</p><p>The wrapped value is placed at position k, other positions are filled with NullOperators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L902-L908">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._get_tuple_var1_impl-Tuple{Any, Any}"><a class="docstring-binding" href="#Bcube._get_tuple_var1_impl-Tuple{Any, Any}"><code>Bcube._get_tuple_var1_impl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_tuple_var1_impl(N, K)</code></pre><p>Generate code expression for creating a tuple with value at position K.</p><p>Used by <code>@generated</code> function <code>_get_tuple_var1</code> to create efficient code.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L913-L919">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._get_tuple_var_impl-Tuple{Any, Any}"><a class="docstring-binding" href="#Bcube._get_tuple_var_impl-Tuple{Any, Any}"><code>Bcube._get_tuple_var_impl</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_tuple_var_impl(k, N)</code></pre><p>Generate code expression for creating a tuple selecting from diagonal or background value.</p><p>Used by <code>@generated</code> function to efficiently create diagonal-like tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L940-L946">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._linear_integration_type-Tuple{Any, Any}"><a class="docstring-binding" href="#Bcube._linear_integration_type-Tuple{Any, Any}"><code>Bcube._linear_integration_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_linear_integration_type(a, V)</code></pre><p>Determine the integration type (Single or Multi) by evaluating the linear form with a null operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L27-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._map_idofs-Tuple{Bcube.AbstractFESpace, StaticArraysCore.SVector}"><a class="docstring-binding" href="#Bcube._map_idofs-Tuple{Bcube.AbstractFESpace, StaticArraysCore.SVector}"><code>Bcube._map_idofs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_map_idofs(V::AbstractFESpace, idofs::SVector)
_map_idofs(V::AbstractMultiFESpace{N}, idofs::Tuple{Vararg{SVector, N}})</code></pre><p>Map DoF indices for a single or multi FESpace.</p><p>For single spaces, returns the indices unchanged. For multifespaces, the mapping of each FESpace is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L692-L700">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._nnz_bilinear_by_element!-NTuple{5, Any}"><a class="docstring-binding" href="#Bcube._nnz_bilinear_by_element!-NTuple{5, Any}"><code>Bcube._nnz_bilinear_by_element!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_nnz_bilinear_by_element!(ndofs, i, elementInfo, U, V)</code></pre><p>Compute and store the number of nonzero entries for the bilinear form for element <code>elementInfo</code> (ith element in the domain) by trial space <code>U</code> and test space <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L91-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._nnz_bilinear_by_element-Tuple{Bcube.CellInfo, Any, Any}"><a class="docstring-binding" href="#Bcube._nnz_bilinear_by_element-Tuple{Bcube.CellInfo, Any, Any}"><code>Bcube._nnz_bilinear_by_element</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_nnz_bilinear_by_element(elementInfo::CellInfo, U, V)</code></pre><p>Compute the number of nonzero entries for a cell element.</p><p>Returns the product of the number of DoFs in trial space <code>U</code> and test space <code>V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L102-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._nnz_bilinear_by_element-Tuple{Bcube.FaceInfo, Any, Any}"><a class="docstring-binding" href="#Bcube._nnz_bilinear_by_element-Tuple{Bcube.FaceInfo, Any, Any}"><code>Bcube._nnz_bilinear_by_element</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_nnz_bilinear_by_element(elementInfo::FaceInfo, U, V)</code></pre><p>Compute the number of nonzero entries for a face element.</p><p>Accounts for interactions between both sides of the face (n⁻, n⁺), returning the sum of all four combinations: nn, np, pn, pp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L115-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._null_operator-Tuple{Bcube.AbstractFESpace}"><a class="docstring-binding" href="#Bcube._null_operator-Tuple{Bcube.AbstractFESpace}"><code>Bcube._null_operator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_null_operator(::AbstractFESpace)
_null_operator(::AbstractMultiFESpace{N})</code></pre><p>Create a null operator placeholder for a finite element space.</p><p>For single spaces, returns a <code>NullOperator()</code>. For multi spaces, returns a tuple of <code>NullOperator</code>s matching the number of component spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L535-L543">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._offsets_bilinear_contribution-Tuple{Any, Any, Any, Bcube.AbstractBcubeBackend}"><a class="docstring-binding" href="#Bcube._offsets_bilinear_contribution-Tuple{Any, Any, Any, Bcube.AbstractBcubeBackend}"><code>Bcube._offsets_bilinear_contribution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_offsets_bilinear_contribution(U, V, domain, backend::AbstractBcubeBackend)</code></pre><p>Compute the cumulative offsets and total number of degrees of freedom for bilinear form assembly on a domain.</p><p>Returns a tuple <code>(offset, totalDof)</code> where <code>offset</code> is an array of cumulative offsets for each element and <code>totalDof</code> is the total number of local DoFs to store.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._recursive_unwrap-Tuple{Bcube.LazyOperators.AbstractMapOver}"><a class="docstring-binding" href="#Bcube._recursive_unwrap-Tuple{Bcube.LazyOperators.AbstractMapOver}"><code>Bcube._recursive_unwrap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_recursive_unwrap(a::LazyOperators.AbstractMapOver)
_recursive_unwrap(a)</code></pre><p>Recursively unwrap lazy map operations to extract concrete values.</p><p>For <code>AbstractMapOver</code> objects, maps <code>_recursive_unwrap</code> over the elements. For other types, applies <code>unwrap</code> once.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L680-L688">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._unwrap_cell_integrate-Tuple{TestFESpace, Any}"><a class="docstring-binding" href="#Bcube._unwrap_cell_integrate-Tuple{TestFESpace, Any}"><code>Bcube._unwrap_cell_integrate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_unwrap_cell_integrate(::TestFESpace, a)
_unwrap_cell_integrate(::AbstractMultiTestFESpace, a)</code></pre><p>Unwrap lazy evaluation structures for cell integrations.</p><p>Maps <code>unwrap</code> twice over the lazy structure to extract computed values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L748-L755">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._unwrap_face_integrate-Tuple{Union{Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}, Any}"><a class="docstring-binding" href="#Bcube._unwrap_face_integrate-Tuple{Union{Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}, Any}"><code>Bcube._unwrap_face_integrate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_unwrap_face_integrate(::Union{TestFESpace, AbstractMultiTestFESpace}, a)</code></pre><p>Unwrap lazy evaluation structures for face integrations in linear forms.</p><p>Maps <code>unwrap</code> three times to extract values from nested lazy operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L800-L806">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._unwrap_face_integrate-Tuple{Union{Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TrialFESpace, N}}} where N, TrialFESpace}, Union{Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}, Any}"><a class="docstring-binding" href="#Bcube._unwrap_face_integrate-Tuple{Union{Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TrialFESpace, N}}} where N, TrialFESpace}, Union{Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}, Any}"><code>Bcube._unwrap_face_integrate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_unwrap_face_integrate(::Union{TrialFESpace, AbstractMultiTrialFESpace},
                       ::Union{TestFESpace, AbstractMultiTestFESpace}, a)</code></pre><p>Recursively unwrap the lazy evaluation structure for face integrations.</p><p>Extracts the actual computed values from the nested lazy operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L664-L671">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._update_b!-Tuple{Any, Any, Any, Bcube.CellInfo, Any, Bcube.AbstractBcubeBackend}"><a class="docstring-binding" href="#Bcube._update_b!-Tuple{Any, Any, Any, Bcube.CellInfo, Any, Bcube.AbstractBcubeBackend}"><code>Bcube._update_b!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_update_b!(b, V, values, elementInfo::CellInfo, domain, backend)</code></pre><p>Update the linear form vector for a cell element.</p><p>Extracts DoF indices and integrated values, then updates the result vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L727-L733">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._update_b!-Union{Tuple{Tval}, Tuple{TV}, Tuple{B}, Tuple{B, TV, Tval, Bcube.FaceInfo, Any, Bcube.AbstractBcubeBackend}} where {B, TV, Tval}"><a class="docstring-binding" href="#Bcube._update_b!-Union{Tuple{Tval}, Tuple{TV}, Tuple{B}, Tuple{B, TV, Tval, Bcube.FaceInfo, Any, Bcube.AbstractBcubeBackend}} where {B, TV, Tval}"><code>Bcube._update_b!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_update_b!(b, V, values, elementInfo::FaceInfo, domain, backend)</code></pre><p>Update the linear form vector for a face element.</p><p>Handles both sides of the face (n⁻ and n⁺) and updates the corresponding DoFs with the integrated values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L759-L766">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.allocate_bilinear-Tuple{Bcube.AbstractBcubeBackend, Vararg{Any, 4}}"><a class="docstring-binding" href="#Bcube.allocate_bilinear-Tuple{Bcube.AbstractBcubeBackend, Vararg{Any, 4}}"><code>Bcube.allocate_bilinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">allocate_bilinear(backend::AbstractBcubeBackend, a, U, V, T)</code></pre><p>Allocate memory for bilinear form assembly.</p><p>Evaluates the bilinear form <code>a</code> with null operators to determine the integration type (single or multiple domains), then dispatches to the appropriate allocate function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L43-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.allocate_bilinear-Tuple{Bcube.BcubeBackendCPUSerial, Tuple{Vararg{AbstractDomain}}, Any, Any, Any}"><a class="docstring-binding" href="#Bcube.allocate_bilinear-Tuple{Bcube.BcubeBackendCPUSerial, Tuple{Vararg{AbstractDomain}}, Any, Any, Any}"><code>Bcube.allocate_bilinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">allocate_bilinear(backend::BcubeBackendCPUSerial, domains, U, V, T)</code></pre><p>Allocate COO format arrays for bilinear form assembly on given domains.</p><p>Computes the total buffer size needed for all elements in all domains, and allocates COO format arrays (I, J, X) for storing the sparse matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L62-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.allocate_linear-Tuple{Bcube.AbstractBcubeBackend, Any, Any}"><a class="docstring-binding" href="#Bcube.allocate_linear-Tuple{Bcube.AbstractBcubeBackend, Any, Any}"><code>Bcube.allocate_linear</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">allocate_linear(backend::AbstractBcubeBackend, V, T)</code></pre><p>Allocate memory for a linear form vector on finite element space <code>V</code> with element type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L35-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.assemble_bilinear!-Union{Tuple{N}, Tuple{AbstractVector, AbstractVector, AbstractVector, Function, Union{Bcube.AbstractMultiFESpace{N}, TrialFESpace}, Union{Bcube.AbstractMultiFESpace{N}, TestFESpace}}} where N"><a class="docstring-binding" href="#Bcube.assemble_bilinear!-Union{Tuple{N}, Tuple{AbstractVector, AbstractVector, AbstractVector, Function, Union{Bcube.AbstractMultiFESpace{N}, TrialFESpace}, Union{Bcube.AbstractMultiFESpace{N}, TestFESpace}}} where N"><code>Bcube.assemble_bilinear!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assemble_bilinear!(I::AbstractVector, J::AbstractVector, X::AbstractVector,
                   a::Function, U, V) where {N}</code></pre><p>In-place assembly of bilinear form <code>a</code> on spaces <code>U</code> (trial) and <code>V</code> (test).</p><p>Populates the COO format arrays <code>I</code>, <code>J</code>, <code>X</code> representing row indices, column indices, and values of the sparse matrix. Returns the final offset in the arrays.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L188-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.assemble_bilinear-Union{Tuple{N}, Tuple{Function, Union{Bcube.AbstractMultiFESpace{N}, TrialFESpace}, Union{Bcube.AbstractMultiFESpace{N}, TestFESpace}}} where N"><a class="docstring-binding" href="#Bcube.assemble_bilinear-Union{Tuple{N}, Tuple{Function, Union{Bcube.AbstractMultiFESpace{N}, TrialFESpace}, Union{Bcube.AbstractMultiFESpace{N}, TestFESpace}}} where N"><code>Bcube.assemble_bilinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assemble_bilinear(a::Function, U, V; T = Float64)</code></pre><p>Assemble the (sparse) Matrix corresponding to the given bilinear form <code>a</code> on the trial and test finite element spaces <code>U</code> and <code>V</code>.</p><p>For the in-place version, check-out <a href="#Bcube.assemble_bilinear!-Union{Tuple{N}, Tuple{AbstractVector, AbstractVector, AbstractVector, Function, Union{Bcube.AbstractMultiFESpace{N}, TrialFESpace}, Union{Bcube.AbstractMultiFESpace{N}, TestFESpace}}} where N"><code>assemble_bilinear!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>a::Function</code> : function of two variables (u,v) representing the bilinear form</li><li><code>U</code> : trial finite element space (for <code>u</code>)</li><li><code>V</code> : test finite element space (for <code>v</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mesh = rectangle_mesh(3,3)
julia&gt; U = TrialFESpace(FunctionSpace(:Lagrange, 0), mesh)
julia&gt; V = TestFESpace(U)
julia&gt; dΩ = Measure(CellDomain(mesh), 3)
julia&gt; a(u, v) = ∫(u * v)dΩ
julia&gt; assemble_bilinear(a, U, V)
4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
 0.25   ⋅     ⋅     ⋅
  ⋅    0.25   ⋅     ⋅
  ⋅     ⋅    0.25   ⋅
  ⋅     ⋅     ⋅    0.25</code></pre><p><strong>Dev note</strong></p><ul><li>step 1: dispatch on <code>Integration</code>/<code>MultiIntegration</code> with <code>_assemble_bilinear!</code></li><li>step 2: dispatch on <code>SingleFESpace</code>/<code>MultiFESpace</code> with <code>__assemble_bilinear!</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L140-L171">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.assemble_bilinear_by_singleFE!-Union{Tuple{F}, Tuple{VJ}, Tuple{VI}, Tuple{VN}, Tuple{AbstractVector, AbstractVector, AbstractVector, Int64, Val{VN}, Val{VI}, Val{VJ}, F, Measure, Any, Any, Any, Any, Bcube.AbstractBcubeBackend}} where {VN, VI, VJ, F&lt;:Function}"><a class="docstring-binding" href="#Bcube.assemble_bilinear_by_singleFE!-Union{Tuple{F}, Tuple{VJ}, Tuple{VI}, Tuple{VN}, Tuple{AbstractVector, AbstractVector, AbstractVector, Int64, Val{VN}, Val{VI}, Val{VJ}, F, Measure, Any, Any, Any, Any, Bcube.AbstractBcubeBackend}} where {VN, VI, VJ, F&lt;:Function}"><code>Bcube.assemble_bilinear_by_singleFE!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assemble_bilinear_by_singleFE!(
    I::AbstractVector,
    J::AbstractVector,
    X::AbstractVector,
    offset0::Int,
    valN::Val{VN},
    valI::Val{VI},
    valJ::Val{VJ},
    f::F,
    measure::Measure,
    U,
    V,
    _U,
    _V,
    backend::AbstractBcubeBackend,
) where {VN, VI, VJ, F &lt;: Function}</code></pre><p>Assemble bilinear form for a specific pair of component spaces in a MultiFESpace.</p><p>Constructs the appropriate function materialization for the component spaces, and performs assembly, then maps the resulting indices back to the global numbering.</p><p><code>U</code> is the initial multi TrialFESpace, while <code>_U</code> is one of the single TrialFESpace composing <code>U</code>. The same goes with <code>V</code> vs <code>_V</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L364-L389">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.assemble_linear!-Tuple{AbstractVector, Function, Union{Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}}"><a class="docstring-binding" href="#Bcube.assemble_linear!-Tuple{AbstractVector, Function, Union{Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}}"><code>Bcube.assemble_linear!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assemble_linear!(b::AbstractVector, l::Function, V::Union{TestFESpace, AbstractMultiTestFESpace})</code></pre><p>In-place version of <a href="#Bcube.assemble_linear-Tuple{Function, Union{Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}}"><code>assemble_linear</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L460-L464">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.assemble_linear-Tuple{Function, Union{Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}}"><a class="docstring-binding" href="#Bcube.assemble_linear-Tuple{Function, Union{Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}}"><code>Bcube.assemble_linear</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">assemble_linear(l::Function, V::Union{TestFESpace, AbstractMultiTestFESpace}; T = Float64)</code></pre><p>Assemble the vector corresponding to a linear form <code>l</code> on the finite element space <code>V</code></p><p>For the in-place version, checkout <a href="#Bcube.assemble_linear!-Tuple{AbstractVector, Function, Union{Bcube.AbstractMultiFESpace{N, &lt;:Tuple{Vararg{TestFESpace, N}}} where N, TestFESpace}}"><code>assemble_linear!</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>l::Function</code> : linear form to assemble, a function of one variable <code>l(v)</code></li><li><code>V</code> : test finite element space</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mesh = rectangle_mesh(3,3)
julia&gt; U = TrialFESpace(FunctionSpace(:Lagrange, 0), mesh)
julia&gt; V = TestFESpace(U)
julia&gt; dΩ = Measure(CellDomain(mesh), 3)
julia&gt; l(v) = ∫(v)dΩ
julia&gt; assemble_linear(l, V)
4-element Vector{Float64}:
 0.25
 0.25
 0.25
 0.25</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L422-L447">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.blockmap_bilinear_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractFESpace, Bcube.AbstractCellInfo, Bcube.AbstractCellInfo}"><a class="docstring-binding" href="#Bcube.blockmap_bilinear_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractFESpace, Bcube.AbstractCellInfo, Bcube.AbstractCellInfo}"><code>Bcube.blockmap_bilinear_shape_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">blockmap_bilinear_shape_functions(U::AbstractFESpace, V::AbstractFESpace,
                                  cellinfo_u::AbstractCellInfo, cellinfo_v::AbstractCellInfo)</code></pre><p>Return block-mapped bilinear shape functions for possibly different cell shapes.</p><p>Useful for cases where trial and test functions may be defined on different cell types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1139-L1146">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.blockmap_bilinear_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractFESpace, Bcube.AbstractCellInfo}"><a class="docstring-binding" href="#Bcube.blockmap_bilinear_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractFESpace, Bcube.AbstractCellInfo}"><code>Bcube.blockmap_bilinear_shape_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">blockmap_bilinear_shape_functions(
    U::AbstractFESpace,
    V::AbstractFESpace,
    cellinfo::AbstractCellInfo,
)</code></pre><p>Return block-mapped bilinear shape functions for trial and test spaces on a cell.</p><p><strong>Dev notes:</strong></p><p>Return <code>blockU</code> and <code>blockV</code> to be able to compute the local matrix corresponding to the bilinear form :</p><p class="math-container">\[    A[i,j] = a(λᵤ[j], λᵥ[i])\]</p><p>where <code>λᵤ</code> and <code>λᵥ</code> are the shape functions associated with the trial <code>U</code> and the test <code>V</code> function spaces respectively. In a &quot;map-over&quot; version, it can be written :</p><p class="math-container">\[    A = a(blockU, blockV)\]</p><p>where <code>blockU</code> and <code>blockV</code> correspond formally to the lazy-map-over matrices :</p><p class="math-container">\[    ∀k, blockU[k,j] = λᵤ[j],
        blockV[i,k] = λᵥ[i]\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1099-L1126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.blockmap_bilinear_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractFESpace, Bcube.FaceInfo}"><a class="docstring-binding" href="#Bcube.blockmap_bilinear_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractFESpace, Bcube.FaceInfo}"><code>Bcube.blockmap_bilinear_shape_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">blockmap_bilinear_shape_functions(U::AbstractFESpace, V::AbstractFESpace, faceinfo::FaceInfo)</code></pre><p>Return block-mapped bilinear shape functions for face integrations.</p><p>Creates four combinations of shape functions for the two sides of the face (n⁻, n⁺): nn, pn, np, pp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1159-L1166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.blockmap_shape_functions-Tuple{Any, Bcube.FaceInfo}"><a class="docstring-binding" href="#Bcube.blockmap_shape_functions-Tuple{Any, Bcube.FaceInfo}"><code>Bcube.blockmap_shape_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">blockmap_shape_functions(feSpace, faceinfo::FaceInfo)</code></pre><p>Return block-mapped shape functions for a face element.</p><p>Combines shape functions from both sides of the face (n⁻ and n⁺).</p><p><strong>Dev note :</strong></p><p>Materialize the integrand function on all the different possible Tuples of <code>v=(v1,0,0,...), (0,v2,0,...), ..., (..., vi, ...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1044-L1054">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.blockmap_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractCellInfo}"><a class="docstring-binding" href="#Bcube.blockmap_shape_functions-Tuple{Bcube.AbstractFESpace, Bcube.AbstractCellInfo}"><code>Bcube.blockmap_shape_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">blockmap_shape_functions(fespace::AbstractFESpace, cellinfo::AbstractCellInfo)</code></pre><p>Return all shape functions <code>a = LazyMapOver((λ₁, λ₂, …, λₙ))</code> corresponding to <code>fespace</code> in cell <code>cellinfo</code>. These shape functions are wrapped by a <code>LazyMapOver</code> so that for a function <code>f</code> it gives:     <code>f(a) == map(f, a)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1007-L1014">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.blockmap_shape_functions-Tuple{Bcube.AbstractMultiFESpace, Bcube.AbstractCellInfo}"><a class="docstring-binding" href="#Bcube.blockmap_shape_functions-Tuple{Bcube.AbstractMultiFESpace, Bcube.AbstractCellInfo}"><code>Bcube.blockmap_shape_functions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">blockmap_shape_functions(multiFESpace::AbstractMultiFESpace, cellinfo::AbstractCellInfo)</code></pre><p>Return all shape functions corresponding to each <code>fespace</code> in <code>multiFESSpace</code> for cell <code>cellinfo</code> :</p><p class="math-container">\[    ((v₁, ∅, ∅, …), (∅, v₂, ∅, …), …, ( …, ∅, ∅, vₙ))\]</p><p>where:</p><ul><li>vᵢ = (λᵢ<em>₁, λᵢ</em>₂, …, λᵢ_ₘ) are the shapes functions of the i-th fespace in the cell.</li><li>∅ are <code>NullOperator</code>s</li></ul><p>Note that the <code>LazyMapOver</code> is used to wrap recursively the result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1021-L1034">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.compute-Tuple{Bcube.Integration}"><a class="docstring-binding" href="#Bcube.compute-Tuple{Bcube.Integration}"><code>Bcube.compute</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute(integration::Integration)
compute(multi::MultiIntegration)</code></pre><p>Compute an integral, independently from a FEM/DG framework (i.e without FESpace)</p><p>Return a <code>SparseVector</code>. The indices of the domain elements are used to store the result of the integration in this sparse vector.</p><p>For MultiIntegration, it evaluates the sum of all integrals stored in <code>multi</code>, after checking that they are defined on the <strong>same mesh instance</strong> and the <strong>same entity kind</strong> (<code>cells</code> or <code>faces</code>). Subdomain overlaps are allowed and left to the user’s responsibility. Raises an error otherwise.</p><p><strong>Example</strong></p><p>Compute volume of each cell and each face.</p><pre><code class="language-julia hljs">mesh = rectangle_mesh(2, 3)
dΩ = Measure(CellDomain(mesh), 1)
dΓ = Measure(BoundaryFaceDomain(mesh), 1)
f = PhysicalFunction(x -&gt; 1)
@show Bcube.compute(∫(f)dΩ)
@show Bcube.compute(∫(side⁻(f))dΓ)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L1256-L1280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.maywrap-Tuple{Any}"><a class="docstring-binding" href="#Bcube.maywrap-Tuple{Any}"><code>Bcube.maywrap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">maywrap(x)
maywrap(x::AbstractLazyOperator)</code></pre><p>Wrap a value in a <code>LazyWrap</code> unless it is already a lazy operator.</p><p>For lazy operators, returns them unchanged. Otherwise wraps in <code>LazyWrap</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/assembler/assembler.jl#L891-L898">source</a></section></details></article><h2 id="DofHandler"><a class="docs-heading-anchor" href="#DofHandler">DofHandler</a><a id="DofHandler-1"></a><a class="docs-heading-anchor-permalink" href="#DofHandler" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Bcube.DofHandler"><a class="docstring-binding" href="#Bcube.DofHandler"><code>Bcube.DofHandler</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>The <code>DofHandler</code> handles the degree of freedom numbering. To each degree of freedom is associated a unique integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/fespace/dofhandler.jl#L1-L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.DofHandler-Tuple{Bcube.Mesh, Bcube.AbstractFunctionSpace, Int64, Bool}"><a class="docstring-binding" href="#Bcube.DofHandler-Tuple{Bcube.Mesh, Bcube.AbstractFunctionSpace, Int64, Bool}"><code>Bcube.DofHandler</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>DofHandler(mesh::Mesh, fSpace::AbstractFunctionSpace, ncomponents::Int, isContinuous::Bool)</p><p>Constructor of a DofHandler for a <code>SingleFESpace</code> on a <code>Mesh</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/fespace/dofhandler.jl#L32-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._deal_with_dofs_on_edges!-Tuple{Dict{Tuple{Int64, Set{Int64}}, Tuple{Int64, Vector{Int64}}}, Any, Any, Any, Any, Int64, Any, Bcube.AbstractShape, Int64, Bcube.AbstractFunctionSpace}"><a class="docstring-binding" href="#Bcube._deal_with_dofs_on_edges!-Tuple{Dict{Tuple{Int64, Set{Int64}}, Tuple{Int64, Vector{Int64}}}, Any, Any, Any, Any, Int64, Any, Bcube.AbstractShape, Int64, Bcube.AbstractFunctionSpace}"><code>Bcube._deal_with_dofs_on_edges!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">deal_with_dofs_on_edges!(dict, iglob, offset, c2n, celltypes, icell::Int, inodes_g, e2n_g, s::AbstractShape, kvar::Int, fs)</code></pre><p>Function dealing with dofs shared by different cell through an edge connection (excluding bord vertices).</p><p>TODO : remove kvar</p><p><strong>Arguments</strong></p><ul><li><code>dict</code> may be modified by this routine</li><li><code>iglob</code> may be modified by this routine</li><li><code>offset</code> may be modified by this routine</li><li><code>fs</code> : FunctionSpace of var <code>kvar</code></li><li><code>icell</code> : cell index</li><li><code>kvar</code> : var index</li><li><code>s</code> : shape of <code>icell</code>-th cell</li><li><code>inodes_g</code> : global indices of nodes of <code>icell</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/fespace/dofhandler.jl#L222-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._deal_with_dofs_on_faces!-Tuple{Any, Any, Any, Any, Any, Int64, Vector{Vector{Int64}}, Bcube.AbstractShape, Bcube.AbstractFunctionSpace, Int64}"><a class="docstring-binding" href="#Bcube._deal_with_dofs_on_faces!-Tuple{Any, Any, Any, Any, Any, Int64, Vector{Vector{Int64}}, Bcube.AbstractShape, Bcube.AbstractFunctionSpace, Int64}"><code>Bcube._deal_with_dofs_on_faces!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>TODO : remove kvar</p><p><strong>Arguments</strong></p><ul><li>f2n_g : local face index -&gt; global nodes indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/fespace/dofhandler.jl#L294-L299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube._deal_with_dofs_on_vertices!-Tuple{Dict{Tuple{Int64, Int64}, Tuple{Int64, Vector{Int64}}}, Any, Any, Int64, Any, Bcube.AbstractShape, Int64, Bcube.AbstractFunctionSpace}"><a class="docstring-binding" href="#Bcube._deal_with_dofs_on_vertices!-Tuple{Dict{Tuple{Int64, Int64}, Tuple{Int64, Vector{Int64}}}, Any, Any, Int64, Any, Bcube.AbstractShape, Int64, Bcube.AbstractFunctionSpace}"><code>Bcube._deal_with_dofs_on_vertices!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">deal_with_dofs_on_vertices!(dict, iglob, offset, icell::Int, inodes_g, s::AbstractShape, kvar::Int, fs)</code></pre><p>Function dealing with dofs shared by different cell through a vertex connection.</p><p>TODO : remove kvar</p><p><strong>Arguments</strong></p><ul><li><code>dict</code> may be modified by this routine</li><li><code>iglob</code> may be modified by this routine</li><li><code>offset</code> may be modified by this routine</li><li><code>fs</code> : FunctionSpace of var <code>kvar</code></li><li><code>icell</code> : cell index</li><li><code>kvar</code> : var index</li><li><code>s</code> : shape of <code>icell</code>-th cell</li><li><code>inodes_g</code> : global indices of nodes of <code>icell</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/fespace/dofhandler.jl#L163-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.get_dof-Tuple{Bcube.DofHandler, Any, Int64, Int64}"><a class="docstring-binding" href="#Bcube.get_dof-Tuple{Bcube.DofHandler, Any, Int64, Int64}"><code>Bcube.get_dof</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_dof(dhl::DofHandler, icell, icomp::Int, idof::Int)</code></pre><p>Global index of the <code>idof</code> local degree of freedom of component <code>icomp</code> in cell <code>icell</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mesh = one_cell_mesh(:line)
dhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))
@show get_dof(dhl, 1, 1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/fespace/dofhandler.jl#L481-L492">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.get_dof-Tuple{Bcube.DofHandler, Any, Int64}"><a class="docstring-binding" href="#Bcube.get_dof-Tuple{Bcube.DofHandler, Any, Int64}"><code>Bcube.get_dof</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_dof(dhl::DofHandler, icell, icomp::Int)</code></pre><p>Global indices of all the dofs of a given component in a given cell</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mesh = one_cell_mesh(:line)
dhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))
@show get_dof(dhl, 1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/fespace/dofhandler.jl#L497-L508">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.get_ncomponents-Tuple{Bcube.DofHandler}"><a class="docstring-binding" href="#Bcube.get_ncomponents-Tuple{Bcube.DofHandler}"><code>Bcube.get_ncomponents</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of components handled by a DofHandler</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/fespace/dofhandler.jl#L530-L532">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.get_ndofs-Tuple{Bcube.DofHandler, Any, AbstractVector{Int64}}"><a class="docstring-binding" href="#Bcube.get_ndofs-Tuple{Bcube.DofHandler, Any, AbstractVector{Int64}}"><code>Bcube.get_ndofs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ndofs(dhl, icell, icomp::Vector{Int})</code></pre><p>Number of dofs for a given set of components in a given cell.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mesh = one_cell_mesh(:line)
dhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1); size = 2))
@show get_ndofs(dhl, 1, [1, 2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/fespace/dofhandler.jl#L431-L443">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.get_ndofs-Tuple{Bcube.DofHandler, Any, Int64}"><a class="docstring-binding" href="#Bcube.get_ndofs-Tuple{Bcube.DofHandler, Any, Int64}"><code>Bcube.get_ndofs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ndofs(dhl, icell, kvar::Int)</code></pre><p>Number of dofs for a given variable in a given cell.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mesh = one_cell_mesh(:line)
dhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))
@show get_ndofs(dhl, 1, 1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/fespace/dofhandler.jl#L417-L428">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.get_ndofs-Tuple{Bcube.DofHandler, Any}"><a class="docstring-binding" href="#Bcube.get_ndofs-Tuple{Bcube.DofHandler, Any}"><code>Bcube.get_ndofs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ndofs(dhl::DofHandler, icell)</code></pre><p>Number of dofs for a given cell.</p><p>Note that for a vector variable, the total (accross all components) number of dofs is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mesh = one_cell_mesh(:line)
dhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))
@show get_ndofs(dhl, 1, :u)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/fespace/dofhandler.jl#L451-L464">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.get_ndofs-Tuple{Bcube.DofHandler}"><a class="docstring-binding" href="#Bcube.get_ndofs-Tuple{Bcube.DofHandler}"><code>Bcube.get_ndofs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ndofs(dhl::DofHandler)</code></pre><p>Total number of dofs. This function takes into account that dofs can be shared by multiple cells.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">mesh = one_cell_mesh(:line)
dhl = DofHandler(mesh, Variable(:u, FunctionSpace(:Lagrange, 1)))
@show get_ndofs(dhl::DofHandler)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/fespace/dofhandler.jl#L467-L478">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Bcube.max_ndofs-Tuple{Bcube.DofHandler}"><a class="docstring-binding" href="#Bcube.max_ndofs-Tuple{Bcube.DofHandler}"><code>Bcube.max_ndofs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">max_ndofs(dhl::DofHandler)</code></pre><p>Count maximum number of dofs per cell, all components mixed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/bcube-project/Bcube.jl/blob/997abbc93db7cce271a34fdcab3f3375b939fad4/src/fespace/dofhandler.jl#L409-L414">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../integration/integration/">« Integration</a><a class="docs-footer-nextpage" href="../../io/io_interface/">IO interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 17 December 2025 20:13">Wednesday 17 December 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
