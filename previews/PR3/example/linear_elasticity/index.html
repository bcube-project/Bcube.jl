<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear elasticity · Bcube</title><meta name="title" content="Linear elasticity · Bcube"/><meta property="og:title" content="Linear elasticity · Bcube"/><meta property="twitter:title" content="Linear elasticity · Bcube"/><meta name="description" content="Documentation for Bcube."/><meta property="og:description" content="Documentation for Bcube."/><meta property="twitter:description" content="Documentation for Bcube."/><meta property="og:url" content="https://bcube-project.github.io/Bcube.jl/example/linear_elasticity/"/><meta property="twitter:url" content="https://bcube-project.github.io/Bcube.jl/example/linear_elasticity/"/><link rel="canonical" href="https://bcube-project.github.io/Bcube.jl/example/linear_elasticity/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.jpg" alt="Bcube logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Bcube</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorial/helmholtz/">Helmholtz equation (FE)</a></li><li><a class="tocitem" href="../../tutorial/heat_equation/">Heat equation (FE)</a></li><li><a class="tocitem" href="../../tutorial/linear_transport/">Linear transport (DG)</a></li><li><a class="tocitem" href="../../tutorial/phase_field_supercooled/">Phase field model - solidification of a liquid in supercooled state</a></li></ul></li><li><span class="tocitem">Advanced examples</span><ul><li><a class="tocitem" href="../covo/">Euler equations - covo</a></li><li><a class="tocitem" href="../euler_naca_steady/">Euler equations on a NACA0012</a></li><li class="is-active"><a class="tocitem" href>Linear elasticity</a></li><li><a class="tocitem" href="../linear_thermoelasticity/">Linear thermo-elasticity</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/geometry/">Geometry and mesh</a></li><li><a class="tocitem" href="../../manual/integration/">Integration</a></li><li><a class="tocitem" href="../../manual/cellfunction/">Cell function</a></li><li><a class="tocitem" href="../../manual/function_space/">Function and FE spaces</a></li><li><a class="tocitem" href="../../manual/operator/">LazyOperators</a></li></ul></li><li><a class="tocitem" href="../../howto/howto/">How to...</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../api/mesh/mesh/">Mesh</a></li><li><a class="tocitem" href="../../api/mesh/gmsh_utils/">GMSH</a></li><li><a class="tocitem" href="../../api/mesh/mesh_generator/">Mesh generator</a></li><li><a class="tocitem" href="../../api/interpolation/shape/">Reference shape</a></li><li><a class="tocitem" href="../../api/interpolation/function_space/">Function spaces</a></li><li><a class="tocitem" href="../../api/interpolation/spaces/">Available spaces</a></li><li><a class="tocitem" href="../../api/interpolation/fespace/">Finite element spaces</a></li><li><a class="tocitem" href="../../api/mapping/mapping/">Mapping</a></li><li><a class="tocitem" href="../../api/integration/integration/">Integration</a></li><li><a class="tocitem" href="../../api/dof/dof/">Degree of freedom</a></li><li><a class="tocitem" href="../../api/output/vtk/">VTK</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Advanced examples</a></li><li class="is-active"><a href>Linear elasticity</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear elasticity</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/bcube-project/Bcube.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/bcube-project/Bcube.jl/blob/main/docs/src/example/linear_elasticity.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-elasticity"><a class="docs-heading-anchor" href="#Linear-elasticity">Linear elasticity</a><a id="Linear-elasticity-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-elasticity" title="Permalink"></a></h1><pre><code class="language-julia hljs">module linear_elasticity #hide
println(&quot;Running linear elasticity API example...&quot;) #hide

# # Linear elasticity

const dir = string(@__DIR__, &quot;/&quot;) # bcube/example dir
using Bcube
using LinearAlgebra
using WriteVTK
using StaticArrays

# function space (here we shall use Lagrange P1 elements) and quadrature degree.
const fspace = :Lagrange
const degree = 1 # FunctionSpace degree
const degquad = 2 * degree + 1

# Input and output paths
const outputpath = dir * &quot;../myout/elasticity/&quot;
const meshpath = dir * &quot;../input/mesh/domainElast_tri.msh&quot;

# Time stepping scheme params
const α = 0.05
const γ = 0.5 + α
const β = 0.25 * (1.0 + α)^2

# Material parameters (Young&#39;s modulus, Poisson coefficient and deduced Lamé coefficients)
const ρ = 2500.0
const E = 200.0e9
const ν = 0.3
const λ = E * ν / ((1.0 + ν) * (1.0 - 2.0 * ν))
const μ = E / (2.0 * (1.0 + ν))

# Strain tensor and stress tensor (Hooke&#39;s law)
ϵ(u) = 0.5 * (∇(u) + transpose(∇(u)))
σ(u) = λ * tr(ϵ(u)) * I + 2 * μ * ϵ(u)

π(u, v) = σ(u) ⊡ ϵ(v) # with the chosen contraction convention ϵ should be transposed, but as it is symmetric the expression remains correct

# materialize for identity operator
Bcube.materialize(A::LinearAlgebra.UniformScaling, B) = A

# Function that runs the steady case:
function run_steady()
    # read mesh, the second argument specifies the spatial dimension
    mesh = read_msh(meshpath, 2)

    fs = FunctionSpace(fspace, degree)
    U_vec = TrialFESpace(
        fs,
        mesh,
        Dict(&quot;West&quot; =&gt; SA[0.0, 0.0], &quot;East&quot; =&gt; SA[1.0, 0.0]);
        size = 2,
    )
    V_vec = TestFESpace(U_vec)

    # Define measures for cell
    dΩ = Measure(CellDomain(mesh), degquad)

    # no volume force term
    f = PhysicalFunction(x -&gt; SA[0.0, 0.0])

    # definition of bilinear and linear forms
    a(u, v) = ∫(π(u, v))dΩ
    l(v) = ∫(f ⋅ v)dΩ

    # solve using AffineFESystem
    sys = Bcube.AffineFESystem(a, l, U_vec, V_vec)
    ϕ = Bcube.solve(sys)

    Un = var_on_vertices(ϕ, mesh)
    # Write the obtained FE solution
    dict_vars = Dict(&quot;Displacement&quot; =&gt; (transpose(Un), VTKPointData()))
    mkpath(outputpath)
    write_vtk(outputpath * &quot;result_elasticity&quot;, itime, t, mesh, dict_vars; append = false)
end

# Function that performs a time step using a Newmark α-HHT scheme
# The scheme updates the acceleration G, the velocity V and the displacement U using the following formulas:
#
# M G +(1-α)A U + αA U0 = (1-α) L + α L0 = L (because here L is time independent)
# V = V0 + (1-γ) Δt G0 + γ Δt G
# U = U0 + Δt V0 + (0.5-β)*Δt^2 G0 + β Δt^2 G
#
# G is then computed by solving the linear system obtained by inserting the expressions for U and V in the equation for G.
function Newmark_α_HHT(dt, L, A, Mat, U0, V0, G0)
    L1 = L - α * A * U0
    L2 = -(1.0 - α) * (A * U0 + dt * A * V0 + (0.5 - β) * dt * dt * A * G0)
    RHS = L1 .+ L2

    G = Mat \ RHS
    V = V0 + (1.0 - γ) * dt * G0 + γ * dt * G
    U = U0 + dt * V0 + (0.5 - β) * dt * dt * G0 + β * dt * dt * G

    return U, V, G
end

# Function that runs the unsteady case:
function run_unsteady()
    # read mesh, the second argument specifies the spatial dimension
    mesh = read_msh(meshpath, 2)

    fs = FunctionSpace(fspace, degree)
    U_vec = TrialFESpace(fs, mesh, Dict(&quot;West&quot; =&gt; SA[0.0, 0.0]); size = 2)
    V_vec = TestFESpace(U_vec)

    # Define measures for cell
    dΩ = Measure(CellDomain(mesh), degquad)
    Γ = BoundaryFaceDomain(mesh, (&quot;East&quot;,))
    dΓ = Measure(Γ, degquad)

    # surface force to be applied on East boundary
    f = PhysicalFunction(x -&gt; SA[100000.0, 1000.0])

    # Definition of bilinear and linear forms
    a(u, v) = ∫(π(u, v))dΩ
    m(u, v) = ∫(ρ * u ⋅ v)dΩ
    l(v) = ∫(side⁻(f) ⋅ side⁻(v))dΓ

    # Assemble matrices and vector
    M = assemble_bilinear(m, U_vec, V_vec)
    A = assemble_bilinear(a, U_vec, V_vec)
    L = assemble_linear(l, V_vec)

    # Apply homogeneous dirichlet on A and b
    Bcube.apply_homogeneous_dirichlet_to_vector!(L, U_vec, V_vec, mesh)
    Bcube.apply_dirichlet_to_matrix!((A, M), U_vec, V_vec, mesh)

    # Initialize solution
    ϕ = FEFunction(U_vec, 0.0)
    U0 = zeros(Bcube.get_ndofs(U_vec))
    V0 = zeros(Bcube.get_ndofs(U_vec))
    G0 = zeros(Bcube.get_ndofs(U_vec))

    # Write initial solution
    Un = var_on_vertices(ϕ, mesh)
    # Write the obtained FE solution
    dict_vars = Dict(&quot;Displacement&quot; =&gt; (transpose(Un), VTKPointData()))
    mkpath(outputpath)
    write_vtk(outputpath * &quot;result_elasticity&quot;, 0, 0.0, mesh, dict_vars; append = false)

    # Time loop
    totalTime = 1.0e-3
    Δt = 1.0e-6
    itime = 0
    t = 0.0

    # Matrix for time stepping
    Mat = factorize(M + (1.0 - α) * (β * Δt * Δt * A))

    while t &lt;= totalTime
        t += Δt
        itime = itime + 1
        @show t, itime

        # solve time step
        U, V, G = Newmark_α_HHT(Δt, L, A, Mat, U0, V0, G0)

        # Update solution
        U0 .= U
        V0 .= V
        G0 .= G

        set_dof_values!(ϕ, U)

        # Write solution
        if itime % 10 == 0
            Un = var_on_vertices(ϕ, mesh)
            # Write the obtained FE solution
            dict_vars = Dict(&quot;Displacement&quot; =&gt; (transpose(Un), VTKPointData()))
            write_vtk(
                outputpath * &quot;result_elasticity&quot;,
                itime,
                t,
                mesh,
                dict_vars;
                append = true,
            )
            # In order to use the warp function in paraview (solid is deformed using the displacement field)
            # the calculator filter has to be used with the following formula to reconstruct a 3D displacement field
            # with 0 z-component: Displacement_X*iHat+Displacement_Y*jHat+0.0*kHat
        end
    end
end

#run_steady()
run_unsteady()

end #hide</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../euler_naca_steady/">« Euler equations on a NACA0012</a><a class="docs-footer-nextpage" href="../linear_thermoelasticity/">Linear thermo-elasticity »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Sunday 19 November 2023 21:13">Sunday 19 November 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
